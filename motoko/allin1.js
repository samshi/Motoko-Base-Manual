const sample_code={"actor_reference/src/actor_reference/main.mo":"import Nat \"mo:base/Nat\";\nimport Cycles \"mo:base/ExperimentalCycles\";\nimport Debug \"mo:base/Debug\";\n\n\nactor {\n\n  // Use an actor reference to access the well-known, virtual\n  // IC management canister with specified Principal \"aaaaa-aa\",\n  // asserting its interface type\n  // NB: this is a smaller supertype of the full interface at\n  //     https://sdk.dfinity.org/docs/interface-spec/index.html#ic-management-canister\n  let IC =\n    actor \"aaaaa-aa\" : actor {\n\n      create_canister : {\n          // richer in ic.did\n        } -> async { canister_id : Principal };\n\n      canister_status : { canister_id : Principal } ->\n        async { // richer in ic.did\n          cycles : Nat\n        };\n\n      stop_canister : { canister_id : Principal } -> async ();\n\n      delete_canister : { canister_id : Principal } -> async ();\n    };\n\n  // Burn half of this actor's cycle balance by provisioning,\n  // creating, stopping and deleting a fresh canister\n  // (without ever installing any code)\n  public func burn() : async () {\n    Debug.print(\"balance before: \" # Nat.toText(Cycles.balance()));\n    Cycles.add(Cycles.balance()/2);\n    let cid = await IC.create_canister({});\n    let status = await IC.canister_status(cid);\n    Debug.print(\"cycles: \" # Nat.toText(status.cycles));\n    await IC.stop_canister(cid);\n    await IC.delete_canister(cid);\n    Debug.print(\"balance after: \" # Nat.toText(Cycles.balance()));\n  };\n\n};\n","basic_bitcoin/src/basic_bitcoin/src/BitcoinApi.mo":"import ExperimentalCycles \"mo:base/ExperimentalCycles\";\n\nimport Types \"Types\";\n\nmodule {\n  type Cycles = Types.Cycles;\n  type Satoshi = Types.Satoshi;\n  type Network = Types.Network;\n  type BitcoinAddress = Types.BitcoinAddress;\n  type GetUtxosResponse = Types.GetUtxosResponse;\n  type MillisatoshiPerByte = Types.MillisatoshiPerByte;\n  type GetBalanceRequest = Types.GetBalanceRequest;\n  type GetUtxosRequest = Types.GetUtxosRequest;\n  type GetCurrentFeePercentilesRequest = Types.GetCurrentFeePercentilesRequest;\n  type SendTransactionRequest = Types.SendTransactionRequest;\n\n  // The fees for the various Bitcoin endpoints.\n  let GET_BALANCE_COST_CYCLES : Cycles = 100_000_000;\n  let GET_UTXOS_COST_CYCLES : Cycles = 100_000_000;\n  let GET_CURRENT_FEE_PERCENTILES_COST_CYCLES : Cycles = 100_000_000;\n  let SEND_TRANSACTION_BASE_COST_CYCLES : Cycles = 5_000_000_000;\n  let SEND_TRANSACTION_COST_CYCLES_PER_BYTE : Cycles = 20_000_000;\n\n  /// Actor definition to handle interactions with the management canister.\n  type ManagementCanisterActor = actor {\n      bitcoin_get_balance : GetBalanceRequest -> async Satoshi;\n      bitcoin_get_utxos : GetUtxosRequest -> async GetUtxosResponse;\n      bitcoin_get_current_fee_percentiles : GetCurrentFeePercentilesRequest -> async [MillisatoshiPerByte];\n      bitcoin_send_transaction : SendTransactionRequest -> async ();\n  };\n\n  let management_canister_actor : ManagementCanisterActor = actor(\"aaaaa-aa\");\n\n  /// Returns the balance of the given Bitcoin address.\n  ///\n  /// Relies on the `bitcoin_get_balance` endpoint.\n  /// See https://internetcomputer.org/docs/current/references/ic-interface-spec/#ic-bitcoin_get_balance\n  public func get_balance(network : Network, address : BitcoinAddress) : async Satoshi {\n    ExperimentalCycles.add(GET_BALANCE_COST_CYCLES);\n    await management_canister_actor.bitcoin_get_balance({\n        address;\n        network;\n        min_confirmations = null;\n    })\n  };\n\n  /// Returns the UTXOs of the given Bitcoin address.\n  ///\n  /// NOTE: Pagination is ignored in this example. If an address has many thousands\n  /// of UTXOs, then subsequent calls to `bitcoin_get_utxos` are required.\n  ///\n  /// See https://internetcomputer.org/docs/current/references/ic-interface-spec/#ic-bitcoin_get_utxos\n  public func get_utxos(network : Network, address : BitcoinAddress) : async GetUtxosResponse {\n    ExperimentalCycles.add(GET_UTXOS_COST_CYCLES);\n    await management_canister_actor.bitcoin_get_utxos({\n        address;\n        network;\n        filter = null;\n    })\n  };\n\n  /// Returns the 100 fee percentiles measured in millisatoshi/byte.\n  /// Percentiles are computed from the last 10,000 transactions (if available).\n  ///\n  /// Relies on the `bitcoin_get_current_fee_percentiles` endpoint.\n  /// See https://internetcomputer.org/docs/current/references/ic-interface-spec/#ic-bitcoin_get_current_fee_percentiles\n  public func get_current_fee_percentiles(network : Network) : async [MillisatoshiPerByte] {\n    ExperimentalCycles.add(GET_CURRENT_FEE_PERCENTILES_COST_CYCLES);\n    await management_canister_actor.bitcoin_get_current_fee_percentiles({\n        network;\n    })\n  };\n\n  /// Sends a (signed) transaction to the Bitcoin network.\n  ///\n  /// Relies on the `bitcoin_send_transaction` endpoint.\n  /// See https://internetcomputer.org/docs/current/references/ic-interface-spec/#ic-bitcoin_send_transaction\n  public func send_transaction(network : Network, transaction : [Nat8]) : async () {\n    let transaction_fee =\n        SEND_TRANSACTION_BASE_COST_CYCLES + transaction.size() * SEND_TRANSACTION_COST_CYCLES_PER_BYTE;\n\n    ExperimentalCycles.add(transaction_fee);\n    await management_canister_actor.bitcoin_send_transaction({\n        network;\n        transaction;\n    })\n  };\n}","basic_bitcoin/src/basic_bitcoin/src/BitcoinWallet.mo":"//! A demo of a very bare-bones Bitcoin \"wallet\".\n//!\n//! The wallet here showcases how Bitcoin addresses can be be computed\n//! and how Bitcoin transactions can be signed. It is missing several\n//! pieces that any production-grade wallet would have, including:\n//!\n//! * Support for address types that aren't P2PKH.\n//! * Caching spent UTXOs so that they are not reused in future transactions.\n//! * Option to set the fee.\n\nimport Debug \"mo:base/Debug\";\nimport Array \"mo:base/Array\";\nimport Nat8 \"mo:base/Nat8\";\nimport Nat32 \"mo:base/Nat32\";\nimport Nat64 \"mo:base/Nat64\";\nimport Iter \"mo:base/Iter\";\nimport Blob \"mo:base/Blob\";\n\nimport EcdsaTypes \"../../../motoko-bitcoin/src/ecdsa/Types\";\nimport P2pkh \"../../../motoko-bitcoin/src/bitcoin/P2pkh\";\nimport Bitcoin \"../../../motoko-bitcoin/src/bitcoin/Bitcoin\";\nimport Address \"../../../motoko-bitcoin/src/bitcoin/Address\";\nimport Transaction \"../../../motoko-bitcoin/src/bitcoin/Transaction\";\nimport Script \"../../../motoko-bitcoin/src/bitcoin/Script\";\nimport Publickey \"../../../motoko-bitcoin/src/ecdsa/Publickey\";\nimport Der \"../../../motoko-bitcoin/src/ecdsa/Der\";\nimport Affine \"../../../motoko-bitcoin/src/ec/Affine\";\n\nimport Types \"Types\";\nimport EcdsaApi \"EcdsaApi\";\nimport BitcoinApi \"BitcoinApi\";\nimport Utils \"Utils\";\n\nmodule {\n  type Network = Types.Network;\n  type BitcoinAddress = Types.BitcoinAddress;\n  type Satoshi = Types.Satoshi;\n  type Utxo = Types.Utxo;\n  type MillisatoshiPerByte = Types.MillisatoshiPerByte;\n  let CURVE = Types.CURVE;\n  type PublicKey = EcdsaTypes.PublicKey;\n  type Transaction = Transaction.Transaction;\n  type Script = Script.Script;\n  type SighashType = Nat32;\n\n  let SIGHASH_ALL : SighashType = 0x01;\n\n  /// Returns the P2PKH address of this canister at the given derivation path.\n  public func get_p2pkh_address(network : Network, key_name : Text, derivation_path : [[Nat8]]) : async BitcoinAddress {\n    // Fetch the public key of the given derivation path.\n    let public_key = await EcdsaApi.ecdsa_public_key(key_name, Array.map(derivation_path, Blob.fromArray));\n\n    // Compute the address.\n    public_key_to_p2pkh_address(network, Blob.toArray(public_key))\n  };\n\n  /// Sends a transaction to the network that transfers the given amount to the\n  /// given destination, where the source of the funds is the canister itself\n  /// at the given derivation path.\n  public func send(network : Network, derivation_path : [[Nat8]], key_name : Text, dst_address : BitcoinAddress, amount : Satoshi) : async [Nat8] {\n    // Get fee percentiles from previous transactions to estimate our own fee.\n    let fee_percentiles = await BitcoinApi.get_current_fee_percentiles(network);\n\n    let fee_per_byte : MillisatoshiPerByte = if(fee_percentiles.size() == 0) {\n        // There are no fee percentiles. This case can only happen on a regtest\n        // network where there are no non-coinbase transactions. In this case,\n        // we use a default of 1000 millisatoshis/byte (i.e. 2 satoshi/byte)\n        2000\n    } else {\n        // Choose the 50th percentile for sending fees.\n        fee_percentiles[49]\n    };\n\n    // Fetch our public key, P2PKH address, and UTXOs.\n    let own_public_key = Blob.toArray(await EcdsaApi.ecdsa_public_key(key_name, Array.map(derivation_path, Blob.fromArray)));\n    let own_address = public_key_to_p2pkh_address(network, own_public_key);\n\n    Debug.print(\"Fetching UTXOs...\");\n    let own_utxos = (await BitcoinApi.get_utxos(network, own_address)).utxos;\n\n    // Build the transaction that sends `amount` to the destination address.\n    let tx_bytes = await build_transaction(own_public_key, own_address, own_utxos, dst_address, amount, fee_per_byte);\n    let transaction =\n        Utils.get_ok(Transaction.fromBytes(Iter.fromArray(tx_bytes)));\n\n    Debug.print(\"Transaction to sign: \" # debug_show(tx_bytes));\n\n    // Sign the transaction.\n    let signed_transaction_bytes = await sign_transaction(own_public_key, own_address, transaction, key_name, Array.map(derivation_path, Blob.fromArray), EcdsaApi.sign_with_ecdsa);\n    let signed_transaction = Utils.get_ok(Transaction.fromBytes(Iter.fromArray(signed_transaction_bytes)));\n\n    Debug.print(\"Signed transaction: \" # debug_show(signed_transaction_bytes));\n\n    Debug.print(\"Sending transaction...\");\n    await BitcoinApi.send_transaction(network, signed_transaction_bytes);\n    Debug.print(\"Done\");\n\n    signed_transaction.id()\n  };\n\n\n// Builds a transaction to send the given `amount` of satoshis to the\n// destination address.\npublic func build_transaction(\n    own_public_key : [Nat8],\n    own_address : BitcoinAddress,\n    own_utxos : [Utxo],\n    dst_address : BitcoinAddress,\n    amount : Satoshi,\n    fee_per_byte : MillisatoshiPerByte,\n) : async [Nat8] {\n    // We have a chicken-and-egg problem where we need to know the length\n    // of the transaction in order to compute its proper fee, but we need\n    // to know the proper fee in order to figure out the inputs needed for\n    // the transaction.\n    //\n    // We solve this problem iteratively. We start with a fee of zero, build\n    // and sign a transaction, see what its size is, and then update the fee,\n    // rebuild the transaction, until the fee is set to the correct amount.\n    let fee_per_byte_nat = Nat64.toNat(fee_per_byte);\n    Debug.print(\"Building transaction...\");\n    var total_fee : Nat = 0;\n    loop {\n        let transaction =\n            Utils.get_ok_except(Bitcoin.buildTransaction(2, own_utxos, [(#p2pkh dst_address, amount)], #p2pkh own_address, Nat64.fromNat(total_fee)), \"Error building transaction.\");\n\n        // Sign the transaction. In this case, we only care about the size\n        // of the signed transaction, so we use a mock signer here for efficiency.\n        let signed_transaction_bytes = await sign_transaction(\n            own_public_key,\n            own_address,\n            transaction,\n            \"\", // mock key name\n            [], // mock derivation path\n            mock_signer,\n        );\n\n        let signed_tx_bytes_len : Nat = signed_transaction_bytes.size();\n\n        if((signed_tx_bytes_len * fee_per_byte_nat) / 1000 == total_fee) {\n            Debug.print(\"Transaction built with fee \" # debug_show(total_fee));\n            return transaction.toBytes();\n        } else {\n            total_fee := (signed_tx_bytes_len * fee_per_byte_nat) / 1000;\n        }\n    }\n  };\n\n  type SignFun = (Text, [Blob], Blob) -> async Blob;\n\n  // Sign a bitcoin transaction.\n  //\n  // IMPORTANT: This method is for demonstration purposes only and it only\n  // supports signing transactions if:\n  //\n  // 1. All the inputs are referencing outpoints that are owned by `own_address`.\n  // 2. `own_address` is a P2PKH address.\n  public func sign_transaction(\n    own_public_key : [Nat8],\n    own_address : BitcoinAddress,\n    transaction : Transaction,\n    key_name : Text,\n    derivation_path : [Blob],\n    signer : SignFun,\n  ) : async [Nat8] {\n    // Obtain the scriptPubKey of the source address which is also the\n    // scriptPubKey of the Tx output being spent.\n    switch (Address.scriptPubKey(#p2pkh own_address)) {\n      case (#ok scriptPubKey) {\n        let scriptSigs = Array.init<Script>(transaction.txInputs.size(), []);\n\n        // Obtain scriptSigs for each Tx input.\n        for (i in Iter.range(0, transaction.txInputs.size() - 1)) {\n          let sighash = transaction.createSignatureHash(\n              scriptPubKey, Nat32.fromIntWrap(i), SIGHASH_ALL);\n\n          let signature_sec = await signer(key_name, derivation_path, Blob.fromArray(sighash));\n          let signature_der = Blob.toArray(Der.encodeSignature(signature_sec));\n\n          // Append the sighash type.\n          let encodedSignatureWithSighashType = Array.tabulate<Nat8>(\n            signature_der.size() + 1, func (n) {\n              if (n < signature_der.size()) {\n                signature_der[n]\n              } else {\n                Nat8.fromNat(Nat32.toNat(SIGHASH_ALL))\n              };\n          });\n\n          // Create Script Sig which looks like:\n          // ScriptSig = <Signature> <Public Key>.\n          let script = [\n            #data encodedSignatureWithSighashType,\n            #data own_public_key\n          ];\n          scriptSigs[i] := script;\n        };\n        // Assign ScriptSigs to their associated TxInputs.\n        for (i in Iter.range(0, scriptSigs.size() - 1)) {\n          transaction.txInputs[i].script := scriptSigs[i];\n        };\n      };\n      // Verify that our own address is P2PKH.\n      case (#err msg)\n        Debug.trap(\"This example supports signing p2pkh addresses only.\");\n    };\n\n    transaction.toBytes()\n  };\n\n  // Converts a public key to a P2PKH address.\n  func public_key_to_p2pkh_address(network : Network, public_key_bytes : [Nat8]) : BitcoinAddress {\n    let public_key = public_key_bytes_to_public_key(public_key_bytes);\n\n    // Compute the P2PKH address from our public key.\n    P2pkh.deriveAddress(network, Publickey.toSec1(public_key, true))\n  };\n\n  // A mock for rubber-stamping ECDSA signatures.\n  func mock_signer(_key_name : Text, _derivation_path : [Blob], _message_hash : Blob) : async Blob {\n      Blob.fromArray(Array.freeze(Array.init<Nat8>(64, 255)))\n  };\n\n  func public_key_bytes_to_public_key(public_key_bytes : [Nat8]) : PublicKey {\n      let point = Utils.unwrap(Affine.fromBytes(public_key_bytes, CURVE));\n      Utils.get_ok(Publickey.decode(#point point))\n  };\n}\n","basic_bitcoin/src/basic_bitcoin/src/EcdsaApi.mo":"import ExperimentalCycles \"mo:base/ExperimentalCycles\";\n\nimport Types \"Types\";\n\nmodule {\n  type ECDSAPublicKey = Types.ECDSAPublicKey;\n  type ECDSAPublicKeyReply = Types.ECDSAPublicKeyReply;\n  type SignWithECDSA = Types.SignWithECDSA;\n  type SignWithECDSAReply = Types.SignWithECDSAReply;\n\n  /// Actor definition to handle interactions with the ECDSA canister.\n  type EcdsaCanisterActor = actor {\n      ecdsa_public_key : ECDSAPublicKey -> async ECDSAPublicKeyReply;\n      sign_with_ecdsa : SignWithECDSA -> async SignWithECDSAReply;\n  };\n\n  let ecdsa_canister_actor : EcdsaCanisterActor = actor(\"aaaaa-aa\");\n\n  /// Returns the ECDSA public key of this canister at the given derivation path.\n  public func ecdsa_public_key(key_name : Text, derivation_path : [Blob]) : async Blob {\n    // Retrieve the public key of this canister at derivation path\n    // from the ECDSA API.\n    let res = await ecdsa_canister_actor.ecdsa_public_key({\n        canister_id = null;\n        derivation_path;\n        key_id = {\n            curve = #Secp256k1;\n            name = key_name;\n        };\n    });\n        \n    res.public_key\n  };\n\n  public func sign_with_ecdsa(key_name : Text, derivation_path : [Blob], message_hash : Blob) : async Blob {\n    ExperimentalCycles.add(10_000_000_000);\n    let res = await ecdsa_canister_actor.sign_with_ecdsa({\n        message_hash;\n        derivation_path;\n        key_id = {\n            curve = #Secp256k1;\n            name = key_name;\n        };\n    });\n        \n    res.signature\n  };\n}\n","basic_bitcoin/src/basic_bitcoin/src/Main.mo":"import Text \"mo:base/Text\";\n\nimport BitcoinWallet \"BitcoinWallet\";\nimport BitcoinApi \"BitcoinApi\";\nimport Types \"Types\";\nimport Utils \"Utils\";\n\nactor class BasicBitcoin(_network : Types.Network) {\n  type GetUtxosResponse = Types.GetUtxosResponse;\n  type MillisatoshiPerByte = Types.MillisatoshiPerByte;\n  type SendRequest = Types.SendRequest;\n  type Network = Types.Network;\n  type BitcoinAddress = Types.BitcoinAddress;\n  type Satoshi = Types.Satoshi;\n\n  // The Bitcoin network to connect to.\n  //\n  // When developing locally this should be `Regtest`.\n  // When deploying to the IC this should be `Testnet`.\n  // `Mainnet` is currently unsupported.\n  stable let NETWORK : Network = _network;\n\n  // The derivation path to use for ECDSA secp256k1.\n  let DERIVATION_PATH : [[Nat8]] = [];\n\n  // The ECDSA key name.\n  let KEY_NAME : Text = switch NETWORK {\n    // For local development, we use a special test key with dfx.\n    case (#Regtest) \"dfx_test_key\";\n    // On the IC we're using a test ECDSA key.\n    case _ \"test_key_1\"\n  };\n\n  /// Returns the balance of the given Bitcoin address.\n  public func get_balance(address : BitcoinAddress) : async Satoshi {\n    await BitcoinApi.get_balance(NETWORK, address)\n  };\n\n  /// Returns the UTXOs of the given Bitcoin address.\n  public func get_utxos(address : BitcoinAddress) : async GetUtxosResponse {\n    await BitcoinApi.get_utxos(NETWORK, address)\n  };\n\n  /// Returns the 100 fee percentiles measured in millisatoshi/byte.\n  /// Percentiles are computed from the last 10,000 transactions (if available).\n  public func get_current_fee_percentiles() : async [MillisatoshiPerByte] {\n    await BitcoinApi.get_current_fee_percentiles(NETWORK)\n  };\n\n  /// Returns the P2PKH address of this canister at a specific derivation path.\n  public func get_p2pkh_address() : async BitcoinAddress {\n    await BitcoinWallet.get_p2pkh_address(NETWORK, KEY_NAME, DERIVATION_PATH)\n  };\n\n  /// Sends the given amount of bitcoin from this canister to the given address.\n  /// Returns the transaction ID.\n  public func send(request : SendRequest) : async Text {\n    Utils.bytesToText(await BitcoinWallet.send(NETWORK, DERIVATION_PATH, KEY_NAME, request.destination_address, request.amount_in_satoshi))\n  };\n};\n\n","basic_bitcoin/src/basic_bitcoin/src/Types.mo":"import Curves \"../../../motoko-bitcoin/src/ec/Curves\";\n\nmodule Types {\n    public type SendRequest = {\n        destination_address : Text;\n        amount_in_satoshi : Satoshi;\n    };\n\n    public type ECDSAPublicKeyReply = {\n        public_key : Blob;\n        chain_code : Blob;\n    };\n\n    public type EcdsaKeyId = {\n        curve : EcdsaCurve;\n        name : Text;\n    };\n\n    public type EcdsaCurve = {\n        #Secp256k1;\n    };\n\n    public type SignWithECDSAReply = {\n        signature : Blob;\n    };\n\n    public type ECDSAPublicKey = {\n        canister_id : ?Principal;\n        derivation_path : [Blob];\n        key_id : EcdsaKeyId;\n    };\n\n    public type SignWithECDSA = {\n        message_hash : Blob;\n        derivation_path : [Blob];\n        key_id : EcdsaKeyId;\n    };\n\n    public type Satoshi = Nat64;\n    public type MillisatoshiPerByte = Nat64;\n    public type Cycles = Nat;\n    public type BitcoinAddress = Text;\n    public type BlockHash = [Nat8];\n    public type Page = [Nat8];\n\n    public let CURVE = Curves.secp256k1;\n    \n    /// The type of Bitcoin network the dapp will be interacting with.\n    public type Network = {\n        #Mainnet;\n        #Testnet;\n        #Regtest;\n    };\n\n    /// A reference to a transaction output.\n    public type OutPoint = {\n        txid : Blob;\n        vout : Nat32;\n    };\n\n    /// An unspent transaction output.\n    public type Utxo = {\n        outpoint : OutPoint;\n        value : Satoshi;\n        height : Nat32;\n    };\n\n    /// A request for getting the balance for a given address.\n    public type GetBalanceRequest = {\n        address : BitcoinAddress;\n        network : Network;\n        min_confirmations : ?Nat32;\n    };\n\n    /// A filter used when requesting UTXOs.\n    public type UtxosFilter = {\n        #MinConfirmations : Nat32;\n        #Page : Page;\n    };\n\n    /// A request for getting the UTXOs for a given address.\n    public type GetUtxosRequest = {\n        address : BitcoinAddress;\n        network : Network;\n        filter : ?UtxosFilter;\n    };\n\n    /// The response returned for a request to get the UTXOs of a given address.\n    public type GetUtxosResponse = {\n        utxos : [Utxo];\n        tip_block_hash : BlockHash;\n        tip_height : Nat32;\n        next_page : ?Page;\n    };\n\n    /// A request for getting the current fee percentiles.\n    public type GetCurrentFeePercentilesRequest = {\n        network : Network;\n    };\n\n    public type SendTransactionRequest = {\n        transaction : [Nat8];\n        network : Network;\n    };\n}","basic_bitcoin/src/basic_bitcoin/src/Utils.mo":"import Result \"mo:base/Result\";\nimport Debug \"mo:base/Debug\";\nimport Iter \"mo:base/Iter\";\nimport Nat8 \"mo:base/Nat8\";\nimport Prelude \"mo:base/Prelude\";\nimport Text \"mo:base/Text\";\n\nmodule {\n    type Result<Ok, Err> = Result.Result<Ok, Err>;\n\n    /// Returns the value of the result and traps if there isn't any value to return.\n    public func get_ok<T, U>(result : Result<T, U>) : T {\n        switch result {\n            case (#ok value)\n                value;\n            case (#err error)\n                Debug.trap(\"pattern failed\");\n        }\n    };\n\n    /// Returns the value of the result and traps with a custom message if there isn't any value to return.\n    public func get_ok_except<T, U>(result : Result<T, U>, expect : Text) : T {\n        switch result {\n            case (#ok value)\n                value;\n            case (#err error) {\n                Debug.print(\"pattern failed\");\n                Debug.trap(expect);\n            };\n        }\n    };\n\n    /// Unwraps the value of the option.\n    public func unwrap<T>(option : ?T) : T {\n        switch option {\n            case (?value)\n                value;\n            case null\n                Prelude.unreachable();\n        }\n    };\n\n    // Returns the hexadecimal representation of a `Nat8` considered as a `Nat4`.\n    func nat4ToText(nat4 : Nat8) : Text {\n        Text.fromChar(switch nat4 {\n            case 0 '0';\n            case 1 '1';\n            case 2 '2';\n            case 3 '3';\n            case 4 '4';\n            case 5 '5';\n            case 6 '6';\n            case 7 '7';\n            case 8 '8';\n            case 9 '9';\n            case 10 'a';\n            case 11 'b';\n            case 12 'c';\n            case 13 'd';\n            case 14 'e';\n            case 15 'f';\n            case _ Prelude.unreachable();\n        })\n    };\n\n    /// Returns the hexadecimal representation of a `Nat8`.\n    func nat8ToText(byte : Nat8) : Text {\n        let leftNat4 = byte >> 4;\n        let rightNat4 = byte & 15;\n        nat4ToText(leftNat4) # nat4ToText(rightNat4)\n    };\n\n    /// Returns the hexadecimal representation of a byte array.\n    public func bytesToText(bytes : [Nat8]) : Text {\n        Text.join(\"\", Iter.map<Nat8, Text>(Iter.fromArray(bytes), func (n) { nat8ToText(n) }))\n    };\n}\n\n","basic_dao/src/Main.mo":"import Trie \"mo:base/Trie\";\nimport Principal \"mo:base/Principal\";\nimport Option \"mo:base/Option\";\nimport Iter \"mo:base/Iter\";\nimport Nat \"mo:base/Nat\";\nimport Result \"mo:base/Result\";\nimport Error \"mo:base/Error\";\nimport ICRaw \"mo:base/ExperimentalInternetComputer\";\nimport List \"mo:base/List\";\nimport Time \"mo:base/Time\";\nimport Types \"./Types\";\n\nshared actor class DAO(init : Types.BasicDaoStableStorage) = Self {\n    stable var accounts = Types.accounts_fromArray(init.accounts);\n    stable var proposals = Types.proposals_fromArray(init.proposals);\n    stable var next_proposal_id : Nat = 0;\n    stable var system_params : Types.SystemParams = init.system_params;\n\n    system func heartbeat() : async () {\n        await execute_accepted_proposals();\n    };\n\n    func account_get(id : Principal) : ?Types.Tokens = Trie.get(accounts, Types.account_key(id), Principal.equal);\n    func account_put(id : Principal, tokens : Types.Tokens) {\n        accounts := Trie.put(accounts, Types.account_key(id), Principal.equal, tokens).0;\n    };\n    func proposal_get(id : Nat) : ?Types.Proposal = Trie.get(proposals, Types.proposal_key(id), Nat.equal);\n    func proposal_put(id : Nat, proposal : Types.Proposal) {\n        proposals := Trie.put(proposals, Types.proposal_key(id), Nat.equal, proposal).0;\n    };\n\n\n    /// Transfer tokens from the caller's account to another account\n    public shared({caller}) func transfer(transfer: Types.TransferArgs) : async Types.Result<(), Text> {\n        switch (account_get caller) {\n        case null { #err \"Caller needs an account to transfer funds\" };\n        case (?from_tokens) {\n                 let fee = system_params.transfer_fee.amount_e8s;\n                 let amount = transfer.amount.amount_e8s;\n                 if (from_tokens.amount_e8s < amount + fee) {\n                     #err (\"Caller's account has insufficient funds to transfer \" # debug_show(amount));\n                 } else {\n                     let from_amount : Nat = from_tokens.amount_e8s - amount - fee;\n                     account_put(caller, { amount_e8s = from_amount });\n                     let to_amount = Option.get(account_get(transfer.to), Types.zeroToken).amount_e8s + amount;\n                     account_put(transfer.to, { amount_e8s = to_amount });\n                     #ok;\n                 };\n        };\n      };\n    };\n\n    /// Return the account balance of the caller\n    public query({caller}) func account_balance() : async Types.Tokens {\n        Option.get(account_get(caller), Types.zeroToken)\n    };\n\n    /// Lists all accounts\n    public query func list_accounts() : async [Types.Account] {\n        Iter.toArray(\n          Iter.map(Trie.iter(accounts),\n                   func ((owner : Principal, tokens : Types.Tokens)) : Types.Account = { owner; tokens }))\n    };\n\n    /// Submit a proposal\n    ///\n    /// A proposal contains a canister ID, method name and method args. If enough users\n    /// vote \"yes\" on the proposal, the given method will be called with the given method\n    /// args on the given canister.\n    public shared({caller}) func submit_proposal(payload: Types.ProposalPayload) : async Types.Result<Nat, Text> {\n        Result.chain(deduct_proposal_submission_deposit(caller), func (()) : Types.Result<Nat, Text> {\n            let proposal_id = next_proposal_id;\n            next_proposal_id += 1;\n\n            let proposal : Types.Proposal = {\n                id = proposal_id;\n                timestamp = Time.now();\n                proposer = caller;\n                payload;\n                state = #open;\n                votes_yes = Types.zeroToken;\n                votes_no = Types.zeroToken;\n                voters = List.nil();\n            };\n            proposal_put(proposal_id, proposal);\n            #ok(proposal_id)\n        })\n    };\n\n    /// Return the proposal with the given ID, if one exists\n    public query func get_proposal(proposal_id: Nat) : async ?Types.Proposal {\n        proposal_get(proposal_id)\n    };\n\n    /// Return the list of all proposals\n    public query func list_proposals() : async [Types.Proposal] {\n        Iter.toArray(Iter.map(Trie.iter(proposals), func (kv : (Nat, Types.Proposal)) : Types.Proposal = kv.1))\n    };\n\n    // Vote on an open proposal\n    public shared({caller}) func vote(args: Types.VoteArgs) : async Types.Result<Types.ProposalState, Text> {\n        switch (proposal_get(args.proposal_id)) {\n        case null { #err(\"No proposal with ID \" # debug_show(args.proposal_id) # \" exists\") };\n        case (?proposal) {\n                 var state = proposal.state;\n                 if (state != #open) {\n                     return #err(\"Proposal \" # debug_show(args.proposal_id) # \" is not open for voting\");\n                 };\n                 switch (account_get(caller)) {\n                 case null { return #err(\"Caller does not have any tokens to vote with\") };\n                 case (?{ amount_e8s = voting_tokens }) {\n                          if (List.some(proposal.voters, func (e : Principal) : Bool = e == caller)) {\n                              return #err(\"Already voted\");\n                          };\n                          \n                          var votes_yes = proposal.votes_yes.amount_e8s;\n                          var votes_no = proposal.votes_no.amount_e8s;\n                          switch (args.vote) {\n                          case (#yes) { votes_yes += voting_tokens };\n                          case (#no) { votes_no += voting_tokens };\n                          };\n                          let voters = List.push(caller, proposal.voters);\n\n                          if (votes_yes >= system_params.proposal_vote_threshold.amount_e8s) {\n                              // Refund the proposal deposit when the proposal is accepted\n                              ignore do ? {\n                                  let account = account_get(proposal.proposer)!;\n                                  let refunded = account.amount_e8s + system_params.proposal_submission_deposit.amount_e8s;\n                                  account_put(proposal.proposer, { amount_e8s = refunded });\n                              };\n                              state := #accepted;\n                          };\n                          \n                          if (votes_no >= system_params.proposal_vote_threshold.amount_e8s) {\n                              state := #rejected;\n                          };\n\n                          let updated_proposal = {\n                              id = proposal.id;\n                              votes_yes = { amount_e8s = votes_yes };                              \n                              votes_no = { amount_e8s = votes_no };\n                              voters;\n                              state;\n                              timestamp = proposal.timestamp;\n                              proposer = proposal.proposer;\n                              payload = proposal.payload;\n                          };\n                          proposal_put(args.proposal_id, updated_proposal);\n                      };\n                 };\n                 #ok(state)\n             };\n        };\n    };\n\n    /// Get the current system params\n    public query func get_system_params() : async Types.SystemParams { system_params };\n\n    /// Update system params\n    ///\n    /// Only callable via proposal execution\n    public shared({caller}) func update_system_params(payload: Types.UpdateSystemParamsPayload) : async () {\n        if (caller != Principal.fromActor(Self)) {\n            return;\n        };\n        system_params := {\n            transfer_fee = Option.get(payload.transfer_fee, system_params.transfer_fee);\n            proposal_vote_threshold = Option.get(payload.proposal_vote_threshold, system_params.proposal_vote_threshold);\n            proposal_submission_deposit = Option.get(payload.proposal_submission_deposit, system_params.proposal_submission_deposit);\n        };\n    };\n\n    /// Deduct the proposal submission deposit from the caller's account\n    func deduct_proposal_submission_deposit(caller : Principal) : Types.Result<(), Text> {\n        switch (account_get(caller)) {\n        case null { #err \"Caller needs an account to submit a proposal\" };\n        case (?from_tokens) {\n                 let threshold = system_params.proposal_submission_deposit.amount_e8s;\n                 if (from_tokens.amount_e8s < threshold) {\n                     #err (\"Caller's account must have at least \" # debug_show(threshold) # \" to submit a proposal\")\n                 } else {\n                     let from_amount : Nat = from_tokens.amount_e8s - threshold;\n                     account_put(caller, { amount_e8s = from_amount });\n                     #ok\n                 };\n             };\n        };\n    };\n\n    /// Execute all accepted proposals\n    func execute_accepted_proposals() : async () {\n        let accepted_proposals = Trie.filter(proposals, func (_ : Nat, proposal : Types.Proposal) : Bool = proposal.state == #accepted);\n        // Update proposal state, so that it won't be picked up by the next heartbeat\n        for ((id, proposal) in Trie.iter(accepted_proposals)) {\n            update_proposal_state(proposal, #executing);\n        };\n\n        for ((id, proposal) in Trie.iter(accepted_proposals)) {\n            switch (await execute_proposal(proposal)) {\n            case (#ok) { update_proposal_state(proposal, #succeeded); };\n            case (#err(err)) { update_proposal_state(proposal, #failed(err)); };\n            };\n        };\n    };\n\n    /// Execute the given proposal\n    func execute_proposal(proposal: Types.Proposal) : async Types.Result<(), Text> {\n        try {\n            let payload = proposal.payload;\n            ignore await ICRaw.call(payload.canister_id, payload.method, payload.message);\n            #ok\n        }\n        catch (e) { #err(Error.message e) };\n    };\n\n    func update_proposal_state(proposal: Types.Proposal, state: Types.ProposalState) {\n        let updated = {\n            state;\n            id = proposal.id;\n            votes_yes = proposal.votes_yes;\n            votes_no = proposal.votes_no;\n            voters = proposal.voters;\n            timestamp = proposal.timestamp;\n            proposer = proposal.proposer;\n            payload = proposal.payload;\n        };\n        proposal_put(proposal.id, updated);\n    };\n};\n","basic_dao/src/Types.mo":"import Result \"mo:base/Result\";\nimport Trie \"mo:base/Trie\";\nimport Int \"mo:base/Int\";\nimport Nat \"mo:base/Nat\";\nimport List \"mo:base/List\";\nimport Principal \"mo:base/Principal\";\n\nmodule {\n  public type Result<T, E> = Result.Result<T, E>;\n  public type Account = { owner : Principal; tokens : Tokens };\n  public type Proposal = {\n    id : Nat;\n    votes_no : Tokens;\n    voters : List.List<Principal>;\n    state : ProposalState;\n    timestamp : Int;\n    proposer : Principal;\n    votes_yes : Tokens;\n    payload : ProposalPayload;\n  };\n  public type ProposalPayload = {\n    method : Text;\n    canister_id : Principal;\n    message : Blob;\n  };\n  public type ProposalState = {\n      // A failure occurred while executing the proposal\n      #failed : Text;\n      // The proposal is open for voting\n      #open;\n      // The proposal is currently being executed\n      #executing;\n      // Enough \"no\" votes have been cast to reject the proposal, and it will not be executed\n      #rejected;\n      // The proposal has been successfully executed\n      #succeeded;\n      // Enough \"yes\" votes have been cast to accept the proposal, and it will soon be executed\n      #accepted;\n  };\n  public type Tokens = { amount_e8s : Nat };\n  public type TransferArgs = { to : Principal; amount : Tokens };\n  public type UpdateSystemParamsPayload = {\n    transfer_fee : ?Tokens;\n    proposal_vote_threshold : ?Tokens;\n    proposal_submission_deposit : ?Tokens;\n  };\n  public type Vote = { #no; #yes };\n  public type VoteArgs = { vote : Vote; proposal_id : Nat };\n\n  public type SystemParams = {\n    transfer_fee: Tokens;\n\n    // The amount of tokens needed to vote \"yes\" to accept, or \"no\" to reject, a proposal\n    proposal_vote_threshold: Tokens;\n\n    // The amount of tokens that will be temporarily deducted from the account of\n    // a user that submits a proposal. If the proposal is Accepted, this deposit is returned,\n    // otherwise it is lost. This prevents users from submitting superfluous proposals.\n    proposal_submission_deposit: Tokens;\n  };\n  public type BasicDaoStableStorage = {\n    accounts: [Account];\n    proposals: [Proposal];\n    system_params: SystemParams;\n  };\n\n  public func proposal_key(t: Nat) : Trie.Key<Nat> = { key = t; hash = Int.hash t };\n  public func account_key(t: Principal) : Trie.Key<Principal> = { key = t; hash = Principal.hash t };\n  public func accounts_fromArray(arr: [Account]) : Trie.Trie<Principal, Tokens> {\n      var s = Trie.empty<Principal, Tokens>();\n      for (account in arr.vals()) {\n          s := Trie.put(s, account_key(account.owner), Principal.equal, account.tokens).0;\n      };\n      s\n  };\n  public func proposals_fromArray(arr: [Proposal]) : Trie.Trie<Nat, Proposal> {\n      var s = Trie.empty<Nat, Proposal>();\n      for (proposal in arr.vals()) {\n          s := Trie.put(s, proposal_key(proposal.id), Nat.equal, proposal).0;\n      };\n      s\n  };\n  \n  public let oneToken = { amount_e8s = 10_000_000 };\n  public let zeroToken = { amount_e8s = 0 };  \n}\n","calc/src/Main.mo":"actor Calc {\n\n  var cell : Int = 0;\n\n  // Add.\n  public func add(n : Int) : async Int {\n    cell += n;\n    return cell;\n  };\n\n  // Subtract.\n  public func sub(n : Int) : async Int {\n    cell -= n;\n    return cell;\n  };\n\n  // Multiply.\n  public func mul(n : Int) : async Int {\n    cell *= n;\n    return cell;\n  };\n\n  // Divide.\n  public func div(n : Int) : async ?Int {\n    if (n == 0) {\n      // 'null' encodes the division by zero error.\n      return null;\n    } else {\n      cell /= n;\n      return ?cell;\n    };\n  };\n\n  // Clear the calculator and reset its cell to zero.\n  public func clearall() : async () {\n    cell := 0;\n  };\n};\n","cert-var/src/cert_var/main.mo":"/// Simple counter (see `Counter.mo`), but uses `mo:base/CertifiedData` to\n/// implement the counter value as a certified variable.\nimport CD \"mo:base/CertifiedData\";\nimport Blob \"mo:base/Blob\";\nimport Nat8 \"mo:base/Nat8\";\nimport Nat32 \"mo:base/Nat32\";\nimport Debug \"mo:base/Debug\";\n\nactor Variable {\n\n  var value : Nat32 = 0;\n\n  /// Helper; should be in base?\n  /// LE encoding matches Candid encoding of Nat32, for consistency and convenience.\n  func blobOfNat32(n : Nat32) : Blob {\n    let byteMask : Nat32 = 0xff;\n    func byte(x : Nat32) : Nat8 {\n      Nat8.fromNat(Nat32.toNat(x))\n    };\n    Blob.fromArray(\n      [byte(((byteMask << 0 ) & value) >> 0),\n       byte(((byteMask << 8 ) & value) >> 8),\n       byte(((byteMask << 16) & value) >> 16),\n       byte(((byteMask << 24) & value) >> 24)])\n  };\n\n  /// Update counter and certificate (via system).\n  public func inc() : async Nat32 {\n    value += 1;\n    CD.set(blobOfNat32(value));\n    return value;\n  };\n\n  public func set(newValue : Nat32) : async () {\n    value := newValue;\n    CD.set(blobOfNat32(value));\n  };\n\n  /// Returns the current counter value,\n  /// and, if available, an unforgeable certificate (from the system) about its authenticity.\n  /// When called via update call or inter-canister call, no certificate is present (and not needed,\n  /// as in these cases the system already certifies the response)\n  public query func get() : async { value : Nat32; certificate : ?Blob } {\n    return { value; certificate = CD.getCertificate() }\n  };\n}\n","classes/src/map/Buckets.mo":"import Nat \"mo:base/Nat\";\nimport Map \"mo:base/RBTree\";\n\nactor class Bucket(n : Nat, i : Nat) {\n\n  type Key = Nat;\n  type Value = Text;\n\n  let map = Map.RBTree<Key, Value>(Nat.compare);\n\n  public func get(k : Key) : async ?Value {\n    assert((k % n) == i);\n    map.get(k);\n  };\n\n  public func put(k : Key, v : Value) : async () {\n    assert((k % n) == i);\n    map.put(k,v);\n  };\n\n};\n","classes/src/map/Map.mo":"import Array \"mo:base/Array\";\nimport Cycles \"mo:base/ExperimentalCycles\";\nimport Buckets \"Buckets\";\n\nactor Map {\n\n  let n = 4; // number of buckets\n\n  // divide initial balance amongst self and buckets\n  let cycleShare = Cycles.balance()/(n + 1);\n\n  type Key = Nat;\n  type Value = Text;\n\n  type Bucket = Buckets.Bucket;\n\n  let buckets : [var ?Bucket] = Array.init(n, null);\n\n  public func get(k : Key) : async ?Value {\n    switch (buckets[k % n]) {\n      case null null;\n      case (?bucket) await bucket.get(k);\n    };\n  };\n\n  public func put(k : Key, v : Value) : async () {\n    let i = k % n;\n    let bucket = switch (buckets[i]) {\n      case null {\n        // provision next send, i.e. Bucket(n, i), with cycles\n        Cycles.add(cycleShare);\n        let b = await Buckets.Bucket(n, i); // dynamically install a new Bucket\n        buckets[i] := ?b;\n        b;\n      };\n      case (?bucket) bucket;\n    };\n    await bucket.put(k, v);\n  };\n\n};\n","classes/src/test/Test.mo":"import Debug \"mo:base/Debug\";\nimport Map \"canister:map\";\n\nactor Test {\n\n  public func run() : async () {\n    var i = 0;\n    while (i < 16) {\n      let t = debug_show(i);\n      assert (null == (await Map.get(i)));\n      Debug.print(\"putting: \" # debug_show(i, t));\n      await Map.put(i, t);\n      assert (?t == (await Map.get(i)));\n      i += 1;\n    };\n  };\n\n};\n","counter/src/Main.mo":"actor Counter {\n\n  stable var counter = 0;\n\n  // Get the value of the counter.\n  public query func get() : async Nat {\n    return counter;\n  };\n\n  // Set the value of the counter.\n  public func set(n : Nat) : async () {\n    counter := n;\n  };\n\n  // Increment the value of the counter.\n  public func inc() : async () {\n    counter += 1;\n  };\n};\n","defi/src/DIP20/motoko/src/token.mo":"/**\n * Module     : token.mo\n * Copyright  : 2021 DFinance Team\n * License    : Apache 2.0 with LLVM Exception\n * Maintainer : DFinance Team <hello@dfinance.ai>\n * Stability  : Experimental\n */\n\nimport HashMap \"mo:base/HashMap\";\nimport Principal \"mo:base/Principal\";\nimport Types \"./types\";\nimport Time \"mo:base/Time\";\nimport Iter \"mo:base/Iter\";\nimport Array \"mo:base/Array\";\nimport Option \"mo:base/Option\";\nimport Order \"mo:base/Order\";\nimport Nat \"mo:base/Nat\";\nimport Result \"mo:base/Result\";\nimport ExperimentalCycles \"mo:base/ExperimentalCycles\";\n\nshared(msg) actor class Token(\n    _logo: Text,\n    _name: Text,\n    _symbol: Text,\n    _decimals: Nat8,\n    _totalSupply: Nat,\n    _owner: Principal,\n    _fee: Nat\n    ) {\n    type Operation = Types.Operation;\n    type TransactionStatus = Types.TransactionStatus;\n    type TxRecord = Types.TxRecord;\n    type Metadata = {\n        logo : Text;\n        name : Text;\n        symbol : Text;\n        decimals : Nat8;\n        totalSupply : Nat;\n        owner : Principal;\n        fee : Nat;\n    };\n    // returns tx index or error msg\n    public type TxReceipt = {\n        #Ok: Nat;\n        #Err: {\n            #InsufficientAllowance;\n            #InsufficientBalance;\n            #ErrorOperationStyle;\n            #Unauthorized;\n            #LedgerTrap;\n            #ErrorTo;\n            #Other;\n            #BlockUsed;\n            #AmountTooSmall;\n        };\n    };\n\n    private stable var owner_ : Principal = _owner;\n    private stable var logo_ : Text = _logo;\n    private stable var name_ : Text = _name;\n    private stable var decimals_ : Nat8 = _decimals;\n    private stable var symbol_ : Text = _symbol;\n    private stable var totalSupply_ : Nat = _totalSupply;\n    private stable var blackhole : Principal = Principal.fromText(\"aaaaa-aa\");\n    private stable var feeTo : Principal = owner_;\n    private stable var fee : Nat = _fee;\n    private stable var balanceEntries : [(Principal, Nat)] = [];\n    private stable var allowanceEntries : [(Principal, [(Principal, Nat)])] = [];\n    private var balances = HashMap.HashMap<Principal, Nat>(1, Principal.equal, Principal.hash);\n    private var allowances = HashMap.HashMap<Principal, HashMap.HashMap<Principal, Nat>>(1, Principal.equal, Principal.hash);\n    balances.put(owner_, totalSupply_);\n    private stable let genesis : TxRecord = {\n        caller = ?owner_;\n        op = #mint;\n        index = 0;\n        from = blackhole;\n        to = owner_;\n        amount = totalSupply_;\n        fee = 0;\n        timestamp = Time.now();\n        status = #succeeded;\n    };\n    private stable var ops : [TxRecord] = [genesis];\n\n    private func addRecord(\n        caller: ?Principal, op: Operation, from: Principal, to: Principal, amount: Nat,\n        fee: Nat, timestamp: Time.Time, status: TransactionStatus\n    ): Nat {\n        let index = ops.size();\n        let o : TxRecord = {\n            caller = caller;\n            op = op;\n            index = index;\n            from = from;\n            to = to;\n            amount = amount;\n            fee = fee;\n            timestamp = timestamp;\n            status = status;\n        };\n        ops := Array.append(ops, [o]);\n        return index;\n    };\n\n    private func _chargeFee(from: Principal, fee: Nat) {\n        if(fee > 0) {\n            _transfer(from, feeTo, fee);\n        };\n    };\n\n    private func _transfer(from: Principal, to: Principal, value: Nat) {\n        let from_balance = _balanceOf(from);\n        let from_balance_new : Nat = from_balance - value;\n        if (from_balance_new != 0) { balances.put(from, from_balance_new); }\n        else { balances.delete(from); };\n\n        let to_balance = _balanceOf(to);\n        let to_balance_new : Nat = to_balance + value;\n        if (to_balance_new != 0) { balances.put(to, to_balance_new); };\n    };\n\n    private func _balanceOf(who: Principal) : Nat {\n        switch (balances.get(who)) {\n            case (?balance) { return balance; };\n            case (_) { return 0; };\n        }\n    };\n\n    private func _allowance(owner: Principal, spender: Principal) : Nat {\n        switch(allowances.get(owner)) {\n            case (?allowance_owner) {\n                switch(allowance_owner.get(spender)) {\n                    case (?allowance) { return allowance; };\n                    case (_) { return 0; };\n                }\n            };\n            case (_) { return 0; };\n        }\n    };\n\n    /*\n    *   Core interfaces:\n    *       update calls:\n    *           transfer/transferFrom/approve\n    *       query calls:\n    *           logo/name/symbol/decimal/totalSupply/balanceOf/allowance/getMetadata\n    *           historySize/getTransaction/getTransactions\n    */\n\n    /// Transfers value amount of tokens to Principal to.\n    public shared(msg) func transfer(to: Principal, value: Nat) : async TxReceipt {\n        if (_balanceOf(msg.caller) < value + fee) { return #Err(#InsufficientBalance); };\n        _chargeFee(msg.caller, fee);\n        _transfer(msg.caller, to, value);\n        let txid = addRecord(null, #transfer, msg.caller, to, value, fee, Time.now(), #succeeded);\n        return #Ok(txid);\n    };\n\n    /// Transfers value amount of tokens from Principal from to Principal to.\n    public shared(msg) func transferFrom(from: Principal, to: Principal, value: Nat) : async TxReceipt {\n        if (_balanceOf(from) < value + fee) { return #Err(#InsufficientBalance); };\n        let allowed : Nat = _allowance(from, msg.caller);\n        if (allowed < value + fee) { return #Err(#InsufficientAllowance); };\n        _chargeFee(from, fee);\n        _transfer(from, to, value);\n        let allowed_new : Nat = allowed - value - fee;\n        if (allowed_new != 0) {\n            let allowance_from = Types.unwrap(allowances.get(from));\n            allowance_from.put(msg.caller, allowed_new);\n            allowances.put(from, allowance_from);\n        } else {\n            if (allowed != 0) {\n                let allowance_from = Types.unwrap(allowances.get(from));\n                allowance_from.delete(msg.caller);\n                if (allowance_from.size() == 0) { allowances.delete(from); }\n                else { allowances.put(from, allowance_from); };\n            };\n        };\n        let txid = addRecord(?msg.caller, #transferFrom, from, to, value, fee, Time.now(), #succeeded);\n        return #Ok(txid);\n    };\n\n    /// Allows spender to withdraw from your account multiple times, up to the value amount.\n    /// If this function is called again it overwrites the current allowance with value.\n    public shared(msg) func approve(spender: Principal, value: Nat) : async TxReceipt {\n        if(_balanceOf(msg.caller) < fee) { return #Err(#InsufficientBalance); };\n        _chargeFee(msg.caller, fee);\n        let v = value + fee;\n        if (value == 0 and Option.isSome(allowances.get(msg.caller))) {\n            let allowance_caller = Types.unwrap(allowances.get(msg.caller));\n            allowance_caller.delete(spender);\n            if (allowance_caller.size() == 0) { allowances.delete(msg.caller); }\n            else { allowances.put(msg.caller, allowance_caller); };\n        } else if (value != 0 and Option.isNull(allowances.get(msg.caller))) {\n            var temp = HashMap.HashMap<Principal, Nat>(1, Principal.equal, Principal.hash);\n            temp.put(spender, v);\n            allowances.put(msg.caller, temp);\n        } else if (value != 0 and Option.isSome(allowances.get(msg.caller))) {\n            let allowance_caller = Types.unwrap(allowances.get(msg.caller));\n            allowance_caller.put(spender, v);\n            allowances.put(msg.caller, allowance_caller);\n        };\n        let txid = addRecord(null, #approve, msg.caller, spender, v, fee, Time.now(), #succeeded);\n        return #Ok(txid);\n    };\n\n    public shared(msg) func mint(to: Principal, amount: Nat): async TxReceipt {\n        if(msg.caller != owner_) {\n            return #Err(#Unauthorized);\n        };\n        let to_balance = _balanceOf(to);\n        totalSupply_ += amount;\n        balances.put(to, to_balance + amount);\n        let txid = addRecord(?msg.caller, #mint, blackhole, to, amount, 0, Time.now(), #succeeded);\n        return #Ok(txid);\n    };\n\n    public shared(msg) func burn(amount: Nat): async TxReceipt {\n        let from_balance = _balanceOf(msg.caller);\n        if(from_balance < amount) {\n            return #Err(#InsufficientBalance);\n        };\n        totalSupply_ -= amount;\n        balances.put(msg.caller, from_balance - amount);\n        let txid = addRecord(?msg.caller, #burn, msg.caller, blackhole, amount, 0, Time.now(), #succeeded);\n        return #Ok(txid);\n    };\n\n    public query func logo() : async Text {\n        return logo_;\n    };\n\n    public query func name() : async Text {\n        return name_;\n    };\n\n    public query func symbol() : async Text {\n        return symbol_;\n    };\n\n    public query func decimals() : async Nat8 {\n        return decimals_;\n    };\n\n    public query func totalSupply() : async Nat {\n        return totalSupply_;\n    };\n\n    public query func getTokenFee() : async Nat {\n        return fee;\n    };\n\n    public query func balanceOf(who: Principal) : async Nat {\n        return _balanceOf(who);\n    };\n\n    public query func allowance(owner: Principal, spender: Principal) : async Nat {\n        return _allowance(owner, spender);\n    };\n\n    public query func getMetadata() : async Metadata {\n        return {\n            logo = logo_;\n            name = name_;\n            symbol = symbol_;\n            decimals = decimals_;\n            totalSupply = totalSupply_;\n            owner = owner_;\n            fee = fee;\n        };\n    };\n\n    /// Get transaction history size\n    public query func historySize() : async Nat {\n        return ops.size();\n    };\n\n    /// Get transaction by index.\n    public query func getTransaction(index: Nat) : async TxRecord {\n        return ops[index];\n    };\n\n    /// Get history\n    public query func getTransactions(start: Nat, limit: Nat) : async [TxRecord] {\n        var ret: [TxRecord] = [];\n        var i = start;\n        while(i < start + limit and i < ops.size()) {\n            ret := Array.append(ret, [ops[i]]);\n            i += 1;\n        };\n        return ret;\n    };\n\n    /*\n    *   Optional interfaces:\n    *       setName/setLogo/setFee/setFeeTo/setOwner\n    *       getUserTransactionsAmount/getUserTransactions\n    *       getTokenInfo/getHolders/getUserApprovals\n    */\n    public shared(msg) func setName(name: Text) {\n        assert(msg.caller == owner_);\n        name_ := name;\n    };\n\n    public shared(msg) func setLogo(logo: Text) {\n        assert(msg.caller == owner_);\n        logo_ := logo;\n    };\n\n    public shared(msg) func setFeeTo(to: Principal) {\n        assert(msg.caller == owner_);\n        feeTo := to;\n    };\n\n    public shared(msg) func setFee(_fee: Nat) {\n        assert(msg.caller == owner_);\n        fee := _fee;\n    };\n\n    public shared(msg) func setOwner(_owner: Principal) {\n        assert(msg.caller == owner_);\n        owner_ := _owner;\n    };\n\n    public query func getUserTransactionAmount(a: Principal) : async Nat {\n        var res: Nat = 0;\n        for (i in ops.vals()) {\n            if (i.caller == ?a or i.from == a or i.to == a) {\n                res += 1;\n            };\n        };\n        return res;\n    };\n\n    public query func getUserTransactions(a: Principal, start: Nat, limit: Nat) : async [TxRecord] {\n        var res: [TxRecord] = [];\n        var index: Nat = 0;\n        for (i in ops.vals()) {\n            if (i.caller == ?a or i.from == a or i.to == a) {\n                if(index >= start and index < start + limit) {\n                    res := Array.append<TxRecord>(res, [i]);\n                };\n                index += 1;\n            };\n        };\n        return res;\n    };\n\n    public type TokenInfo = {\n        metadata: Metadata;\n        feeTo: Principal;\n        // status info\n        historySize: Nat;\n        deployTime: Time.Time;\n        holderNumber: Nat;\n        cycles: Nat;\n    };\n    public query func getTokenInfo(): async TokenInfo {\n        {\n            metadata = {\n                logo = logo_;\n                name = name_;\n                symbol = symbol_;\n                decimals = decimals_;\n                totalSupply = totalSupply_;\n                owner = owner_;\n                fee = fee;\n            };\n            feeTo = feeTo;\n            historySize = ops.size();\n            deployTime = genesis.timestamp;\n            holderNumber = balances.size();\n            cycles = ExperimentalCycles.balance();\n        }\n    };\n\n    public query func getHolders(start: Nat, limit: Nat) : async [(Principal, Nat)] {\n        let temp =  Iter.toArray(balances.entries());\n        func order (a: (Principal, Nat), b: (Principal, Nat)) : Order.Order {\n            return Nat.compare(b.1, a.1);\n        };\n        let sorted = Array.sort(temp, order);\n        let limit_: Nat = if(start + limit > temp.size()) {\n            temp.size() - start\n        } else {\n            limit\n        };\n        let res = Array.init<(Principal, Nat)>(limit_, (owner_, 0));\n        for (i in Iter.range(0, limit_ - 1)) {\n            res[i] := sorted[i+start];\n        };\n        return Array.freeze(res);\n    };\n\n    public query func getAllowanceSize() : async Nat {\n        var size : Nat = 0;\n        for ((k, v) in allowances.entries()) {\n            size += v.size();\n        };\n        return size;\n    };\n\n    public query func getUserApprovals(who : Principal) : async [(Principal, Nat)] {\n        switch (allowances.get(who)) {\n            case (?allowance_who) {\n                return Iter.toArray(allowance_who.entries());\n            };\n            case (_) {\n                return [];\n            };\n        }\n    };\n\n    /*\n    * upgrade functions\n    */\n    system func preupgrade() {\n        balanceEntries := Iter.toArray(balances.entries());\n        var size : Nat = allowances.size();\n        var temp : [var (Principal, [(Principal, Nat)])] = Array.init<(Principal, [(Principal, Nat)])>(size, (owner_, []));\n        size := 0;\n        for ((k, v) in allowances.entries()) {\n            temp[size] := (k, Iter.toArray(v.entries()));\n            size += 1;\n        };\n        allowanceEntries := Array.freeze(temp);\n    };\n\n    system func postupgrade() {\n        balances := HashMap.fromIter<Principal, Nat>(balanceEntries.vals(), 1, Principal.equal, Principal.hash);\n        balanceEntries := [];\n        for ((k, v) in allowanceEntries.vals()) {\n            let allowed_temp = HashMap.fromIter<Principal, Nat>(v.vals(), 1, Principal.equal, Principal.hash);\n            allowances.put(k, allowed_temp);\n        };\n        allowanceEntries := [];\n    };\n};\n","defi/src/DIP20/motoko/src/types.mo":"/**\n * Module     : types.mo\n * Copyright  : 2021 DFinance Team\n * License    : Apache 2.0 with LLVM Exception\n * Maintainer : DFinance Team <hello@dfinance.ai>\n * Stability  : Experimental\n */\n\nimport Time \"mo:base/Time\";\nimport P \"mo:base/Prelude\";\n\nmodule {\n    /// Update call operations\n    public type Operation = {\n        #mint;\n        #burn;\n        #transfer;\n        #transferFrom;\n        #approve;\n    };\n    public type TransactionStatus = {\n        #succeeded;\n        #inprogress;\n        #failed;\n    };\n    /// Update call operation record fields\n    public type TxRecord = {\n        caller: ?Principal;\n        op: Operation;\n        index: Nat;\n        from: Principal;\n        to: Principal;\n        amount: Nat;\n        fee: Nat;\n        timestamp: Time.Time;\n        status: TransactionStatus;\n    };\n\n    public func unwrap<T>(x : ?T) : T =\n        switch x {\n            case null { P.unreachable() };\n            case (?x_) { x_ };\n        };\n};    \n","defi/src/defi_dapp/Account.mo":"import Array     \"mo:base/Array\";\nimport Blob      \"mo:base/Blob\";\nimport Nat8      \"mo:base/Nat8\";\nimport Nat32     \"mo:base/Nat32\";\nimport Principal \"mo:base/Principal\";\nimport Text      \"mo:base/Text\";\nimport Buffer      \"mo:base/Buffer\";\nimport CRC32     \"./CRC32\";\nimport SHA224    \"./SHA224\";\n\nmodule {\n  // 32-byte array.\n  public type AccountIdentifier = Blob;\n  // 32-byte array.\n  public type Subaccount = Blob;\n\n  func beBytes(n: Nat32) : [Nat8] {\n    func byte(n: Nat32) : Nat8 {\n      Nat8.fromNat(Nat32.toNat(n & 0xff))\n    };\n    [byte(n >> 24), byte(n >> 16), byte(n >> 8), byte(n)]\n  };\n\n  public func principalToSubaccount(principal: Principal) : Blob {\n      let idHash = SHA224.Digest();\n      idHash.write(Blob.toArray(Principal.toBlob(principal)));\n      let hashSum = idHash.sum();\n      let crc32Bytes = beBytes(CRC32.ofArray(hashSum));\n      let buf = Buffer.Buffer<Nat8>(32);\n      let blob = Blob.fromArray(Array.append(crc32Bytes, hashSum));\n\n      return blob;\n  };\n\n  public func defaultSubaccount() : Subaccount {\n    Blob.fromArrayMut(Array.init(32, 0 : Nat8))\n  };\n\n  public func accountIdentifier(principal: Principal, subaccount: Subaccount) : AccountIdentifier {\n    let hash = SHA224.Digest();\n    hash.write([0x0A]);\n    hash.write(Blob.toArray(Text.encodeUtf8(\"account-id\")));\n    hash.write(Blob.toArray(Principal.toBlob(principal)));\n    hash.write(Blob.toArray(subaccount));\n    let hashSum = hash.sum();\n    let crc32Bytes = beBytes(CRC32.ofArray(hashSum));\n    Blob.fromArray(Array.append(crc32Bytes, hashSum))\n  };\n\n  public func validateAccountIdentifier(accountIdentifier : AccountIdentifier) : Bool {\n    if (accountIdentifier.size() != 32) {\n      return false;\n    };\n    let a = Blob.toArray(accountIdentifier);\n    let accIdPart    = Array.tabulate(28, func(i: Nat): Nat8 { a[i + 4] });\n    let checksumPart = Array.tabulate(4,  func(i: Nat): Nat8 { a[i] });\n    let crc32 = CRC32.ofArray(accIdPart);\n    Array.equal(beBytes(crc32), checksumPart, Nat8.equal)\n  };\n}\n","defi/src/defi_dapp/CRC32.mo":"import Blob  \"mo:base/Blob\";\nimport Nat8  \"mo:base/Nat8\";\nimport Nat32 \"mo:base/Nat32\";\n\nmodule {\n\n  let crc32Table : [Nat32] =\n   [ 0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f\n   , 0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988\n   , 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91, 0x1db71064, 0x6ab020f2\n   , 0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7\n   , 0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9\n   , 0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172\n   , 0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b, 0x35b5a8fa, 0x42b2986c\n   , 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59\n   , 0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423\n   , 0xcfba9599, 0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924\n   , 0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190, 0x01db7106\n   , 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433\n   , 0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d\n   , 0x91646c97, 0xe6635c01, 0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e\n   , 0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950\n   , 0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65\n   , 0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7\n   , 0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0\n   , 0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa\n   , 0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f\n   , 0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81\n   , 0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a\n   , 0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683, 0xe3630b12, 0x94643b84\n   , 0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1\n   , 0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb\n   , 0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc\n   , 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5, 0xd6d6a3e8, 0xa1d1937e\n   , 0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b\n   , 0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55\n   , 0x316e8eef, 0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236\n   , 0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe, 0xb2bd0b28\n   , 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d\n   , 0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f\n   , 0x72076785, 0x05005713, 0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38\n   , 0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242\n   , 0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777\n   , 0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69\n   , 0x616bffd3, 0x166ccf45, 0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2\n   , 0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc\n   , 0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9\n   , 0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693\n   , 0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94\n   , 0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d\n   ];\n\n  let seed : Nat32 = 0xffffffff;\n\n  public func ofArray(arr : [Nat8]) : Nat32 {\n    ofBlob(Blob.fromArray(arr))\n  };\n\n  // Returns CRC-32 checksum of a byte array encoded as big-endian.\n  public func ofBlob(blob: Blob) : Nat32 {\n    // See https://en.wikipedia.org/wiki/Cyclic_redundancy_check#CRC-32_algorithm\n    var crc = seed;\n    for (b in blob.vals()) {\n      crc := crc32Table[Nat32.toNat(crc ^ Nat32.fromNat(Nat8.toNat(b)) & 0xff)] ^ (crc >> 8);\n    };\n    crc ^ seed\n  };\n}\n","defi/src/defi_dapp/SHA224.mo":"import Array \"mo:base/Array\";\nimport Iter \"mo:base/Iter\";\nimport Nat \"mo:base/Nat\";\nimport Nat8 \"mo:base/Nat8\";\nimport Nat32 \"mo:base/Nat32\";\nimport Nat64 \"mo:base/Nat64\";\n\nmodule {\n\n  private let K : [Nat32] = [\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,\n    0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,\n    0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,\n    0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,\n    0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,\n    0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,\n    0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,\n    0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,\n    0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2,\n  ];\n\n  private let S : [Nat32] = [\n    0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,\n    0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4,\n  ];\n\n  // Calculate a SHA224 hash.\n  public func sha224(data : [Nat8]) : [Nat8] {\n    let digest = Digest();\n    digest.write(data);\n    return digest.sum();\n  };\n\n  public class Digest() {\n\n    private let s = Array.thaw<Nat32>(S);\n\n    private let x = Array.init<Nat8>(64, 0);\n\n    private var nx = 0;\n\n    private var len : Nat64 = 0;\n\n    public func reset() {\n      for (i in Iter.range(0, 7)) {\n        s[i] := S[i];\n      };\n      nx := 0;\n      len := 0;\n    };\n\n    public func write(data : [Nat8]) {\n      var p = data;\n      len +%= Nat64.fromIntWrap(p.size());\n      if (nx > 0) {\n        let n = Nat.min(p.size(), 64 - nx);\n        for (i in Iter.range(0, n - 1)) {\n          x[nx + i] := p[i];\n        };\n        nx += n;\n        if (nx == 64) {\n          let buf = Array.freeze<Nat8>(x);\n          block(buf);\n          nx := 0;\n        };\n        p := Array.tabulate<Nat8>(p.size() - n, func (i) {\n          return p[n + i];\n        });\n      };\n      if (p.size() >= 64) {\n        let n = Nat64.toNat(Nat64.fromIntWrap(p.size()) & (^ 63));\n        let buf = Array.tabulate<Nat8>(n, func (i) {\n          return p[i];\n        });\n        block(buf);\n        p := Array.tabulate<Nat8>(p.size() - n, func (i) {\n          return p[n + i];\n        });\n      };\n      if (p.size() > 0) {\n        for (i in Iter.range(0, p.size() - 1)) {\n          x[i] := p[i];\n        };\n        nx := p.size();\n      };\n    };\n\n    public func sum() : [Nat8] {\n      var m = 0;\n      var n = len;\n      var t = Nat64.toNat(n) % 64;\n      var buf : [var Nat8] = [var];\n      if (56 > t) {\n        m := 56 - t;\n      } else {\n        m := 120 - t;\n      };\n      n := n << 3;\n      buf := Array.init<Nat8>(m, 0);\n      if (m > 0) {\n        buf[0] := 0x80;\n      };\n      write(Array.freeze<Nat8>(buf));\n      buf := Array.init<Nat8>(8, 0);\n      for (i in Iter.range(0, 7)) {\n        let j : Nat64 = 56 -% 8 *% Nat64.fromIntWrap(i);\n        buf[i] := Nat8.fromIntWrap(Nat64.toNat(n >> j));\n      };\n      write(Array.freeze<Nat8>(buf));\n      let hash = Array.init<Nat8>(28, 0);\n      for (i in Iter.range(0, 6)) {\n        for (j in Iter.range(0, 3)) {\n          let k : Nat32 = 24 -% 8 *% Nat32.fromIntWrap(j);\n          hash[4 * i + j] := Nat8.fromIntWrap(Nat32.toNat(s[i] >> k));\n        };\n      };\n      return Array.freeze<Nat8>(hash);\n    };\n\n    private func block(data : [Nat8]) {\n      var p = data;\n      var w = Array.init<Nat32>(64, 0);\n      while (p.size() >= 64) {\n        var j = 0;\n        for (i in Iter.range(0, 15)) {\n          j := i * 4;\n          w[i] :=\n            Nat32.fromIntWrap(Nat8.toNat(p[j + 0])) << 24 |\n            Nat32.fromIntWrap(Nat8.toNat(p[j + 1])) << 16 |\n            Nat32.fromIntWrap(Nat8.toNat(p[j + 2])) << 08 |\n            Nat32.fromIntWrap(Nat8.toNat(p[j + 3])) << 00;\n        };\n        var v1 : Nat32 = 0;\n        var v2 : Nat32 = 0;\n        var t1 : Nat32 = 0;\n        var t2 : Nat32 = 0;\n        for (i in Iter.range(16, 63)) {\n          v1 := w[i - 02];\n          v2 := w[i - 15];\n          t1 := rot(v1, 17) ^ rot(v1, 19) ^ (v1 >> 10);\n          t2 := rot(v2, 07) ^ rot(v2, 18) ^ (v2 >> 03);\n          w[i] :=\n              t1 +% w[i - 07] +%\n              t2 +% w[i - 16];\n        };\n        var a = s[0];\n        var b = s[1];\n        var c = s[2];\n        var d = s[3];\n        var e = s[4];\n        var f = s[5];\n        var g = s[6];\n        var h = s[7];\n        for (i in Iter.range(0, 63)) {\n          t1 := rot(e, 06) ^ rot(e, 11) ^ rot(e, 25);\n          t1 +%= (e & f) ^ (^ e & g) +% h +% K[i] +% w[i];\n          t2 := rot(a, 02) ^ rot(a, 13) ^ rot(a, 22);\n          t2 +%= (a & b) ^ (a & c) ^ (b & c);\n          h := g;\n          g := f;\n          f := e;\n          e := d +% t1;\n          d := c;\n          c := b;\n          b := a;\n          a := t1 +% t2;\n        };\n        s[0] +%= a;\n        s[1] +%= b;\n        s[2] +%= c;\n        s[3] +%= d;\n        s[4] +%= e;\n        s[5] +%= f;\n        s[6] +%= g;\n        s[7] +%= h;\n        p := Array.tabulate<Nat8>(p.size() - 64, func (i) {\n          return p[i + 64];\n        });\n      };\n    };\n  };\n\n  private let rot : (Nat32, Nat32) -> Nat32 = Nat32.bitrotRight;\n};\n","defi/src/defi_dapp/book.mo":"import Array \"mo:base/Array\";\nimport Debug \"mo:base/Debug\";\nimport Principal \"mo:base/Principal\";\nimport Iter \"mo:base/Iter\";\n\nimport M \"mo:base/HashMap\";\n\nimport T \"types\";\n\nmodule {\n\n    public class Book() {\n\n        var book = M.HashMap<Principal, M.HashMap<T.Token, Nat>>(10, Principal.equal, Principal.hash);\n\n        public func get(user: Principal) : ?M.HashMap<T.Token, Nat> {\n            book.get(user)\n        };\n\n        public func put(user: Principal, userBalances: M.HashMap<T.Token, Nat>) {\n            book.put(user, userBalances);\n        };\n\n        public func entries() : Iter.Iter<(Principal,M.HashMap<T.Token,Nat>)> {\n            book.entries()\n        };\n\n        public func size() : Nat {\n            book.size()\n        };\n\n        // For development only.\n        public func print_balances(){\n            for ((x, y) in book.entries()) {\n                Debug.print( debug_show(\"PRINCIPAL: \", x));\n                for ((key: T.Token, value: Nat) in y.entries()) {\n                    Debug.print( debug_show(\"Balance: Token: \", key, \" amount: \",value));\n                };\n            };\n        };\n\n        public func clear() {\n            book := M.HashMap<Principal, M.HashMap<T.Token, Nat>>(10, Principal.equal, Principal.hash);\n        };\n\n        // function that adds tokens to book. Book keeps track of users deposits.\n        public func addTokens(user: Principal, token: T.Token, amount: Nat){\n            switch (book.get(user)) {\n                case (?token_balance) {\n                    // check if user already has existing balance for this token\n                    switch (token_balance.get(token)){\n                        case (?balance) {\n                            token_balance.put(token, balance+amount);\n                        };\n                        case(null){\n                            token_balance.put(token, amount);\n                        };\n                    };\n                };\n                case (null) {\n                    // user didn't exist\n                    var x1 = M.HashMap<T.Token, Nat>(2, Principal.equal, Principal.hash);\n                    x1.put(token,amount);\n                    book.put(user,x1);\n                };\n            };\n        };\n\n        // return the new balance.\n        public func removeTokens(user: Principal, token: T.Token, amount: Nat) : ?Nat {\n            switch (book.get(user)) {\n                case (?token_balance) {\n                    // check if user already has existing balance for this token\n                    switch (token_balance.get(token)){\n                        case (?balance) {\n                          if (balance>=amount) {\n                            if (balance==amount) {\n                              token_balance.delete(token);\n                            } else {\n                              token_balance.put(token, balance-amount);\n                            };\n                            ?(balance-amount)\n                          } else {\n                            null\n                            }\n                        };\n                        case(null){\n                            Debug.print(\"User \" # Principal.toText(user) # \" has no balance of token \" # Principal.toText(token));\n                            null\n                        };\n                    };\n                };\n                case (null) {\n                    // user didn't exist\n                    Debug.print(\"User \" # Principal.toText(user) # \" doesn't exist in book, cannot remove tokens.\");\n                    null\n                };\n            };\n        };\n\n        // Return true if a user has at least amount tokens in the book, false otherwise.\n        public func hasEnoughBalance(user: Principal, token: Principal, amount: Nat) : Bool {\n            switch (book.get(user)) {\n                case (?balances) {\n                    switch(balances.get(token)) {\n                        case (?balance) return balance >= amount;\n                        case null return false;\n                    }\n                };\n                case null return false;\n            };\n        }\n    }\n}\n","defi/src/defi_dapp/exchange.mo":"import Array \"mo:base/Array\";\nimport B \"mo:base/Buffer\";\nimport Debug \"mo:base/Debug\";\nimport Float \"mo:base/Float\";\nimport Int \"mo:base/Int\";\nimport Iter \"mo:base/Iter\";\nimport L \"mo:base/List\";\nimport M \"mo:base/HashMap\";\nimport Nat \"mo:base/Nat\";\nimport Text \"mo:base/Text\";\nimport Nat32 \"mo:base/Nat32\";\nimport Nat64 \"mo:base/Nat64\";\nimport Order \"mo:base/Order\";\nimport Principal \"mo:base/Principal\";\nimport RBTree \"mo:base/RBTree\";\n\nimport Book \"book\";\nimport T \"types\";\n\nmodule {\n\n    // internal types\n    public type TradingPair = (T.Token,T.Token);\n\n    // An exchange between ICP and DIP20 tokens.\n    public class Exchange(trading_pair: TradingPair, book: Book.Book) {\n\n        // The map of all orders (not differentiated by pairs).\n        let orders = M.HashMap<T.OrderId, T.Order>(10, func(x,y){x == y}, func(x) {x});\n\n        public func getOrder(id: T.OrderId) : ?T.Order {\n            orders.get(id)\n        };\n\n        public func getOrders() : [T.Order] {\n            Debug.print(\"List orders on exchange \" # Principal.toText(trading_pair.0) # \"/\" # Principal.toText(trading_pair.1));\n            let buff : B.Buffer<T.Order> = B.Buffer(10);\n            for (o in orders.vals()) {\n                buff.add(o);\n            };\n            buff.toArray();\n        };\n\n        // Cancel order WITHOUT verifying ownership.\n        public func cancelOrder(id: T.OrderId) : ?T.Order {\n            orders.remove(id)\n        };\n\n        public func addOrders(dex : Principal, orders: [T.Order]) {\n            for(o in orders.vals()) {\n                addOrder(dex, o);\n            }\n        };\n\n        public func addOrder(dex : Principal, o: T.Order) {\n            orders.put(o.id, o);\n            detectMatch(dex, o);\n        };\n\n        func detectMatch(dex : Principal, order: T.Order) {\n            let a = order;\n\n            // Find matching orders.\n            let matches : B.Buffer<T.Order> = B.Buffer(10);\n            for(b in orders.vals()) {\n                if(a.id!=b.id\n                    and a.from==b.to and a.to==b.from\n                    and a.fromAmount * b.fromAmount >= a.toAmount * b.toAmount\n                ) {\n                    matches.add(b);\n                }\n            };\n\n            label iter_matches for(b in matches.vals()) {\n                var a_to_amount = 0;\n                var b_to_amount = 0;\n                // Check if some orders can be completed in their entirety.\n                if (b.fromAmount >= a.toAmount) {\n                    a_to_amount := a.toAmount;\n                };\n                if (a.fromAmount >= b.toAmount) {\n                    b_to_amount := b.toAmount;\n                };\n\n                // Check if some orders can be completed partially.\n                if (a_to_amount == 0 and b_to_amount > 0) {\n                    a_to_amount := b.fromAmount;\n                    // Verify that we can complete the partial order with natural number tokens remaining.\n                    if ((a_to_amount * a.fromAmount) % a.toAmount != 0)\n                    {\n                        continue iter_matches;\n                    };\n                };\n                if (b_to_amount == 0 and a_to_amount > 0) {\n                    b_to_amount := a.fromAmount;\n                    // Verify that we can complete the partial order with natural number tokens remaining.\n                    if ((b_to_amount * b.fromAmount) % b.toAmount != 0)\n                    {\n                        continue iter_matches;\n                    };\n                };\n\n                if (a_to_amount > 0 and b_to_amount > 0) {\n                    processTrade(dex, a, b, a_to_amount, b_to_amount);\n                }\n            };\n        };\n\n        func processTrade(dex : Principal, orderA : T.Order, orderB: T.Order, aToAmount: Nat, bToAmount: Nat) {\n            Debug.print(\"Process trade between order \" # Nat32.toText(orderA.id) # \" and order \" # Nat32.toText(orderB.id));\n            let ra=orders.remove(orderA.id);\n            let rb=orders.remove(orderB.id);\n\n            // Calculate \"cost\" to each\n            let aFromAmount : Nat = (aToAmount*orderA.fromAmount) / orderA.toAmount;\n            let bFromAmount : Nat = (bToAmount*orderB.fromAmount) / orderB.toAmount;\n\n            // Update order with remaining tokens\n            let a : T.Order = {\n                id = orderA.id;\n                owner = orderA.owner;\n                from = orderA.from;\n                fromAmount = orderA.fromAmount - aFromAmount;\n                to = orderA.to;\n                toAmount = orderA.toAmount - aToAmount;\n            };\n\n            let b : T.Order = {\n                id = orderB.id;\n                owner = orderB.owner;\n                from = orderB.from;\n                fromAmount = orderB.fromAmount - bFromAmount;\n                to = orderB.to;\n                toAmount = orderB.toAmount - bToAmount;\n            };\n\n            // Update DEX balances (book)\n            let removedA=book.removeTokens(a.owner, a.from, aFromAmount);\n            book.addTokens(a.owner, a.to, aToAmount);\n            let removedB=book.removeTokens(b.owner, b.from, bFromAmount);\n            book.addTokens(b.owner, b.to, bToAmount);\n\n            // The DEX keeps any tokens not required to satisfy the parties.\n            let dex_amount_a : Nat = aFromAmount - bToAmount;\n            if (dex_amount_a > 0) {\n                book.addTokens(dex, a.from, dex_amount_a);\n            };\n            let dex_amount_b : Nat = bFromAmount - aToAmount;\n            if (dex_amount_b > 0) {\n                book.addTokens(dex, b.from, dex_amount_b);\n            };\n\n            // Maintain the orders only if not empty\n            if (a.fromAmount != 0) {\n                orders.put(a.id, a);\n            };\n            if (b.fromAmount != 0) {\n                orders.put(b.id, b);\n            };\n        };\n\n    }\n\n}\n","defi/src/defi_dapp/main.mo":"import Array \"mo:base/Array\";\nimport Buffer \"mo:base/Buffer\";\nimport Debug \"mo:base/Debug\";\nimport Bool \"mo:base/Debug\";\nimport Float \"mo:base/Float\";\nimport Int \"mo:base/Int\";\nimport Int64 \"mo:base/Int64\";\nimport Iter \"mo:base/Iter\";\nimport M \"mo:base/HashMap\";\nimport Nat64 \"mo:base/Nat64\";\nimport Nat32 \"mo:base/Nat32\";\nimport Nat \"mo:base/Nat\";\nimport Hash \"mo:base/Hash\";\nimport Principal \"mo:base/Principal\";\nimport Text \"mo:base/Text\";\nimport Time \"mo:base/Time\";\nimport Result \"mo:base/Result\";\n\nimport Account \"./Account\";\nimport Ledger \"canister:ledger\";\n\nimport B \"book\";\nimport E \"exchange\";\nimport T \"types\";\n\nshared(init_msg) actor class Dex() = this {\n    let ledger : Principal = Principal.fromActor(Ledger);\n    let icp_fee: Nat = 10_000;\n\n    stable var orders_stable : [T.Order] = [];\n    stable var lastId : Nat32 = 0;\n    var exchanges = M.HashMap<E.TradingPair, E.Exchange>(10, func (k1: E.TradingPair,k2: E.TradingPair): Bool {\n        Principal.equal(k1.0,k2.0) and Principal.equal(k1.1,k2.1)\n    }, func (k : E.TradingPair) {\n        Text.hash(Text.concat(Principal.toText(k.0),Principal.toText(k.1)))\n    });\n\n    // User balance datastructure\n    private var book = B.Book();\n    private stable var book_stable : [var (Principal, [(T.Token, Nat)])] = [var];\n\n    // ===== ORDER FUNCTIONS =====\n    public shared(msg) func placeOrder(from: T.Token, fromAmount: Nat, to: T.Token, toAmount: Nat) : async T.OrderPlacementReceipt {\n        let id = nextId();\n        Debug.print(\"\");\n        Debug.print(\"Placing order \"# Nat32.toText(id) #\" from user \" # Principal.toText(msg.caller) # \" for selling \" # Nat.toText(fromAmount) # \" tokens \" # Principal.toText(from));\n        let owner=msg.caller;\n        let submitted = Time.now();\n\n        // consturct trading pair which is used to select correct exchange\n        // following pair is constructed (X,Y) where X is less accoriding to principal compare function\n        // this is needed that buy and sell orders use the same exchange\n        var trading_pair=(from,to);\n        switch(create_trading_pair(from,to)){\n            case(?tp){\n                trading_pair:=tp;\n            };\n            case(null){\n                return #Err(#InvalidOrder);\n            }\n        };\n\n        // Iterate all orders to only allow one sell order per token.\n        for(e in exchanges.vals()) {\n            for(o in e.getOrders().vals()){\n                if (o.from == from and o.owner == owner ) {\n                    return #Err(#OrderBookFull);\n                };\n            };\n        };\n                                                                       \n        // Check if user balance in book is enough before creating the order.\n        if(book.hasEnoughBalance(owner,from,fromAmount) == false) {\n            Debug.print(\"Not enough balance for user \" # Principal.toText(owner) # \" in token \" # Principal.toText(from));\n            return #Err(#InvalidOrder);\n        };\n\n        let exchange = switch (exchanges.get(trading_pair)) {\n            case null {\n                Debug.print(\"Creating Exchange for trading pair: \" # Principal.toText(trading_pair.0) # \"::\" # Principal.toText(trading_pair.1));\n                let exchange : E.Exchange = E.Exchange(trading_pair, book);\n                exchanges.put(trading_pair,exchange);\n                exchange\n            };\n            case (?e) e\n        };\n        let order : T.Order = {\n            id;\n            owner;\n            from;\n            fromAmount;\n            to;\n            toAmount;\n         };\n        exchange.addOrder(Principal.fromActor(this), order);\n\n        #Ok(exchange.getOrder(id))\n    };\n\n    public shared(msg) func cancelOrder(order_id: T.OrderId) : async T.CancelOrderReceipt {\n        Debug.print(\"Cancelling order \"# Nat32.toText(order_id) #\"...\");\n        for(e in exchanges.vals()) {\n            switch (e.getOrder(order_id)) {\n                case (?order)\n                    if(order.owner != msg.caller) {\n                        return #Err(#NotAllowed);\n                    } else {\n                        switch (e.cancelOrder(order_id)) {\n                            case (?canceled) return #Ok(canceled.id);\n                            case null return #Err(#NotAllowed)\n                        }\n                    };\n                case null {}\n            };\n        };\n        return #Err(#NotExistingOrder);\n    };\n\n    public func getOrder(order_id: T.OrderId) : async(?T.Order) {\n        Debug.print(\"Checking order \"# Nat32.toText(order_id) #\"...\");\n        for(e in exchanges.vals()) {\n            switch (e.getOrder(order_id)) {\n                case (?order) return ?order;\n                case null {}\n            };\n        };\n        null;\n    };\n\n    public func getOrders() : async([T.Order]) {\n        Debug.print(\"List orders...\");\n        getAllOrders()\n    };\n\n    private func getAllOrders() : [T.Order] {\n        let buff : Buffer.Buffer<T.Order> = Buffer.Buffer(10);\n        for(e in exchanges.vals()) {\n            for(o in e.getOrders().vals()) {\n                buff.add(o);\n            };\n        };\n        buff.toArray();\n    };\n\n    private func nextId() : Nat32 {\n        lastId += 1;\n        lastId;\n    };\n\n    // ===== WITHDRAW FUNCTIONS =====\n    public shared(msg) func withdraw(token: T.Token, amount: Nat, address: Principal) : async T.WithdrawReceipt {\n        // remove user submitted orders\n        for (order in getAllOrders().vals()){\n            if (order.owner == msg.caller){\n                // find trading pair of order. This is needed to select the correct exchange.\n                var trading_pair=(order.from,order.to);\n                switch(create_trading_pair(order.from,order.to)){\n                    case(?tp){\n                        trading_pair:=tp;\n                    };\n                    case _ {};\n                };\n                switch (exchanges.get(trading_pair)) {\n                    case (?e) {\n                        let _ = e.cancelOrder(order.id);\n                    };\n                    case _ {};\n                };\n            }\n        };\n        \n\n        if (token == ledger) {\n            let account_id = Account.accountIdentifier(address, Account.defaultSubaccount());\n            await withdrawIcp(msg.caller, amount, account_id)\n        } else {\n            await withdrawDip(msg.caller, token, amount, address)\n        }\n    };\n\n    private func withdrawIcp(caller: Principal, amount: Nat, account_id: Blob) : async T.WithdrawReceipt {\n        Debug.print(\"Withdraw...\");\n\n        // remove withdrawal amount from book\n        switch (book.removeTokens(caller, ledger, amount+icp_fee)){\n            case(null){\n                return #Err(#BalanceLow)\n            };\n            case _ {};\n        };\n\n        // Transfer amount back to user\n        let icp_reciept =  await Ledger.transfer({\n            memo: Nat64    = 0;\n            from_subaccount = ?Account.defaultSubaccount();\n            to = account_id;\n            amount = { e8s = Nat64.fromNat(amount + icp_fee) };\n            fee = { e8s = Nat64.fromNat(icp_fee) };\n            created_at_time = ?{ timestamp_nanos = Nat64.fromNat(Int.abs(Time.now())) };\n        });\n\n        switch icp_reciept {\n            case (#Err e) {\n                // add tokens back to user account balance\n                book.addTokens(caller,ledger,amount+icp_fee);\n                return #Err(#TransferFailure);\n            };\n            case _ {};\n        };\n        #Ok(amount)\n    };\n\n    private func withdrawDip(caller: Principal, token: T.Token, amount: Nat, address: Principal) : async T.WithdrawReceipt {\n\n        // cast canisterID to token interface\n        let dip20 = actor (Principal.toText(token)) : T.DIPInterface;\n\n        // get dip20 fee\n        let dip_fee = await fetch_dip_fee(token);\n\n        // remove withdrawal amount from book\n        switch (book.removeTokens(caller,token,amount+dip_fee)){\n            case(null){\n                return #Err(#BalanceLow)\n            };\n            case _ {};\n        };\n\n        // Transfer amount back to user\n        let txReceipt =  await dip20.transfer(address, amount);\n\n        switch txReceipt {\n            case (#Err e) {\n                // add tokens back to user account balance\n                book.addTokens(caller,token,amount + dip_fee);\n                return #Err(#TransferFailure);\n            };\n            case _ {};\n        };\n        return #Ok(amount)\n    };\n\n\n    // ===== DEX STATE FUNCTIONS =====\n    public shared query (msg) func getBalance(token: T.Token) : async Nat {\n        switch (book.get(msg.caller)) {\n            case (?token_balance) {\n                switch (token_balance.get(token)){\n                    case (?balance) {\n                        return balance;\n                    };\n                    case(null){\n                        return 0;\n                    };\n                };\n            };\n            case (null) {\n                return 0;\n            };\n        };\n    };\n\n    public shared query (msg) func getBalances() : async [T.Balance] {\n        switch (book.get(msg.caller)) {\n            case (?token_balance) {\n                Array.map<(T.Token, Nat),T.Balance>(Iter.toArray(token_balance.entries()), func (k : T.Token, v: Nat) : T.Balance {\n                    {\n                        owner = msg.caller;\n                        token = k;\n                        amount = v;\n                    }\n                })\n            };\n            case (null) {\n                return [];\n            };\n        };\n    };\n\n\n    public shared query (msg) func getAllBalances() : async [T.Balance] {\n        \n        // could probably allocate more but this is minimum\n        let buff : Buffer.Buffer<T.Balance> = Buffer.Buffer(book.size());\n        for ((owner, user_balances) in book.entries()) {\n            let b : Buffer.Buffer<T.Balance> = Buffer.Buffer(user_balances.size());\n            for ((token, amount) in user_balances.entries()) {\n                b.add({\n                    owner;\n                    token;\n                    amount;\n                });\n            };\n            buff.append(b);\n        };\n        buff.toArray()\n    };\n\n    public shared query (msg) func whoami() : async Principal {\n        return msg.caller;\n    };\n\n\n    // ===== DEPOSIT FUNCTIONS =====\n    // Return the account ID specific to this user's subaccount\n    public shared(msg) func getDepositAddress(): async Blob {\n        Account.accountIdentifier(Principal.fromActor(this), Account.principalToSubaccount(msg.caller));\n    };\n\n    public shared(msg) func deposit(token: T.Token): async T.DepositReceipt {\n        Debug.print(\"Depositing Token: \" # Principal.toText(token) # \" LEDGER: \" # Principal.toText(ledger));\n        if (token == ledger) {\n            await depositIcp(msg.caller)\n        } else {\n            await depositDip(msg.caller, token)\n        }\n    };\n\n    // After user approves tokens to the DEX\n    private func depositDip(caller: Principal, token: T.Token): async T.DepositReceipt {\n        // cast token to actor\n        let dip20 = actor (Principal.toText(token)) : T.DIPInterface;\n\n        // get DIP fee\n        let dip_fee = await fetch_dip_fee(token);\n\n        // Check DIP20 allowance for DEX\n        let balance : Nat = (await dip20.allowance(caller, Principal.fromActor(this)));\n\n        // Transfer to account.\n        let token_reciept = if (balance > dip_fee) {\n            await dip20.transferFrom(caller, Principal.fromActor(this),balance - dip_fee);\n        } else {\n            return #Err(#BalanceLow);\n        };\n\n        switch token_reciept {\n            case (#Err e) {\n                return #Err(#TransferFailure);\n            };\n            case _ {};\n        };\n        let available = balance - dip_fee;\n\n        // add transferred amount to user balance\n        book.addTokens(caller,token,available);\n\n        // Return result\n        #Ok(available)\n    };\n\n    // After user transfers ICP to the target subaccount\n    private func depositIcp(caller: Principal): async T.DepositReceipt {\n\n        // Calculate target subaccount\n        // NOTE: Should this be hashed first instead?\n        let source_account = Account.accountIdentifier(Principal.fromActor(this), Account.principalToSubaccount(caller));\n\n        // Check ledger for value\n        let balance = await Ledger.account_balance({ account = source_account });\n\n        // Transfer to default subaccount\n        let icp_receipt = if (Nat64.toNat(balance.e8s) > icp_fee) {\n            await Ledger.transfer({\n                memo: Nat64    = 0;\n                from_subaccount = ?Account.principalToSubaccount(caller);\n                to = Account.accountIdentifier(Principal.fromActor(this), Account.defaultSubaccount());\n                amount = { e8s = balance.e8s - Nat64.fromNat(icp_fee)};\n                fee = { e8s = Nat64.fromNat(icp_fee) };\n                created_at_time = ?{ timestamp_nanos = Nat64.fromNat(Int.abs(Time.now())) };\n            })\n        } else {\n            return #Err(#BalanceLow);\n        };\n\n        switch icp_receipt {\n            case ( #Err _) {\n                return #Err(#TransferFailure);\n            };\n            case _ {};\n        };\n        let available = { e8s : Nat = Nat64.toNat(balance.e8s) - icp_fee };\n\n        // keep track of deposited ICP\n        book.addTokens(caller,ledger,available.e8s);\n\n        // Return result\n        #Ok(available.e8s)\n    };\n\n\n    // ===== INTERNAL FUNCTIONS =====\n    private func fetch_dip_fee(token: T.Token) : async Nat {\n        let dip20 = actor (Principal.toText(token)) : T.DIPInterface;\n        let metadata = await dip20.getMetadata();\n        metadata.fee\n    };\n\n    public func getSymbol(token: T.Token) : async Text {\n        let dip20 = actor (Principal.toText(token)) : T.DIPInterface;\n        if (token==ledger){\n            return \"ICP\"\n        };\n        let metadata = await dip20.getMetadata();\n        metadata.symbol\n    };\n\n    private func create_trading_pair(from: T.Token, to: T.Token) : ?E.TradingPair {\n        switch(Principal.compare(from,to)){\n            case(#less){\n                ?(from,to)\n            };\n            case(#greater){\n                ?(to,from)\n            };\n            case(#equal){\n                null\n            };\n        };\n    };\n\n    private func create_trading_pair_symbol(from: T.Token, to: T.Token) : async ?(Text,Text) {\n        let trading_pair =  switch (create_trading_pair(from,to)){\n            // should not occur here since all orders already validated\n            case null return null;\n            case (?tp) tp;\n        };\n        ?(await getSymbol(trading_pair.0),await getSymbol(trading_pair.1))\n    };\n    \n    // For testing\n    public shared(msg) func credit(user: Principal, token_canister_id: T.Token, amount: Nat) {\n        assert (msg.caller == init_msg.caller);\n        book.addTokens(user,token_canister_id,amount);\n    };\n\n    // For testing.\n    public shared(msg) func clear() {\n        assert (msg.caller == init_msg.caller);\n        book.clear();\n\n        exchanges := M.HashMap<E.TradingPair, E.Exchange>(10, func (k1: E.TradingPair,k2: E.TradingPair): Bool {\n                Principal.equal(k1.0,k2.0) and Principal.equal(k1.1,k2.1)\n            },\n            func (k : E.TradingPair) {\n                Text.hash(Text.concat(Principal.toText(k.0),Principal.toText(k.1)))\n            });\n    };\n\n    // !!!! UPGRADES ONLY USED FOR DEVELOPMENT !!!!\n    // Defi apps are not upgradable and should have an empty controller list\n    // https://smartcontracts.org/docs/developers-guide/concepts/trust-in-canisters.html\n    // !!!! UPGRADES ONLY USED FOR DEVELOPMENT !!!!\n    \n    // Required since maps cannot be stable and need to be moved to stable memory\n    // Before canister upgrade book hashmap gets stored in stable memory such that it survives updates\n    system func preupgrade() {\n        book_stable := Array.init(book.size(), (Principal.fromText(\"\"), []));\n        var i = 0;\n        for ((x, y) in book.entries()) {\n            book_stable[i] := (x, Iter.toArray(y.entries()));\n            i += 1;\n        };\n        orders_stable := getAllOrders();\n    };\n\n    // After canister upgrade book map gets reconstructed from stable array\n    system func postupgrade() {\n        // Reload book.\n        for ((key: Principal, value: [(T.Token, Nat)]) in book_stable.vals()) {\n            let tmp: M.HashMap<T.Token, Nat> = M.fromIter<T.Token, Nat>(Iter.fromArray<(T.Token, Nat)>(value), 10, Principal.equal, Principal.hash);\n            book.put(key, tmp);\n        };\n\n        // TODO Reload exchanges (find solution for async symbol retrieving).\n        for(o in orders_stable.vals()) {\n            let trading_pair = switch (create_trading_pair(o.from,o.to)){\n                // should not occur here since all orders already validated\n                case null (o.from,o.to);\n                case (?tp) tp;\n            };\n            let exchange = switch (exchanges.get(trading_pair)) {\n                case null {\n                    let exchange : E.Exchange = E.Exchange(trading_pair, book);\n                    exchanges.put(trading_pair,exchange);\n                    exchange\n                };\n                case (?e) e\n            };\n            exchange.addOrder(Principal.fromActor(this), o);\n        };\n\n        // Clean stable memory.\n        book_stable := [var];\n        orders_stable := [];\n    };\n\n}\n","defi/src/defi_dapp/types.mo":"import Time \"mo:base/Time\";\n\n\nmodule {\n\n    public type Token = Principal;\n\n    public type OrderId = Nat32;\n  \n    public type Order = {\n        id: OrderId;\n        owner: Principal;\n        from: Token;\n        fromAmount: Nat;\n        to: Token;\n        toAmount: Nat;\n    };\n    \n    // ledger types\n    public type Operation = {\n        #approve;\n        #mint;\n        #transfer;\n        #transferFrom;\n    };\n\n \n    public type TransactionStatus = {\n        #succeeded;\n        #failed;\n    };\n\n    public type TxRecord = {\n        caller: ?Principal;\n        op: Operation; // operation type\n        index: Nat; // transaction index\n        from: Principal;\n        to: Principal;\n        amount: Nat;\n        fee: Nat;\n        timestamp: Time.Time;\n        status: TransactionStatus;\n    };\n\n    // Dip20 token interface\n    public type TxReceipt = {\n        #Ok: Nat;\n        #Err: {\n            #InsufficientAllowance;\n            #InsufficientBalance;\n            #ErrorOperationStyle;\n            #Unauthorized;\n            #LedgerTrap;\n            #ErrorTo;\n            #Other;\n            #BlockUsed;\n            #AmountTooSmall;\n        };\n    };\n\n    public type Metadata = {\n        logo : Text; // base64 encoded logo or logo url\n        name : Text; // token name\n        symbol : Text; // token symbol\n        decimals : Nat8; // token decimal\n        totalSupply : Nat; // token total supply\n        owner : Principal; // token owner\n        fee : Nat; // fee for update calls\n    };\n\n\n    public type DIPInterface = actor {\n        transfer : (Principal,Nat) ->  async TxReceipt;\n        transferFrom : (Principal,Principal,Nat) -> async TxReceipt;\n        allowance : (owner: Principal, spender: Principal) -> async Nat;\n        getMetadata: () -> async Metadata;\n    };\n\n    // return types\n    public type OrderPlacementErr = {\n        #InvalidOrder;\n        #OrderBookFull;\n    };\n    public type OrderPlacementReceipt = {\n        #Ok: ?Order;\n        #Err: OrderPlacementErr;\n    };\n    public type CancelOrderErr = {\n        #NotExistingOrder;\n        #NotAllowed;\n    };\n    public type CancelOrderReceipt = {\n        #Ok: OrderId;\n        #Err: CancelOrderErr;\n    };\n    public type WithdrawErr = {\n        #BalanceLow;\n        #TransferFailure;\n    };\n    public type WithdrawReceipt = {\n        #Ok: Nat;\n        #Err: WithdrawErr;  \n    };\n    public type DepositErr = {\n        #BalanceLow;\n        #TransferFailure;\n    };\n    public type DepositReceipt = {\n        #Ok: Nat;\n        #Err: DepositErr;\n    };\n    public type Balance = {\n        owner: Principal;\n        token: Token;\n        amount: Nat;\n    };\n\n}\n","dip721-nft-container/src/Main.mo":"import Nat \"mo:base/Nat\";\nimport Nat8 \"mo:base/Nat8\";\nimport Nat16 \"mo:base/Nat16\";\nimport Nat32 \"mo:base/Nat32\";\nimport Nat64 \"mo:base/Nat64\";\nimport List \"mo:base/List\";\nimport Array \"mo:base/Array\";\nimport Option \"mo:base/Option\";\nimport Bool \"mo:base/Bool\";\nimport Principal \"mo:base/Principal\";\nimport Types \"./Types\";\n\nshared actor class Dip721NFT(custodian: Principal, init : Types.Dip721NonFungibleToken) = Self {\n  stable var transactionId: Types.TransactionId = 0;\n  stable var nfts = List.nil<Types.Nft>();\n  stable var custodians = List.make<Principal>(custodian);\n  stable var logo : Types.LogoResult = init.logo;\n  stable var name : Text = init.name;\n  stable var symbol : Text = init.symbol;\n  stable var maxLimit : Nat16 = init.maxLimit;\n\n  // https://forum.dfinity.org/t/is-there-any-address-0-equivalent-at-dfinity-motoko/5445/3\n  let null_address : Principal = Principal.fromText(\"aaaaa-aa\");\n\n  public query func balanceOfDip721(user: Principal) : async Nat64 {\n    return Nat64.fromNat(\n      List.size(\n        List.filter(nfts, func(token: Types.Nft) : Bool { token.owner == user })\n      )\n    );\n  };\n\n  public query func ownerOfDip721(token_id: Types.TokenId) : async Types.OwnerResult {\n    let item = List.find(nfts, func(token: Types.Nft) : Bool { token.id == token_id });\n    switch (item) {\n      case (null) {\n        return #Err(#InvalidTokenId);\n      };\n      case (?token) {\n        return #Ok(token.owner);\n      };\n    };\n  };\n\n  public shared({ caller }) func safeTransferFromDip721(from: Principal, to: Principal, token_id: Types.TokenId) : async Types.TxReceipt {  \n    if (to == null_address) {\n      return #Err(#ZeroAddress);\n    } else {\n      return transferFrom(from, to, token_id, caller);\n    };\n  };\n\n  public shared({ caller }) func transferFromDip721(from: Principal, to: Principal, token_id: Types.TokenId) : async Types.TxReceipt {\n    return transferFrom(from, to, token_id, caller);\n  };\n\n  func transferFrom(from: Principal, to: Principal, token_id: Types.TokenId, caller: Principal) : Types.TxReceipt {\n    let item = List.find(nfts, func(token: Types.Nft) : Bool { token.id == token_id });\n    switch (item) {\n      case null {\n        return #Err(#InvalidTokenId);\n      };\n      case (?token) {\n        if (\n          caller != token.owner and\n          not List.some(custodians, func (custodian : Principal) : Bool { custodian == caller })\n        ) {\n          return #Err(#Unauthorized);\n        } else if (Principal.notEqual(from, token.owner)) {\n          return #Err(#Other);\n        } else {\n          nfts := List.map(nfts, func (item : Types.Nft) : Types.Nft {\n            if (item.id == token.id) {\n              let update : Types.Nft = {\n                owner = to;\n                id = item.id;\n                metadata = token.metadata;\n              };\n              return update;\n            } else {\n              return item;\n            };\n          });\n          transactionId += 1;\n          return #Ok(transactionId);   \n        };\n      };\n    };\n  };\n\n  public query func supportedInterfacesDip721() : async [Types.InterfaceId] {\n    return [#TransferNotification, #Burn, #Mint];\n  };\n\n  public query func logoDip721() : async Types.LogoResult {\n    return logo;\n  };\n\n  public query func nameDip721() : async Text {\n    return name;\n  };\n\n  public query func symbolDip721() : async Text {\n    return symbol;\n  };\n\n  public query func totalSupplyDip721() : async Nat64 {\n    return Nat64.fromNat(\n      List.size(nfts)\n    );\n  };\n\n  public query func getMetadataDip721(token_id: Types.TokenId) : async Types.MetadataResult {\n    let item = List.find(nfts, func(token: Types.Nft) : Bool { token.id == token_id });\n    switch (item) {\n      case null {\n        return #Err(#InvalidTokenId);\n      };\n      case (?token) {\n        return #Ok(token.metadata);\n      }\n    };\n  };\n\n  public query func getMaxLimitDip721() : async Nat16 {\n    return maxLimit;\n  };\n\n  public func getMetadataForUserDip721(user: Principal) : async Types.ExtendedMetadataResult {\n    let item = List.find(nfts, func(token: Types.Nft) : Bool { token.owner == user });\n    switch (item) {\n      case null {\n        return #Err(#Other);\n      };\n      case (?token) {\n        return #Ok({\n          metadata_desc = token.metadata;\n          token_id = token.id;\n        });\n      }\n    };\n  };\n\n  public query func getTokenIdsForUserDip721(user: Principal) : async [Types.TokenId] {\n    let items = List.filter(nfts, func(token: Types.Nft) : Bool { token.owner == user });\n    let tokenIds = List.map(items, func (item : Types.Nft) : Types.TokenId { item.id });\n    return List.toArray(tokenIds);\n  };\n\n  public shared({ caller }) func mintDip721(to: Principal, metadata: Types.MetadataDesc) : async Types.MintReceipt {\n    if (not List.some(custodians, func (custodian : Principal) : Bool { custodian == caller })) {\n      return #Err(#Unauthorized);\n    };\n\n    let newId = Nat64.fromNat(List.size(nfts));\n    let nft : Types.Nft = {\n      owner = to;\n      id = newId;\n      metadata = metadata;\n    };\n\n    nfts := List.push(nft, nfts);\n\n    transactionId += 1;\n\n    return #Ok({\n      token_id = newId;\n      id = transactionId;\n    });\n  };\n}","dip721-nft-container/src/Types.mo":"import Nat \"mo:base/Nat\";\nimport Nat8 \"mo:base/Nat8\";\nimport Nat16 \"mo:base/Nat16\";\nimport Nat32 \"mo:base/Nat32\";\nimport Nat64 \"mo:base/Nat64\";\nimport Blob \"mo:base/Blob\";\nimport Principal \"mo:base/Principal\";\n\nmodule {\n  public type Dip721NonFungibleToken = {\n    logo: LogoResult;\n    name: Text;\n    symbol: Text;\n    maxLimit : Nat16;\n  };\n\n  public type ApiError = {\n    #Unauthorized;\n    #InvalidTokenId;\n    #ZeroAddress;\n    #Other;\n  };\n\n  public type Result<S, E> = {\n    #Ok : S;\n    #Err : E;\n  };\n\n  public type OwnerResult = Result<Principal, ApiError>;\n  public type TxReceipt = Result<Nat, ApiError>;\n  \n  public type TransactionId = Nat;\n  public type TokenId = Nat64;\n\n  public type InterfaceId = {\n    #Approval;\n    #TransactionHistory;\n    #Mint;\n    #Burn;\n    #TransferNotification;\n  };\n\n  public type LogoResult = {\n    logo_type: Text;\n    data: Text;\n  };\n\n  public type Nft = {\n    owner: Principal;\n    id: TokenId;\n    metadata: MetadataDesc;\n  };\n\n  public type ExtendedMetadataResult = Result<{\n    metadata_desc: MetadataDesc;\n    token_id: TokenId;\n  }, ApiError>;\n\n  public type MetadataResult = Result<MetadataDesc, ApiError>;\n\n  public type MetadataDesc = [MetadataPart];\n\n  public type MetadataPart = {\n    purpose: MetadataPurpose;\n    key_val_data: [MetadataKeyVal];\n    data: Blob;\n  };\n\n  public type MetadataPurpose = {\n    #Preview;\n    #Rendered;\n  };\n  \n  public type MetadataKeyVal = {\n    key: Text;\n    val: MetadataVal;\n  };\n\n  public type MetadataVal = {\n    #TextContent : Text;\n    #BlobContent : Blob;\n    #NatContent : Nat;\n    #Nat8Content: Nat8;\n    #Nat16Content: Nat16;\n    #Nat32Content: Nat32;\n    #Nat64Content: Nat64;\n  };\n\n  public type MintReceipt = Result<MintReceiptPart, ApiError>;\n\n  public type MintReceiptPart = {\n    token_id: TokenId;\n    id: Nat;\n  };\n};\n","echo/src/Main.mo":"actor Echo {\n\n  // Say the given phase.\n  public query func say(phrase : Text) : async Text {\n    return phrase;\n  };\n};\n","encrypted-notes-dapp/src/encrypted_notes_motoko/main.mo":"import Map \"mo:base/HashMap\";\nimport Text \"mo:base/Text\";\nimport Array \"mo:base/Array\";\nimport Buffer \"mo:base/Buffer\";\nimport List \"mo:base/List\";\nimport Iter \"mo:base/Iter\";\nimport Time \"mo:base/Time\";\nimport Int \"mo:base/Int\";\nimport Nat \"mo:base/Nat\";\nimport Bool \"mo:base/Bool\";\nimport Principal \"mo:base/Principal\";\nimport Result \"mo:base/Result\";\nimport Option \"mo:base/Option\";\nimport Debug \"mo:base/Debug\";\nimport Order \"mo:base/Order\";\n\nimport En \"types\";\nimport UserStore \"user_store\";\n\n\n// Declare a shared actor class\n// Bind the caller and the initializer\nshared({ caller = initializer }) actor class() {\n\n    // Currently, a single canister smart contract is limited to 4 GB of storage due to WebAssembly limitations.\n    // To ensure that our canister does not exceed this limit, we restrict memory usage to at most 2 GB because \n    // up to 2x memory may be needed for data serialization during canister upgrades. Therefore, we aim to support\n    // up to 1,000 users, each storing up to 2 MB of data. \n    // 1) One half of this data is reserved for device management: \n    //     DEVICES_PER_USER = (MAX_CYPHERTEXT_LENGTH + MAX_PUBLIC_KEY_LENGTH + MAX_DEVICE_ALIAS_LENGTH) x (4 bytes per char) x MAX_DEVICES_PER_USER\n    //     1 MB = 40,700 x 4 x 6 = 976,800\n    // 2) Another half is reserved for storing the notes:\n    //     NOTES_PER_USER = MAX_NOTES_PER_USER x MAX_NOTE_CHARS x (4 bytes per char)\n    //     1 MB = 500 x 500 x 4 = 1,000,000\n\n    // Define dapp limits - important for security assurance\n    private let MAX_USERS = 1_000;\n    private let MAX_NOTES_PER_USER = 500;\n    private let MAX_DEVICES_PER_USER = 6;\n    private let MAX_NOTE_CHARS = 500;\n    private let MAX_DEVICE_ALIAS_LENGTH = 200;\n    private let MAX_PUBLIC_KEY_LENGTH = 500;\n    private let MAX_CYPHERTEXT_LENGTH = 40_000;\n\n    // Define private types\n    private type PrincipalName = Text;\n\n    // Define public types\n    // Type of an encrypted note\n    // Attention: This canister does *not* perform any encryption. \n    //            Here we assume that the notes are encrypted end-\n    //            to-end by the front-end (at client side). \n    public type EncryptedNote = {\n        encrypted_text: Text;\n        id: Nat;\n    };\n\n    // Define private fields\n    // Stable actor fields are automatically retained across canister upgrades. \n    // See https://smartcontracts.org/docs/language-guide/upgrades.html\n\n    // Design choice: Use globally unique note identifiers for all users.\n    //\n    // The keyword `stable` makes this (scalar) variable keep its value across canister upgrades.\n    //\n    // See https://smartcontracts.org/docs/developers-guide/working-with-canisters.html#upgrade-canister\n    private stable var nextNoteId: Nat = 1;\n    \n    // Internal representation: store each user's notes in a separate List. \n    private var notesByUser = Map.HashMap<PrincipalName, List.List<EncryptedNote>>(0, Text.equal, Text.hash);\n    \n    // While accessing data via [notesByUser] is more efficient, we use the following stable array\n    // as a buffer to preserve user notes across canister upgrades.\n    // See also: [preupgrade], [postupgrade]\n    private stable var stable_notesByUser: [(PrincipalName, List.List<EncryptedNote>)] = [];\n\n    // Internal representation: associate each user with a UserStore\n    private var users = Map.HashMap<Principal, UserStore.UserStore>(10, Principal.equal, Principal.hash);\n\n    // While accessing data via hashed structures (e.g., [users]) may be more efficient, we use \n    // the following stable array as a buffer to preserve registered users and user devices across \n    // canister upgrades. \n    // See also: [pre_upgrade], [post_upgrade]\n    // TODO: replace with\n    // private stable var stable_users: [UserStore.StableUserStoreEntry] = [];\n    // once https://github.com/dfinity/motoko/issues/3128 is resolved.\n    private stable var stable_users: [(Principal, En.PublicKey, En.DeviceAlias, ?En.Ciphertext)] = [];\n\n    // The following invariant is preserved by [register_device].\n    //\n    // All the functions of this canister's public API are available only to \n    // registered users, with the exception of [register_device] and [whoami].\n    //\n    // See also: [is_user_registered]\n    private func users_invariant(): Bool {\n        notesByUser.size() == users.size()\n    };\n\n    // Check if this user has been registered \n    // Note: [register_device] must be each user's very first update call.\n    // See also: [users_invariant]\n    private func is_user_registered(principal: Principal): Bool {\n        Option.isSome(users.get(principal));\n    };\n\n    // Returns the current number of users.\n    // Traps if [users_invariant] is violated\n    private func user_count(): Nat {\n        assert users_invariant();\n        notesByUser.size()\n    };\n\n    // Check that a note identifier is sane. This is needed since Motoko integers \n    // are infinite-precision. \n    // Note: avoid extraneous usage of async functions, hence [user_count]\n    private func is_id_sane(id: Int): Bool {\n        0 <= id and id < MAX_NOTES_PER_USER * user_count()\n    };\n\n    // Returns `true` iff [store.device_list] contains the provided public key [pk].\n    //\n    // Traps:\n    //      [store.device_list] exceeds [MAX_DEVICES_PER_USER]\n    //      [pk] exceeds [MAX_PUBLIC_KEY_LENGTH]\n    private func is_known_public_key(store: UserStore.UserStore, pk: En.PublicKey): Bool {\n        assert store.device_list.size() <= MAX_DEVICES_PER_USER;\n        assert pk.size() <= MAX_PUBLIC_KEY_LENGTH;\n\n        var found = false;\n        for (x in store.device_list.entries()) {\n            if (x.1 == pk) {\n                return true;\n            }\n        };\n        false\n    };\n\n    // Utility function that helps writing assertion-driven code more concisely.\n    private func expect<T>(opt: ?T, violation_msg: Text): T {\n        switch (opt) {\n            case (null) {\n                Debug.trap(violation_msg);\n            };\n            case (?x) {\n                x\n            };\n        };\n    };\n\n    // Reflects the [caller]'s identity by returning (a future of) its principal. \n    // Useful for debugging. \n    public shared({ caller }) func whoami(): async Text {\n        return Principal.toText(caller);\n    };\n\n    // Shared functions, i.e., those specified with [shared], are \n    // accessible to remote callers. \n    // The extra parameter [caller] is the caller's principal\n    // See https://smartcontracts.org/docs/language-guide/actors-async.html\n\n    // Add new note for this [caller]. Note: this function may be called only by \n    // those users that have at least one device registered via [register_device].\n    //      [encrypted_text]: (encrypted) content of this note\n    //\n    // Returns: \n    //      Future of unit\n    // Traps: \n    //      [caller] is the anonymous identity\n    //      [caller] is not a registered user\n    //      [encrypted_text] exceeds [MAX_NOTE_CHARS]\n    //      User already has [MAX_NOTES_PER_USER] notes\n    public shared({ caller }) func add_note(encrypted_text: Text): async () {\n        assert not Principal.isAnonymous(caller);\n        assert is_user_registered(caller);\n        assert encrypted_text.size() <= MAX_NOTE_CHARS;\n\n        Debug.print(\"Adding note...\");\n\n        let principalName = Principal.toText(caller);\n        let userNotes : List.List<EncryptedNote> = Option.get(notesByUser.get(principalName), List.nil<EncryptedNote>());\n\n        // check that user is not going to exceed limits\n        assert List.size(userNotes) < MAX_NOTES_PER_USER;\n        \n        let newNote: EncryptedNote = {\n            id = nextNoteId; \n            encrypted_text = encrypted_text\n        };\n        nextNoteId += 1;\n        notesByUser.put(principalName, List.push(newNote, userNotes));\n    };\n\n    // Returns (a future of) this [caller]'s notes.\n    // \n    // --- Queries vs. Updates ---\n    // Note that this method is declared as an *update* call (see `shared`) rather than *query*.\n    //\n    // While queries are significantly faster than updates, they are not certified by the IC. \n    // Thus, we avoid using queries throughout this dapp, ensuring that the result of our \n    // functions gets through consensus. Otherwise, this function could e.g. omit some notes \n    // if it got executed by a malicious node. (To make the dapp more efficient, one could \n    // use an approach in which both queries and updates are combined.)\n    // See https://smartcontracts.org/docs/developers-guide/concepts/canisters-code.html#query-update\n    //\n    // Returns: \n    //      Future of array of EncryptedNote\n    // Traps: \n    //      [caller] is the anonymous identity\n    //      [caller] is not a registered user\n    public shared({ caller }) func get_notes(): async [EncryptedNote] {\n        assert not Principal.isAnonymous(caller);\n        assert is_user_registered(caller);\n\n        let principalName = Principal.toText(caller);\n        let userNotes = Option.get(notesByUser.get(principalName), List.nil());\n        return List.toArray(userNotes);\n    };\n\n    // Update this [caller]'s note (by replacing an existing with \n    // the same id). If none of the existing notes have this id, \n    // do nothing. \n    // [encrypted_note]: the note to be updated\n    //\n    // Returns: \n    //      Future of unit\n    // Traps: \n    //      [caller] is the anonymous identity\n    //      [caller] is not a registered user\n    //      [encrypted_note.encrypted_text] exceeds [MAX_NOTE_CHARS]\n    //      [encrypted_note.id] is unreasonable; see [is_id_sane]\n    public shared({ caller }) func update_note(encrypted_note: EncryptedNote): async () {\n        assert not Principal.isAnonymous(caller);\n        assert is_user_registered(caller);\n        assert encrypted_note.encrypted_text.size() <= MAX_NOTE_CHARS;\n        assert is_id_sane(encrypted_note.id);\n\n        let principalName = Principal.toText(caller);\n        var existingNotes = expect(notesByUser.get(principalName), \n            \"registered user (principal \" # principalName # \") w/o allocated notes\");\n\n        var updatedNotes = List.map(existingNotes, func (note: EncryptedNote): EncryptedNote {\n            if (note.id == encrypted_note.id) {\n                encrypted_note\n            } else {\n                note\n            }\n        });\n        notesByUser.put(principalName, updatedNotes);\n    };\n\n    // Delete this [caller]'s note with given id. If none of the \n    // existing notes have this id, do nothing. \n    // [id]: the id of the note to be deleted\n    //\n    // Returns: \n    //      Future of unit\n    // Traps: \n    //      [caller] is the anonymous identity\n    //      [caller] is not a registered user\n    //      [id] is unreasonable; see [is_id_sane]\n    public shared({ caller }) func delete_note(id: Int): async () {\n        assert not Principal.isAnonymous(caller);\n        assert is_user_registered(caller);\n        assert is_id_sane(id);\n\n        let principalName = Principal.toText(caller);\n        var notesOfUser = Option.get(notesByUser.get(principalName), List.nil());\n\n        notesByUser.put(\n            principalName,\n            List.filter(notesOfUser, func(note: EncryptedNote): Bool { note.id != id })\n        )\n    };\n\n    // Below, we implement a decentralized key-value store. \n    // The purpose of this code is to support and synchronize \n    // multiple devices that a single user may have. \n\n    // Associate a public key with a device ID.\n    // Returns: \n    //      `true` iff device is *newly* registered, ie. [alias] has not been \n    //      registered for this user before. \n    // Traps:\n    //      [caller] is the anonymous identity\n    //      [alias] exceeds [MAX_DEVICE_ALIAS_LENGTH]\n    //      [pk] exceeds [MAX_PUBLIC_KEY_LENGTH]\n    //      While registering new user's device:\n    //          There are already [MAX_USERS] users while we need to register a new user\n    //          This user already has notes despite not having any registered devices\n    //      This user already has [MAX_DEVICES_PER_USER] registered devices.\n    public shared({ caller }) func register_device(\n        alias: En.DeviceAlias, pk: En.PublicKey\n    ): async Bool {\n        \n        assert not Principal.isAnonymous(caller);\n        assert alias.size() <= MAX_DEVICE_ALIAS_LENGTH;\n        assert pk.size() <= MAX_PUBLIC_KEY_LENGTH;\n\n        // get caller's device list and add\n        switch (users.get(caller)) {\n            case null {\n                // caller unknown ==> check invariants\n                // A. can we add a new user?\n                assert user_count() < MAX_USERS;\n                // B. this caller does not have notes\n                let principalName = Principal.toText(caller);\n                assert notesByUser.get(principalName) == null;\n\n                // ... then initialize the following:\n                // 1) a new [UserStore] instance in [users]\n                let new_store = UserStore.UserStore(caller, 10);\n                new_store.device_list.put(alias, pk);\n                users.put(caller, new_store);\n                // 2) a new [[EncryptedNote]] list in [notesByUser]\n                notesByUser.put(principalName, List.nil());\n                \n                // finally, indicate accept\n                true\n            };\n            case (?store) {\n                if (Option.isSome(store.device_list.get(alias))) {\n                    // device alias already registered ==> indicate reject\n                    false\n                } else {\n                    // device not yet registered ==> check that user did not exceed limits\n                    assert store.device_list.size() < MAX_DEVICES_PER_USER;\n                    // all good ==> register device\n                    store.device_list.put(alias, pk);\n                    // indicate accept\n                    true\n                }\n            };\n        }\n    };\n\n    // Remove this user's device with given [alias]\n    //\n    // Traps: \n    //      [caller] is the anonymous identity\n    //      [caller] is not a registered user\n    //      [alias] exceeds [MAX_DEVICE_ALIAS_LENGTH]\n    //      [caller] has only one registered device (which we refuse to remove)\n    public shared({ caller }) func remove_device(alias: En.DeviceAlias): () {\n        assert not Principal.isAnonymous(caller);\n        assert is_user_registered(caller);\n        assert alias.size() <= MAX_DEVICE_ALIAS_LENGTH;\n\n        let store = expect(users.get(caller), \n            \"registered user (principal \" # Principal.toText(caller) # \") w/o allocated notes\");\n\n        assert store.device_list.size() > 1;\n\n        Option.iterate(store.device_list.get(alias), func (k: En.PublicKey) {\n            store.ciphertext_list.delete(k);\n        });\n        store.device_list.delete(alias);\n    };\n\n    // Returns:\n    //      Future array of all (device, public key) pairs for this user's registered devices.\n    //\n    //      See also [get_notes], in particular, \"Queries vs. Updates\"\n    // Traps: \n    //      [caller] is the anonymous identity\n    //      [caller] is not a registered user\n    public shared({ caller }) func get_devices(): async [(En.DeviceAlias, En.PublicKey)] {\n        assert not Principal.isAnonymous(caller);\n        assert is_user_registered(caller);\n\n        let store = switch (users.get(caller)) {\n            case (?s) { s };\n            case null { return [] }\n        };\n        Iter.toArray(store.device_list.entries())\n    };\n\n    // Returns:\n    //      Future array of all public keys that are not already associated with a device.\n    //\n    //      See also [get_notes], in particular, \"Queries vs. Updates\"\n    // Traps: \n    //      [caller] is the anonymous identity\n    //      [caller] is not a registered user\n    public shared({ caller }) func get_unsynced_pubkeys(): async [En.PublicKey] {\n        assert not Principal.isAnonymous(caller);\n        assert is_user_registered(caller);\n\n        let store = switch (users.get(caller)) {\n            case (?s) { s };\n            case null { return [] }\n        };\n        let entries = Iter.toArray(store.device_list.entries());\n\n        Array.mapFilter(entries, func((alias, key): (En.DeviceAlias, En.PublicKey)): ?En.PublicKey {\n            if (Option.isNull(store.ciphertext_list.get(key))) {\n                ?key\n            } else {\n                null\n            }\n        })\n    };\n\n    // Returns: \n    //      `true` iff the user has at least one public key.\n    //\n    //      See also [get_notes], in particular, \"Queries vs. Updates\"\n    // Traps: \n    //      [caller] is the anonymous identity\n    //      [caller] is not a registered user\n    public shared({ caller }) func is_seeded(): async Bool {\n        assert not Principal.isAnonymous(caller);\n        assert is_user_registered(caller);\n\n        switch (users.get(caller)) {\n            case null { false };\n            case (?store) { store.ciphertext_list.size() > 0 }\n        }\n    };\n\n    // Fetch the private key associated with this public key.\n    // See also [get_notes], in particular, \"Queries vs. Updates\"\n    // Returns:\n    //      Future of an [En.Ciphertext] result\n    // Traps: \n    //      [caller] is the anonymous identity\n    //      [caller] is not a registered user\n    //      [pk] exceeds [MAX_PUBLIC_KEY_LENGTH]\n    public shared({ caller }) func get_ciphertext(\n        pk: En.PublicKey\n    ): async Result.Result<En.Ciphertext, En.GetCiphertextError> {\n        \n        assert not Principal.isAnonymous(caller);\n        assert is_user_registered(caller);        \n        assert pk.size() <= MAX_PUBLIC_KEY_LENGTH;\n                \n        let store = switch (users.get(caller)) {\n            case null { return #err(#notFound) };\n            case (?s) { s }\n        };\n        if (not is_known_public_key(store, pk)) {\n            return #err(#notFound) // pk unknown\n        };\n        switch (store.ciphertext_list.get(pk)) {\n            case null { #err(#notSynced) };\n            case (?ciphertext) { #ok(ciphertext) }\n        };\n    };\n\n    // Store a list of public keys and associated private keys. \n    // Considers only public keys matching those of a registered device.\n    // Does not overwrite key-value pairs that already exist.\n    //\n    // Traps: \n    //      [caller] is the anonymous identity\n    //      [caller] is not a registered user\n    //      Length of [ciphertexts] exceeds [MAX_DEVICES_PER_USER]\n    //      User is trying to save a known device's ciphertext exceeding [MAX_CYPHERTEXT_LENGTH]\n    public shared({ caller }) func submit_ciphertexts(ciphertexts: [(En.PublicKey, En.Ciphertext)]): () {\n        assert not Principal.isAnonymous(caller);\n        assert is_user_registered(caller);\n        assert ciphertexts.size() <= MAX_DEVICES_PER_USER;\n        \n        let store = switch (users.get(caller)) {\n            case null { return };\n            case (?s) { s }\n        };\n        for ((pk, text) in ciphertexts.vals()) {\n            if (is_known_public_key(store, pk) \n                and Option.isNull(store.ciphertext_list.get(pk))) {\n\n                assert text.size() <= MAX_CYPHERTEXT_LENGTH;\n                store.ciphertext_list.put(pk, text);\n            }\n        }\n    };\n\n    // Store a public key and associated private key in an empty user store. \n    // This function is a no-op if the user already has at least one public key stored.\n    //\n    // Traps: \n    //      [caller] is the anonymous identity\n    //      [caller] is not a registered user\n    //      [pk] exceeds [MAX_PUBLIC_KEY_LENGTH]\n    //      [ctext] exceeding [MAX_CYPHERTEXT_LENGTH]\n    public shared({ caller }) func seed(pk: En.PublicKey, ctext: En.Ciphertext): () {\n        assert not Principal.isAnonymous(caller);\n        assert is_user_registered(caller);\n        assert pk.size() <= MAX_PUBLIC_KEY_LENGTH;\n        assert ctext.size() <= MAX_CYPHERTEXT_LENGTH;\n\n        let store = switch (users.get(caller)) {\n            case null { return };\n            case (?s) { s }\n        };\n        if (is_known_public_key(store, pk) and store.ciphertext_list.size() == 0) {\n            store.ciphertext_list.put(pk, ctext)\n        }\n    };\n\n    // Below, we implement the upgrade hooks for our canister.\n    // See https://smartcontracts.org/docs/language-guide/upgrades.html\n\n    // The work required before a canister upgrade begins.\n    // See [nextNoteId], [stable_notesByUser], [stable_users]\n    system func preupgrade() {\n        Debug.print(\"Starting pre-upgrade hook...\");\n        stable_notesByUser := Iter.toArray(notesByUser.entries());\n        stable_users := UserStore.serializeAll(users);\n        Debug.print(\"pre-upgrade finished.\");\n    };\n\n    // The work required after a canister upgrade ends.\n    // See [nextNoteId], [stable_notesByUser], [stable_users]\n    system func postupgrade() {\n        Debug.print(\"Starting post-upgrade hook...\");\n        notesByUser := Map.fromIter<PrincipalName, List.List<EncryptedNote>>(\n            stable_notesByUser.vals(), stable_notesByUser.size(), Text.equal, Text.hash);\n\n        users := UserStore.deserialize(stable_users, stable_notesByUser.size());\n        stable_notesByUser := [];\n        Debug.print(\"post-upgrade finished.\");\n    };\n};\n","encrypted-notes-dapp/src/encrypted_notes_motoko/test/test.mo":"import Debug \"mo:base/Debug\";\n\nimport Option \"mo:base/Option\";\nimport Iter \"mo:base/Iter\";\nimport Array \"mo:base/Array\";\nimport List \"mo:base/List\";\nimport Text \"mo:base/Text\";\nimport Principal \"mo:base/Principal\";\n\nimport M \"mo:matchers/Matchers\";\nimport T \"mo:matchers/Testable\";\nimport Suite \"mo:matchers/Suite\";\nimport HM \"mo:matchers/matchers/Hashmap\";\n\nimport En \"../types\";\nimport UserStore \"../user_store\";\n\n// Custom [TestableItem] for serialized [UserStore] entries.\n// See https://github.com/kritzcreek/motoko-matchers/blob/master/src/Testable.mo\nfunc tuple4(ta: Principal, tb: En.PublicKey, tc: En.DeviceAlias, td: ?En.Ciphertext): \n    T.TestableItem<UserStore.StableUserStoreEntry> = {\n    \n    item = (ta, tb, tc, td);\n\n    display = func ((a, b, c, d): UserStore.StableUserStoreEntry): Text =\n        \"(\" # Principal.toText(a) # \", \" # b # \", \" # c # \", \" # Option.get(d, \"<none>\") # \")\";\n\n    equals = func ((a1, b1, c1, d1): UserStore.StableUserStoreEntry, \n                   (a2, b2, c2, d2): UserStore.StableUserStoreEntry): Bool =\n        Principal.equal(a1, a2) and \n        Text.equal(b1, b2) and \n        Text.equal(c1, c2) and \n        d1 == d2;\n};\n\n// Custom [TestableItem] for values of type [Principal].\n// See https://github.com/kritzcreek/motoko-matchers/blob/master/src/Testable.mo\nfunc princ(p: Principal): T.TestableItem<Principal> = {\n    item = p;\n\n    display = Principal.toText;\n\n    equals = Principal.equal;\n};\n\nfunc user_store(us: UserStore.UserStore): T.TestableItem<UserStore.UserStore> = {\n    item = us;\n\n    display = func (us: UserStore.UserStore): Text = \n        \"UserStore(principal = \" # Principal.toText(us.get_principal()) # \") {\\n\"\n        # \"    device_list =     \" # Array.foldLeft<(En.DeviceAlias, En.PublicKey), Text>(\n            Iter.toArray(us.device_list.entries()),\n            \"\",\n            func (buf: Text, (alias, pk): (En.DeviceAlias, En.PublicKey)): Text = buf # \"  (\" # alias # \" -> \" # pk # \")\") \n        # \";\\n\"\n        # \"    ciphertext_list = \" # Array.foldLeft<(En.PublicKey, En.Ciphertext), Text>(\n            Iter.toArray(us.ciphertext_list.entries()),\n            \"\",\n            func (buf: Text, (pk, ct): (En.PublicKey, En.Ciphertext)): Text = buf # \"  (\" # pk # \" -> \" # ct # \")\")\n        # \";\\n\"\n        # \"}\";\n\n    equals = func (us1: UserStore.UserStore, us2: UserStore.UserStore): Bool {\n        let s1: List.List<UserStore.StableUserStoreEntry> = List.fromArray(us1.serialize());\n        let s2: List.List<UserStore.StableUserStoreEntry> = List.fromArray(us2.serialize());\n        (List.size(s1) == List.size(s2))\n        and List.all(\n            List.zip(s1, s2), \n            func ((a, b): (UserStore.StableUserStoreEntry, UserStore.StableUserStoreEntry)): Bool {\n                a.0 == b.0 and  // Principal\n                a.1 == b.1 and  // En.PublicKey\n                a.2 == b.2 and  // En.DeviceAlias\n                a.3 == b.3      // ?En.Ciphertext\n            })\n    }\n};\n\nfunc PopulateUserStore(\n    principal: Principal, \n    dev_keys: [En.PublicKey], \n    dev_aliases: [En.DeviceAlias], \n    ciphertexts: [?En.Ciphertext],\n    permutation: [Nat]): UserStore.UserStore {\n\n    let store = UserStore.UserStore(principal, 10);\n    for (i in Iter.fromArray(permutation)) {\n        let key = dev_keys[i];\n        let alias = dev_aliases[i];\n        store.device_list.put(alias, key);\n        switch (ciphertexts[i]) {\n            case (null) {};\n            case (?ciphertext) {\n                store.ciphertext_list.put(key, ciphertext);\n            };\n        };\n    };\n    store\n};\n\nfunc C(t: Text): ?Text = Option.make(t);\n\nlet USER_1 = Principal.fromText(\"2vxsx-fae\");\nlet USER_1_dev_keys    = [ \"A1\", \"B1\", \"C1\", \"D1\" ];\nlet USER_1_dev_aliases = [ \"a1\", \"b1\", \"c1\", \"d1\" ];\nlet USER_1_ciphertexts = [ C(\"Ax\"), C(\"Bx\"), C(\"Cx\"), C(\"Dx\") ];\nlet USER_1_permuts = [\n    [0, 1, 2, 3],  // default order\n    [3, 2, 1, 0],  // test permutation 1\n    [2, 0, 3, 1],  // test permutation 2\n];\nfunc USER_1_store(permutation: [Nat]): UserStore.UserStore = \n    PopulateUserStore(\n        USER_1, \n        USER_1_dev_keys, \n        USER_1_dev_aliases, \n        USER_1_ciphertexts, \n        permutation);\n\nlet USER_2 = Principal.fromText(\"2vxsx-fae\");  // TODO: use a distinct principal for USER_2\nlet USER_2_dev_keys    = [ \"A2\", \"B2\", \"C2\", \"D2\", \"E2\" ];\nlet USER_2_dev_aliases = [ \"a2\", \"b2\", \"c2\", \"d2\", \"e2\" ];\nlet USER_2_ciphertexts = [ null, null, C(\"Cy\"), C(\"Dy\"), null ];\nlet USER_2_permuts = [\n    [0, 1, 2, 3, 4],  // default order\n    [4, 3, 2, 1, 0],  // test permutation 1\n    [3, 0, 4, 2, 1],  // test permutation 2\n];\nfunc USER_2_store(permutation: [Nat]): UserStore.UserStore = \n    PopulateUserStore(\n        USER_2, \n        USER_2_dev_keys, \n        USER_2_dev_aliases, \n        USER_2_ciphertexts, \n        permutation);\n\nSuite.run(\n    Suite.suite(\"UserStore\", [\n        Suite.suite(\"UserStore.serialize\", \n            Array.append(\n                Array.map(USER_1_permuts, func (perm: [Nat]): Suite.Suite =\n                    Suite.test(\n                        \"Serializing a user store with 4 fully-synced devices\", \n                        USER_1_store(perm).serialize(), \n                        M.array([\n                            M.equals(tuple4(USER_1, \"A1\", \"a1\", Option.make(\"Ax\"))),\n                            M.equals(tuple4(USER_1, \"B1\", \"b1\", Option.make(\"Bx\"))),\n                            M.equals(tuple4(USER_1, \"C1\", \"c1\", Option.make(\"Cx\"))),\n                            M.equals(tuple4(USER_1, \"D1\", \"d1\", Option.make(\"Dx\"))),\n                        ]))),\n                Array.map(USER_2_permuts, func (perm: [Nat]): Suite.Suite =\n                    Suite.test(\n                        \"Serializing a user store with 5 devices only 3 of which are synced\", \n                        USER_2_store(perm).serialize(), \n                        M.array([\n                            M.equals(tuple4(USER_2, \"A2\", \"a2\", null)),\n                            M.equals(tuple4(USER_2, \"B2\", \"b2\", null)),\n                            M.equals(tuple4(USER_2, \"C2\", \"c2\", Option.make(\"Cy\"))),\n                            M.equals(tuple4(USER_2, \"D2\", \"d2\", Option.make(\"Dy\"))),\n                            M.equals(tuple4(USER_2, \"E2\", \"e2\", null)),\n                        ]))))),\n        Suite.suite(\"UserStore.deserialize\", \n            Array.append(\n                [\n                    Suite.test(\n                        \"Smoke test\",\n                        UserStore.deserialize(USER_1_store(USER_1_permuts[0]).serialize(), 10),\n                        M.allOf([\n                            HM.hasKey<Principal, UserStore.UserStore>(princ(USER_1)),\n                            M.not_(HM.atKey<Principal, UserStore.UserStore>(princ(USER_1), M.equals(user_store(USER_2_store(USER_2_permuts[0])))))\n                        ]))\n                ],\n                Array.append(\n                    Array.map(USER_1_permuts, func (perm: [Nat]): Suite.Suite = \n                        Suite.test(\n                            \"Deserialize a serialized user store with 4 fully-synced devices\",\n                            UserStore.deserialize(USER_1_store(perm).serialize(), 10),\n                            M.allOf([\n                                HM.hasKey<Principal, UserStore.UserStore>(princ(USER_1)),\n                                HM.atKey<Principal, UserStore.UserStore>(princ(USER_1), M.equals(user_store(USER_1_store(perm))))\n                            ]))),\n                    Array.map(USER_2_permuts, func (perm: [Nat]): Suite.Suite = \n                        Suite.test(\n                            \"Deserialize a serialized user store with 5 devices only 3 of which are synced\",\n                            UserStore.deserialize(USER_2_store(perm).serialize(), 10),\n                            M.allOf([\n                                HM.hasKey<Principal, UserStore.UserStore>(princ(USER_2)),\n                                HM.atKey<Principal, UserStore.UserStore>(princ(USER_2), M.equals(user_store(USER_2_store(perm))))\n                            ]))))))\n    ]));\n\n","encrypted-notes-dapp/src/encrypted_notes_motoko/types.mo":"import Iter \"mo:base/Iter\";\nimport List \"mo:base/List\";\nimport Array \"mo:base/Array\";\nimport Order \"mo:base/Order\";\n\nimport Text \"mo:base/Text\";\n\nmodule BaseTypes {\n    public type PublicKey = Text;\n    public type Ciphertext = Text;\n    public type DeviceAlias = Text;\n    public type GetCiphertextError = { #notFound; #notSynced };\n\n    // Helper function that sorts an iterator of pairs by [#left] or [#right] column. \n    //\n    // Returns:\n    //      Immutable array of sorted pairs\n    public func sort_pairs_by_column<A<: Text, B<: Text>(pairs: Iter.Iter<(A, B)>, factor: {#left; #right}): [(A, B)] {\n        let mutable_array = List.toVarArray<(A, B)>(Iter.toList(pairs));\n        let comparator = switch (factor) {\n            case (#left) { \n                func (a: (A, B), b: (A, B)): Order.Order {\n                    Text.compare(a.0, b.0)\n                }\n            };\n            case (#right) {\n                func (a: (A, B), b: (A, B)): Order.Order {\n                    Text.compare(a.1, b.1)\n                }\n            };\n        };\n        Array.sortInPlace(mutable_array, comparator);\n        Array.freeze(mutable_array)\n    };\n}","encrypted-notes-dapp/src/encrypted_notes_motoko/user_store.mo":"import Option \"mo:base/Option\";\nimport Iter \"mo:base/Iter\";\nimport Map \"mo:base/HashMap\";\nimport Buffer \"mo:base/Buffer\";\nimport Array \"mo:base/Array\";\n\nimport Principal \"mo:base/Principal\";\nimport Text \"mo:base/Text\";\nimport Nat \"mo:base/Nat\";\n\nimport En \"types\";\n\nmodule {\n\n    // Each element (a, b, c, d) represents the following:\n    //  \"a\" = user principal,  \"b\" = device public key,  \"c\" = device alias,  \"d\" = the optional ciphertext\n    public type StableUserStoreEntry = (Principal, En.PublicKey, En.DeviceAlias, ?En.Ciphertext);\n\n    public class UserStore(principal: Principal, starting_buf_size: Nat) {\n\n        public let device_list = Map.HashMap<En.DeviceAlias, En.PublicKey>(starting_buf_size, Text.equal, Text.hash);\n        public let ciphertext_list = Map.HashMap<En.PublicKey, En.Ciphertext>(10, Text.equal, Text.hash);\n\n        private var stable_users: [StableUserStoreEntry] = [];\n\n        public func get_principal(): Principal = principal;\n\n        public func serialize(): [StableUserStoreEntry] {\n\n            // sort devices by public key\n            let devices: [(En.DeviceAlias, En.PublicKey)] = En.sort_pairs_by_column(\n                device_list.entries(),\n                #right);\n\n            // sort ciphertexts by public key\n            let ciphertexts: [(En.PublicKey, En.Ciphertext)] = En.sort_pairs_by_column(\n                ciphertext_list.entries(),\n                #left);\n\n            // Invariant: \n            // is_sorted(devices) ^ is_sorted(ciphertexts) \n            // ^ is_subset(set(ciphertexts#left), set(devices#right))\n            \n            // Zipping idea:\n            // devices     [ (a, x)       (b, y)     (c, z)       (d, t)       ]\n            // ciphertexts [ (x, 0)                  (z, 1)       (t, 2)       ]\n            // buf         [ (x, Some(0)) (y, None)  (z, Some(1)) (t, Some(2)) ]\n\n            let buf = Buffer.Buffer<StableUserStoreEntry>(\n                devices.size());\n\n            var pos = 0;\n            var cyp_pos = 0;\n            while (pos < devices.size()) {\n                let device_alias: En.DeviceAlias = devices[pos].0;\n                let pub_key: En.PublicKey = devices[pos].1;\n\n                if (cyp_pos < ciphertexts.size() and pub_key == ciphertexts[cyp_pos].0) {\n                    let cipher_text: En.Ciphertext = ciphertexts[cyp_pos].1;\n                    buf.add((principal, pub_key, device_alias, Option.make(cipher_text)));\n                    cyp_pos += 1;\n                } else {\n                    buf.add((principal, pub_key, device_alias, null));\n                };\n\n                pos += 1;\n            };\n            buf.toArray()\n        }\n    };\n\n    public func serializeAll(users: Map.HashMap<Principal, UserStore>): [StableUserStoreEntry] = \n        Array.flatten(Iter.toArray(Iter.map(\n            users.vals(), \n            func(user_store: UserStore): [StableUserStoreEntry] =\n                user_store.serialize())));\n\n    public func deserialize(serial: [StableUserStoreEntry], starting_buf_size: Nat): Map.HashMap<Principal, UserStore> {\n\n        let users = Map.HashMap<Principal, UserStore>(starting_buf_size, Principal.equal, Principal.hash);\n\n        for (entry in serial.vals()) {\n            let principal: Principal = entry.0;\n            let pub_key: En.PublicKey = entry.1;\n            let device_alias: En.DeviceAlias = entry.2;\n            let cipher_text_maybe: ?En.Ciphertext = entry.3;\n\n            switch (users.get(principal)) {\n                case (null) {\n                    // initialize user store\n                    let new_store = UserStore(principal, starting_buf_size);\n                    new_store.device_list.put(device_alias, pub_key);\n                    switch (cipher_text_maybe) {\n                        case (null) {};\n                        case (?cipher_text) new_store.ciphertext_list.put(pub_key, cipher_text);\n                    };\n                    users.put(principal, new_store);\n                };\n                case (?store) {\n                    // extend user store\n                    store.device_list.put(device_alias, pub_key);\n                    switch (cipher_text_maybe) {\n                        case (null) {};\n                        case (?cipher_text) store.ciphertext_list.put(pub_key, cipher_text);\n                    };\n                };\n            };\n        };\n\n        users\n    };\n\n}","factorial/src/Main.mo":"actor Factorial {\n\n  // Calculate the product of all positive integers less than or equal to `n`.\n  public query func fac(n : Nat) : async Nat {\n\n    // We implement the recustion in a helper function that does not return\n    // asynchronously.\n    func go(m : Nat) : Nat {\n      if (m == 0) {\n        return 1;\n      } else {\n        return m * go(m - 1);\n      };\n    };\n\n    // Return.\n    return go(n);\n  };\n};\n","hello-world/src/Main.mo":"import Debug \"mo:base/Debug\"\n\nactor HelloWorld {\n  public func main() {\n    Debug.print(\"Hello World!\")\n  }\n}\n","hello_cycles/src/hello_cycles/main.mo":"import Nat \"mo:base/Nat\";\nimport Nat64 \"mo:base/Nat64\";\nimport Cycles \"mo:base/ExperimentalCycles\";\n\nactor HelloCycles  {\n\n  let limit = 10_000_000;\n\n  public func wallet_balance() : async Nat {\n    return Cycles.balance();\n  };\n\n  public func wallet_receive() : async { accepted: Nat64 } {\n    let available = Cycles.available();\n    let accepted = Cycles.accept(Nat.min(available, limit));\n    { accepted = Nat64.fromNat(accepted) };\n  };\n\n  public func transfer(\n    receiver : shared () -> async (),\n    amount : Nat) : async { refunded : Nat } {\n      Cycles.add(amount);\n      await receiver();\n      { refunded = Cycles.refunded() };\n  };\n\n};\n","http_counter/src/main.mo":"import Nat \"mo:base/Nat\";\nimport Text \"mo:base/Text\";\nimport Array \"mo:base/Array\";\nimport Option \"mo:base/Option\";\nimport Prim \"mo:\";\nimport Prelude \"mo:base/Prelude\";\n\n\nactor HttpCounter {\n\n  type StreamingCallbackHttpResponse = {\n    body: Blob;\n    token: ?Token;\n  };\n\n  type Token = {\n    // Add whatever fields you'd like\n    arbitrary_data: Text;\n  };\n\n  type CallbackStrategy = {\n    callback: shared query (Token) -> async StreamingCallbackHttpResponse;\n    token: Token;\n  };\n\n  type StreamingStrategy =  {\n    #Callback: CallbackStrategy;\n  };\n\n  type HeaderField = (Text, Text);\n\n  type HttpResponse = {\n    status_code: Nat16;\n    headers: [HeaderField];\n    body: Blob;\n    streaming_strategy: ?StreamingStrategy;\n    upgrade: ?Bool;\n  };\n\n  type HttpRequest = {\n    method: Text;\n    url: Text;\n    headers: [HeaderField];\n    body: Blob;\n  };\n\n  func isGzip(x : HeaderField) : Bool {\n    Text.map(x.0 , Prim.charToLower) == \"accept-encoding\" and Text.contains(Text.map(x.1 , Prim.charToLower), #text \"gzip\");\n  };\n\n  stable var counter = 0;\n\n  public query func http_request(req : HttpRequest) : async HttpResponse {\n    switch (req.method, not Option.isNull(Array.find(req.headers, isGzip)), req.url) {\n      case (\"GET\", false, \"/stream\") {{\n        status_code = 200;\n        headers = [ (\"content-type\", \"text/plain\") ];\n        body = Text.encodeUtf8(\"Counter\");\n        streaming_strategy = ?#Callback({\n          callback = http_streaming;\n          token = {\n            arbitrary_data = \"start\";\n          }\n        });\n        upgrade = ?false;\n      }};\n      case (\"GET\", false, _) {{\n        status_code = 200;\n        headers = [ (\"content-type\", \"text/plain\") ];\n        body = Text.encodeUtf8(\"Counter is \" # Nat.toText(counter) # \"\\n\" # req.url # \"\\n\");\n        streaming_strategy = null;\n        upgrade = null;\n      }};\n      case (\"GET\", true, _) {{\n        status_code = 200;\n        headers = [ (\"content-type\", \"text/plain\"), (\"content-encoding\", \"gzip\") ];\n        body = \"\\1f\\8b\\08\\00\\98\\02\\1b\\62\\00\\03\\2b\\2c\\4d\\2d\\aa\\e4\\02\\00\\d6\\80\\2b\\05\\06\\00\\00\\00\";\n        streaming_strategy = null;\n        upgrade = null;\n      }};\n\n      case (\"POST\", _, _) {{\n        status_code = 204;\n        headers = [];\n        body = \"\";\n        streaming_strategy = null;\n        upgrade = ?true;\n      }};\n      case _ {{\n        status_code = 400;\n        headers = [];\n        body = \"Invalid request\";\n        streaming_strategy = null;\n        upgrade = null;\n      }};\n    }\n  };\n\n  public func http_request_update(req : HttpRequest) : async HttpResponse {\n    switch (req.method, not Option.isNull(Array.find(req.headers, isGzip))) {\n      case (\"POST\", false) {\n        counter += 1;\n        {\n          status_code = 201;\n          headers = [ (\"content-type\", \"text/plain\") ];\n          body = Text.encodeUtf8(\"Counter updated to \" # Nat.toText(counter) # \"\\n\");\n          streaming_strategy = null;\n          upgrade = null;\n        }\n      };\n      case (\"POST\", true) {\n        counter += 1;\n        {\n          status_code = 201;\n          headers = [ (\"content-type\", \"text/plain\"), (\"content-encoding\", \"gzip\") ];\n          body = \"\\1f\\8b\\08\\00\\37\\02\\1b\\62\\00\\03\\2b\\2d\\48\\49\\2c\\49\\e5\\02\\00\\a8\\da\\91\\6c\\07\\00\\00\\00\";\n          \n          streaming_strategy = null;\n          upgrade = null;\n        }\n      };\n      case _ {{\n        status_code = 400;\n        headers = [];\n        body = \"Invalid request\";\n        streaming_strategy = null;\n        upgrade = null;\n      }};\n    }\n  };\n\n  public query func http_streaming(token : Token) : async StreamingCallbackHttpResponse {\n    switch (token.arbitrary_data) {\n      case \"start\" {{\n        body = Text.encodeUtf8(\" is \");\n        token = ?{arbitrary_data = \"next\"};\n      }};\n      case \"next\" {{\n        body = Text.encodeUtf8(Nat.toText(counter));\n        token = ?{arbitrary_data = \"last\"};\n      }};\n      case \"last\" {{\n        body = Text.encodeUtf8(\" streaming\\n\");\n        token = null;\n      }};\n      case _ { Prelude.unreachable() };\n    }\n  };\n};\n","invoice-canister/examples/motoko-seller-client/backend/src/mocks/invoice.mo":"import A          \"../../../../../src/invoice/Account\";   \nimport Hex        \"../../../../../src/invoice/Hex\";\nimport T          \"../../../../../src/invoice/Types\";\nimport U          \"../../../../../src/invoice/Utils\";\n\nimport Array      \"mo:base/Array\";\nimport Blob       \"mo:base/Blob\";\nimport Debug      \"mo:base/Debug\";\nimport Hash       \"mo:base/Hash\";\nimport HashMap    \"mo:base/HashMap\";\nimport Iter       \"mo:base/Iter\";\nimport Nat        \"mo:base/Nat\";\nimport Nat64      \"mo:base/Nat64\";\nimport Option     \"mo:base/Option\";\nimport Principal  \"mo:base/Principal\";\nimport Result     \"mo:base/Result\";\nimport Text       \"mo:base/Text\";\nimport Time       \"mo:base/Time\";\n\nactor InvoiceMock {\n// #region Types\n  type Details = T.Details;\n  type Token = T.Token;\n  type TokenVerbose = T.TokenVerbose;\n  type AccountIdentifier = T.AccountIdentifier;\n  type Invoice = T.Invoice;\n// #endregion\n\n  let errInvalidToken = #err({\n    message = ?\"This token is not yet supported. Currently, this canister supports ICP.\";\n    kind = #InvalidToken;\n  });\n\n/**\n* Application State\n*/\n\n// #region State\n  stable var entries : [(Nat, Invoice)] = [];\n  stable var invoiceCounter : Nat = 0;\n  let invoices: HashMap.HashMap<Nat, Invoice> = HashMap.fromIter(Iter.fromArray(entries), entries.size(), Nat.equal, Hash.hash);\n\n  var icpBlockHeight : Nat = 0;\n  var icpLedgerMock : HashMap.HashMap<Blob, Nat> = HashMap.HashMap(16, Blob.equal, Blob.hash);\n  let MAX_INVOICES = 30_000;\n// #endregion\n\n/**\n* Application Interface\n*/    \n\n// #region Create Invoice\n  public shared ({caller}) func create_invoice (args: T.CreateInvoiceArgs) : async T.CreateInvoiceResult {\n    let id : Nat = invoiceCounter;\n    // increment counter\n    invoiceCounter += 1;\n    let inputsValid = areInputsValid(args);\n    if(not inputsValid) {\n      return #err({\n        message = ?\"Bad size: one or more of your inputs exceeds the allowed size.\";\n        kind = #BadSize;\n      });\n    };\n\n    if(id > MAX_INVOICES){\n      return #err({\n        message = ?\"The maximum number of invoices has been reached.\";\n        kind = #MaxInvoicesReached;\n      });\n    };\n\n    let destinationResult : T.GetDestinationAccountIdentifierResult = getDestinationAccountIdentifier({ \n      token = args.token;\n      invoiceId = id;\n      caller \n    });\n\n    switch(destinationResult){\n      case (#err result) {\n        return #err({\n          message = ?\"Invalid destination account identifier\";\n          kind = #InvalidDestination;\n        });\n      };\n      case (#ok result) {\n        let destination : AccountIdentifier = result.accountIdentifier;\n        let token = getTokenVerbose(args.token);\n\n        let invoice : Invoice = {\n          id;\n          creator = caller;\n          details = args.details;\n          permissions = args.permissions;\n          amount = args.amount;\n          amountPaid = 0;\n          token;\n          verifiedAtTime = null;\n          paid = false;\n          destination;\n        };\n    \n        invoices.put(id, invoice);\n\n        return #ok({invoice});\n      };\n    };\n  };\n\n  func getTokenVerbose(token: Token) : TokenVerbose { \n    switch(token.symbol){\n      case (\"ICP\") {\n        return {\n          symbol = \"ICP\";\n          decimals = 8;\n          meta = ?{\n            Issuer = \"e8s\";\n          }\n        };\n\n      };\n      case (_) {\n        return {\n          symbol = \"\";\n          decimals = 1;\n          meta = ?{\n            Issuer = \"\";\n          }\n        }\n      };\n    };\n  };\n\n  func areInputsValid(args : T.CreateInvoiceArgs) : Bool {\n    let token = getTokenVerbose(args.token);\n\n    var isValid = true;\n\n    switch (args.details){\n      case null {};\n      case (? details){\n        if (details.meta.size() > 32_000) {\n          isValid := false;\n        };\n        if (details.description.size() > 256) {\n          isValid := false;\n        };\n      };\n    };\n\n    switch (args.permissions){\n      case null {};\n      case (? permissions){\n        if (permissions.canGet.size() > 256 or permissions.canVerify.size() > 256) {\n          isValid := false;\n        };\n      };\n    };\n\n    return isValid;\n  };\n\n// #region Get Destination Account Identifier\n  func getDestinationAccountIdentifier (args: T.GetDestinationAccountIdentifierArgs) : T.GetDestinationAccountIdentifierResult {\n    let token = args.token;\n    switch(token.symbol){\n      case(\"ICP\"){\n        let canisterId = Principal.fromActor(InvoiceMock);\n\n        let account = U.getICPAccountIdentifier({\n          principal = canisterId;\n          subaccount = U.generateInvoiceSubaccount({ \n            caller = args.caller;\n            id = args.invoiceId;\n          });\n        });\n        let hexEncoded = Hex.encode(Blob.toArray(account));\n        let result: AccountIdentifier = #text(hexEncoded);\n        return #ok({accountIdentifier = result});\n      };\n      case(_){\n        return errInvalidToken;\n      };\n    };\n  };\n// #endregion\n// #endregion\n\n// #region Get Invoice\n  public shared query ({caller}) func get_invoice (args: T.GetInvoiceArgs) : async T.GetInvoiceResult {\n    let invoice = invoices.get(args.id);\n    switch(invoice){\n      case(null){\n        return #err({\n          message = ?\"Invoice not found\";\n          kind = #NotFound;\n        });\n      };\n      case (?i) {\n        if (i.creator == caller) {\n          return #ok({invoice = i});\n        };\n        // If additional permissions are provided\n        switch (i.permissions) {\n          case (null) {\n            return #err({\n              message = ?\"You do not have permission to view this invoice\";\n              kind = #NotAuthorized;\n            });\n          };\n          case (?permissions) {\n            let hasPermission = Array.find<Principal>(\n              permissions.canGet,\n              func (x : Principal) : Bool {\n                return x == caller;\n              }\n            );\n            if (Option.isSome(hasPermission)) {\n              return #ok({invoice = i});\n            } else {\n              return #err({\n                message = ?\"You do not have permission to view this invoice\";\n                kind = #NotAuthorized;\n              });\n            };\n          };\n        };\n        #ok({invoice = i});\n      };\n    };\n  };\n// #endregion\n\n// #region Get Balance\n  public shared ({caller}) func get_balance (args: T.GetBalanceArgs) : async T.GetBalanceResult {\n    let token = args.token;\n    let canisterId = Principal.fromActor(InvoiceMock);\n    switch(token.symbol){\n      case(\"ICP\"){\n        let defaultAccount = U.getDefaultAccount({\n          canisterId;\n          principal = caller;\n        });\n        let balance = icpLedgerMock.get(defaultAccount);\n        switch(balance){\n          case(null){\n            return #err({\n              message = ?\"Could not get balance\";\n              kind = #NotFound;\n            });\n          };\n          case(? b){\n            return #ok({balance = b});\n          };\n        };\n      };\n      case(_){\n        return errInvalidToken;\n      };\n    };\n  };\n// #endregion\n\n// #region Verify Invoice\n  public shared ({caller}) func verify_invoice (args: T.VerifyInvoiceArgs) : async T.VerifyInvoiceResult {\n    let invoice = invoices.get(args.id);\n    let canisterId = Principal.fromActor(InvoiceMock);\n\n    switch(invoice){\n      case(null){\n        return #err({\n          message = ?\"Invoice not found\";\n          kind = #NotFound;\n        });\n      };\n      case(? i){\n        // Return if already verified\n        if (i.verifiedAtTime != null){\n          return #ok(#AlreadyVerified{\n            invoice = i;\n          });\n        };\n\n        if (i.creator != caller) {\n          switch (i.permissions) {\n            case null {\n              return #err({\n                message = ?\"You do not have permission to verify this invoice\";\n                kind = #NotAuthorized;\n              });\n            };\n            case (?permissions) {\n              let hasPermission = Array.find<Principal>(\n                permissions.canVerify,\n                func (x : Principal) : Bool {\n                  return x == caller;\n                }\n              );\n              if (Option.isSome(hasPermission)) {\n                // May proceed\n              } else {\n                return #err({\n                  message = ?\"You do not have permission to verify this invoice\";\n                  kind = #NotAuthorized;\n                });\n              };\n            };\n          };\n        };\n\n        switch (i.token.symbol){\n          case(\"ICP\"){\n            let destinationResult = U.accountIdentifierToBlob({\n              accountIdentifier = i.destination;\n              canisterId = ?canisterId;\n              });\n            switch(destinationResult){\n              case(#err err){\n                return #err({\n                  kind = #InvalidAccount;\n                  message = ?\"Invalid destination account\";\n                });\n              };\n              case (#ok destination){\n                let destinationBalance = icpLedgerMock.get(destination);\n                switch(destinationBalance){\n                  case (null){\n                    return #err({\n                      message = ?\"Insufficient balance. Current Balance is 0\";\n                      kind = #NotYetPaid;\n                    });\n                  };\n                  case (? balance){\n                    if(balance < i.amount){\n                      return #err({\n                        message = ?Text.concat(\"Insufficient balance. Current Balance is \", Nat.toText(balance));\n                        kind = #NotYetPaid;\n                      });\n                    };\n                    let verifiedAtTime: ?Time.Time = ?Time.now();\n                    // Otherwise, update with latest balance and mark as paid\n                    let verifiedInvoice = {\n                      id = i.id;\n                      creator = i.creator;\n                      details = i.details;\n                      permissions = i.permissions;\n                      amount = i.amount;\n                      // update amountPaid\n                      amountPaid = balance;\n                      token = i.token;\n                      // update verifiedAtTime\n                      verifiedAtTime;\n                      // update paid\n                      paid = true;\n                      destination = i.destination;\n                    };\n\n                    // TODO Transfer funds to default subaccount of invoice creator\n                    let subaccount = U.generateInvoiceSubaccount({ caller = i.creator; id = i.id });\n                    let transfer = await mockICPTransfer({\n                      amount = {\n                        e8s = Nat64.fromNat(balance - 10_000);\n                      };\n                      fee = {\n                        e8s = 10_000;\n                      };\n                      memo = 0;\n                      from_subaccount = ?subaccount;\n                      to = #blob(U.getDefaultAccount({\n                        canisterId;\n                        principal = i.creator;\n                      }));\n                      token = i.token;\n                      canisterId = ?canisterId;\n                      created_at_time = null;\n                    });\n                    let replaced = invoices.replace(i.id, verifiedInvoice);\n                    return #ok(#Paid({\n                      invoice = verifiedInvoice;\n                    }));\n                  };\n                };\n\n              };\n            }\n          };\n          case(_){\n            return errInvalidToken;\n          };\n        };\n      };\n    };\n  };\n// #endregion\n\n// #region Transfer\n  public shared ({caller}) func transfer (args: T.TransferArgs) : async T.TransferResult {\n    let token = args.token;\n    let accountResult = U.accountIdentifierToBlob({\n      accountIdentifier = args.destination;\n      canisterId = ?Principal.fromActor(InvoiceMock);\n    });\n    switch (accountResult){\n      case (#err err){\n        return #err({\n          message = err.message;\n          kind = #InvalidDestination;\n        });\n      };\n      case (#ok destination){\n        switch(token.symbol){\n          case(\"ICP\"){\n            let now = Nat64.fromIntWrap(Time.now());\n            \n\n            let transferResult = await mockICPTransfer({\n              memo = 0;\n              fee = {\n                e8s = 10000;\n              };\n              amount = {\n                // Total amount, minus the fee\n                e8s = Nat64.sub(Nat64.fromNat(args.amount), 10000);\n              };\n              from_subaccount = ?A.principalToSubaccount(caller);\n\n              to = #blob(destination);\n              created_at_time = null;\n            });\n            switch (transferResult) {\n              case (#ok result) {\n                return #ok(result);\n              };\n              case (#err err) {\n                switch (err.kind){\n                  case (#BadFee _){\n                    return #err({\n                      message = err.message;\n                      kind = #BadFee;\n                    });\n                  };\n                  case (#InsufficientFunds _){\n                    return #err({\n                      message = err.message;\n                      kind = #InsufficientFunds;\n                    });\n                  };\n                  case (_){\n                    return #err({\n                      message = err.message;\n                      kind = #Other;\n                    });\n                  }\n                };\n              };\n            };\n          };\n          case(_){\n            return #err({\n              message = ?\"Token not supported\";\n              kind = #InvalidToken;\n            });\n          };\n        };\n      };\n    };\n  };\n// #endregion\n\n// #region get_account_identifier\n  /*\n    * Get Caller Identifier\n    * Allows a caller to the accountIdentifier for a given principal\n    * for a specific token.\n    */\n  public query func get_account_identifier (args: T.GetAccountIdentifierArgs) : async T.GetAccountIdentifierResult {\n    let token = args.token;\n    let principal = args.principal;\n    let canisterId = Principal.fromActor(InvoiceMock);\n    switch(token.symbol){\n      case(\"ICP\"){\n        let subaccount = U.getDefaultAccount({principal; canisterId;});\n        let hexEncoded = Hex.encode(\n          Blob.toArray(subaccount)\n        );\n        let result: AccountIdentifier = #text(hexEncoded);\n        return #ok({accountIdentifier = result});\n      };\n      case(_){\n        return errInvalidToken;\n      };\n    };\n  };\n// #endregion\n\n// #region Utils\n  public func accountIdentifierToBlob (accountIdentifier: AccountIdentifier) : async T.AccountIdentifierToBlobResult {\n    return U.accountIdentifierToBlob({\n      accountIdentifier;\n      canisterId = ?Principal.fromActor(InvoiceMock);\n    });\n  };\n  \n  func mockICPTransfer (args: T.ICPTransferArgs) : async T.ICPTransferResult {\n    let FEE = 10_000;\n    let amount = args.amount;\n    switch(args.from_subaccount){\n      case(? subaccount){\n        let fromAccount = U.getICPAccountIdentifier({\n          subaccount;\n          principal = Principal.fromActor(InvoiceMock);\n        });\n        let balance = icpLedgerMock.get(fromAccount);\n        switch(balance){\n          case(? b){\n            if(b < Nat64.toNat(amount.e8s) + FEE){\n              Debug.trap(\"InsufficientFunds\");\n            };\n            let newBalance = Nat.sub(Nat.sub(b, Nat64.toNat(amount.e8s)), FEE);\n            icpLedgerMock.put(fromAccount, newBalance);\n            \n            let destinationResult = U.accountIdentifierToBlob({\n              accountIdentifier = args.to;\n              canisterId = ?Principal.fromActor(InvoiceMock);\n            });\n            switch(destinationResult){\n              case(#err err){\n                switch(err.message){\n                  case (null){\n                    Debug.trap(\"InvalidDestination\");\n                  };\n                  case(? message){\n                    Debug.trap(message);\n                  };\n                }\n              };\n              case (#ok destination){\n                let destinationBalance = icpLedgerMock.get(destination);\n                let newDestinationBalance = newBalance + Nat64.toNat(amount.e8s);\n                icpLedgerMock.put(destination, newDestinationBalance);\n                icpBlockHeight := icpBlockHeight + 1;\n                return #ok({\n                  blockHeight = Nat64.fromNat(icpBlockHeight);\n                });\n\n              };\n            };\n          };\n          case(_){\n            Debug.trap(\"InsufficientFunds\");\n          };\n        };\n      };\n      case(null){\n        Debug.trap(\"InvalidSubaccount\");\n      };\n    };\n  };\n\n  // Useful for testing\n  type FreeMoneyArgs = {\n    amount: Nat;\n    accountIdentifier: AccountIdentifier;\n  };\n  type FreeMoneyResult = Result.Result<Nat, FreeMoneyError>;\n  type FreeMoneyError = {\n    message: ?Text;\n    kind: {\n      #InvalidDestination;\n    };\n  };\n  public func deposit_free_money (args: FreeMoneyArgs) : async FreeMoneyResult {\n    let amount = args.amount;\n    let accountBlob = U.accountIdentifierToBlob({\n      accountIdentifier = args.accountIdentifier;\n      canisterId = ?Principal.fromActor(InvoiceMock);\n    });\n    \n    switch(accountBlob){\n      case(#err err){\n        return #err({\n          message = err.message;\n          kind = #InvalidDestination;\n        });\n      };\n      case(#ok account){\n        let balanceResult = icpLedgerMock.get(account);\n        switch(balanceResult){\n          case(null){\n            icpLedgerMock.put(account, amount);\n            return #ok(amount);\n          };\n          case (? balance){\n            let newBalance = balance + amount;\n            icpLedgerMock.put(account, newBalance);\n            return #ok(newBalance);\n          };\n        };\n      };\n    };\n  };\n// #endregion\n\n// #region Upgrade Hooks\n  system func preupgrade() {\n      entries := Iter.toArray(invoices.entries());\n  };\n// #endregion\n}\n","invoice-canister/examples/motoko-seller-client/backend/src/seller/main.mo":"import Invoice \"canister:invoice\";\n\nimport Hash       \"mo:base/Hash\";\nimport HashMap    \"mo:base/HashMap\";\nimport Iter       \"mo:base/Iter\";\nimport Nat        \"mo:base/Nat\";\nimport Principal  \"mo:base/Principal\";\nimport Result     \"mo:base/Result\";\nimport Text       \"mo:base/Text\";\n\nactor Seller {\n\n  let ONE_ICP_IN_E8S = 100_000_000;\n\n  stable var invoicesStable : [(Nat, Invoice.Invoice)] = [];\n  var invoices: HashMap.HashMap<Nat, Invoice.Invoice> = HashMap.HashMap(16, Nat.equal, Hash.hash);\n\n  stable var licensesStable : [(Principal, Bool)] = [];\n  var licenses: HashMap.HashMap<Principal, Bool> = HashMap.HashMap(16, Principal.equal, Principal.hash);\n\n// #region create_invoice\n  public shared ({caller}) func create_invoice() : async Invoice.CreateInvoiceResult {\n    let invoiceCreateArgs : Invoice.CreateInvoiceArgs = {\n      amount = ONE_ICP_IN_E8S * 10;\n      token = {\n        symbol = \"ICP\";\n      };\n      permissions = null;\n      details = ?{\n        description = \"Example license certifying status\";\n        // JSON string as a blob\n        meta = Text.encodeUtf8(\n          \"{\\n\" #\n          \"  \\\"seller\\\": \\\"Invoice Canister Example Dapp\\\",\\n\" #\n          \"  \\\"itemized_bill\\\": [\\\"Standard License\\\"],\\n\" #\n          \"}\"\n        );\n      };\n    };\n    let invoiceResult = await Invoice.create_invoice(invoiceCreateArgs);\n    switch(invoiceResult){\n      case(#err _) {};\n      case(#ok result) {\n        invoices.put(result.invoice.id, result.invoice);\n      };\n    };\n    return invoiceResult;\n  };\n\n  public shared query ({caller}) func check_license_status() : async Bool {\n    let licenseResult = licenses.get(caller);\n    switch(licenseResult) {\n      case(null){\n        return false;\n      };\n      case (? license){\n        return license;\n      };\n    };\n  };\n\n  public shared query ({caller}) func get_invoice(id: Nat) : async ?Invoice.Invoice {\n    invoices.get(id);\n  };\n\n  public shared ({caller}) func verify_invoice(id: Nat) : async Invoice.VerifyInvoiceResult {\n    let invoiceResult = invoices.get(id);\n    switch(invoiceResult){\n      case(null){\n        return #err({\n          kind = #Other;\n          message = ?\"Invoice not found for this user\";\n        });\n      };\n      case (? invoice){\n        let verifyResult = await Invoice.verify_invoice({id = invoice.id});\n        switch(verifyResult){\n          case(#err _) {};\n          case(#ok result) {\n            switch(result){\n              case(#Paid p){\n                invoices.put(id, p.invoice);\n              };\n              case(#AlreadyPaid a){\n                invoices.put(id, a.invoice);\n              };\n            };\n            // update licenses with the verified invoice\n            licenses.put(caller, true);\n          };\n        };\n        \n        return verifyResult;\n      };\n    };\n  };\n\n// #region Utils\n  public shared ({caller}) func reset_license() : async () {\n    licenses.put(caller, false);\n    ();\n  };\n// #endregion\n\n// #region Upgrade Hooks\n  system func preupgrade() {\n      invoicesStable := Iter.toArray(invoices.entries());\n      licensesStable := Iter.toArray(licenses.entries());\n  };\n\n  system func postupgrade() {\n      invoices := HashMap.fromIter(Iter.fromArray(invoicesStable), 16, Nat.equal, Hash.hash);\n      invoicesStable := [];\n      licenses := HashMap.fromIter(Iter.fromArray(licensesStable), 16, Principal.equal, Principal.hash);\n      licensesStable := [];\n  };\n// #endregion\n};\n","invoice-canister/src/invoice/Account.mo":"import CRC32     \"./CRC32\";\nimport SHA224    \"./SHA224\";\n\nimport Array     \"mo:base/Array\";\nimport Blob      \"mo:base/Blob\";\nimport Buffer    \"mo:base/Buffer\";\nimport Nat32     \"mo:base/Nat32\";\nimport Nat8      \"mo:base/Nat8\";\nimport Principal \"mo:base/Principal\";\nimport Text      \"mo:base/Text\";\n\nmodule {\n  // 32-byte array.\n  public type AccountIdentifier = Blob;\n  // 32-byte array.\n  public type Subaccount = Blob;\n\n  public func beBytes(n : Nat32) : [Nat8] {\n    func byte(n : Nat32) : Nat8 {\n      Nat8.fromNat(Nat32.toNat(n & 0xff))\n    };\n    [byte(n >> 24), byte(n >> 16), byte(n >> 8), byte(n)]\n  };\n\n  public func defaultSubaccount() : Subaccount {\n    Blob.fromArrayMut(Array.init(32, 0 : Nat8))\n  };\n\n  public func accountIdentifier(principal : Principal, subaccount : Subaccount) : AccountIdentifier {\n    let hash = SHA224.Digest();\n    hash.write([0x0A]);\n    hash.write(Blob.toArray(Text.encodeUtf8(\"account-id\")));\n    hash.write(Blob.toArray(Principal.toBlob(principal)));\n    hash.write(Blob.toArray(subaccount));\n    let hashSum = hash.sum();\n    let crc32Bytes = beBytes(CRC32.ofArray(hashSum));\n    let buf = Buffer.Buffer<Nat8>(32);\n    Blob.fromArray(Array.append(crc32Bytes, hashSum))\n  };\n\n  public func validateAccountIdentifier(accountIdentifier : AccountIdentifier) : Bool {\n    if (accountIdentifier.size() != 32) {\n      return false;\n    };\n    let a = Blob.toArray(accountIdentifier);\n    let accIdPart    = Array.tabulate(28, func(i : Nat) : Nat8 { a[i + 4] });\n    let checksumPart = Array.tabulate(4,  func(i : Nat) : Nat8 { a[i] });\n    let crc32 = CRC32.ofArray(accIdPart);\n    Array.equal(beBytes(crc32), checksumPart, Nat8.equal)\n  };\n\n  public func principalToSubaccount(principal : Principal) : Blob {\n    let idHash = SHA224.Digest();\n    idHash.write(Blob.toArray(Principal.toBlob(principal)));\n    let hashSum = idHash.sum();\n    let crc32Bytes = beBytes(CRC32.ofArray(hashSum));\n    let buf = Buffer.Buffer<Nat8>(32);\n    Blob.fromArray(Array.append(crc32Bytes, hashSum));\n  };\n}\n","invoice-canister/src/invoice/CRC32.mo":"import Blob  \"mo:base/Blob\";\nimport Nat8  \"mo:base/Nat8\";\nimport Nat32 \"mo:base/Nat32\";\n\nmodule {\n\n  let crc32Table : [Nat32] =\n   [ 0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f\n   , 0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988\n   , 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91, 0x1db71064, 0x6ab020f2\n   , 0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7\n   , 0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9\n   , 0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172\n   , 0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b, 0x35b5a8fa, 0x42b2986c\n   , 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59\n   , 0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423\n   , 0xcfba9599, 0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924\n   , 0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190, 0x01db7106\n   , 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433\n   , 0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d\n   , 0x91646c97, 0xe6635c01, 0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e\n   , 0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950\n   , 0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65\n   , 0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7\n   , 0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0\n   , 0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa\n   , 0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f\n   , 0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81\n   , 0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a\n   , 0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683, 0xe3630b12, 0x94643b84\n   , 0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1\n   , 0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb\n   , 0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc\n   , 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5, 0xd6d6a3e8, 0xa1d1937e\n   , 0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b\n   , 0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55\n   , 0x316e8eef, 0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236\n   , 0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe, 0xb2bd0b28\n   , 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d\n   , 0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f\n   , 0x72076785, 0x05005713, 0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38\n   , 0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242\n   , 0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777\n   , 0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69\n   , 0x616bffd3, 0x166ccf45, 0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2\n   , 0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc\n   , 0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9\n   , 0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693\n   , 0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94\n   , 0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d\n   ];\n\n  let seed : Nat32 = 0xffffffff;\n\n  public func ofArray(arr : [Nat8]) : Nat32 {\n    ofBlob(Blob.fromArray(arr))\n  };\n\n  // Returns CRC-32 checksum of a byte array encoded as big-endian.\n  public func ofBlob(blob: Blob) : Nat32 {\n    // See https://en.wikipedia.org/wiki/Cyclic_redundancy_check#CRC-32_algorithm\n    var crc = seed;\n    for (b in blob.vals()) {\n      crc := crc32Table[Nat32.toNat(crc ^ Nat32.fromNat(Nat8.toNat(b)) & 0xff)] ^ (crc >> 8);\n    };\n    crc ^ seed\n  };\n}\n","invoice-canister/src/invoice/Hex.mo":"/**\n * Module      : Hex.mo\n * Description : Hexadecimal encoding and decoding routines.\n * Copyright   : 2022 Dfinity\n * License     : Apache 2.0>\n */\n\nimport Array \"mo:base/Array\";\nimport Iter \"mo:base/Iter\";\nimport Option \"mo:base/Option\";\nimport Nat8 \"mo:base/Nat8\";\nimport Char \"mo:base/Char\";\nimport Result \"mo:base/Result\";\nimport Text \"mo:base/Text\";\nimport Prim \"mo:\";\n\nmodule {\n\n  private type Result<Ok, Err> = Result.Result<Ok, Err>;\n\n  private let base : Nat8 = 0x10;\n\n  private let symbols = [\n    '0', '1', '2', '3', '4', '5', '6', '7',\n    '8', '9', 'A', 'B', 'C', 'D', 'E', 'F',\n  ];\n\n  /**\n   * Define a type to indicate that the decoder has failed.\n   */\n  public type DecodeError = {\n    #msg : Text;\n  };\n\n  /**\n   * Encode an array of unsigned 8-bit integers in hexadecimal format.\n   */\n  public func encode(array : [Nat8]) : Text {\n    let encoded = Array.foldLeft<Nat8, Text>(array, \"\", func (accum, w8) {\n      accum # encodeW8(w8);\n    });\n    // encode as lowercase\n    return Text.map(encoded, Prim.charToLower);\n  };\n\n  /**\n   * Encode an unsigned 8-bit integer in hexadecimal format.\n   */\n  private func encodeW8(w8 : Nat8) : Text {\n    let c1 = symbols[Nat8.toNat(w8 / base)];\n    let c2 = symbols[Nat8.toNat(w8 % base)];\n    Char.toText(c1) # Char.toText(c2);\n  };\n\n  /**\n   * Decode an array of unsigned 8-bit integers in hexadecimal format.\n   */\n  public func decode(text : Text) : Result<[Nat8], DecodeError> {\n    // Transform to uppercase for uniform decoding\n    let upper = Text.map(text, Prim.charToUpper);\n    let next = upper.chars().next;\n    func parse() : Result<Nat8, DecodeError> {\n      Option.get<Result<Nat8, DecodeError>>(\n        do ? {\n          let c1 = next()!;\n          let c2 = next()!;\n          Result.chain<Nat8, Nat8, DecodeError>(decodeW4(c1), func (x1) {\n            Result.chain<Nat8, Nat8, DecodeError>(decodeW4(c2), func (x2) {\n                #ok (x1 * base + x2);\n            })\n          })\n        },\n        #err (#msg \"Not enough input!\"),\n      );\n    };\n    var i = 0;\n    let n = upper.size() / 2 + upper.size() % 2;\n    let array = Array.init<Nat8>(n, 0);\n    while (i != n) {\n      switch (parse()) {\n        case (#ok w8) {\n          array[i] := w8;\n          i += 1;\n        };\n        case (#err err) {\n          return #err err;\n        };\n      };\n    };\n    #ok (Array.freeze<Nat8>(array));\n  };\n\n  /**\n   * Decode an unsigned 4-bit integer in hexadecimal format.\n   */\n  private func decodeW4(char : Char) : Result<Nat8, DecodeError> {\n    for (i in Iter.range(0, 15)) {\n      if (symbols[i] == char) {\n        return #ok (Nat8.fromNat(i));\n      };\n    };\n    let str = \"Unexpected character: \" # Char.toText(char);\n    #err (#msg str);\n  };\n};\n","invoice-canister/src/invoice/ICPLedger.mo":"import Ledger     \"canister:ledger\";\n\nimport A          \"./Account\";\nimport CRC32      \"./CRC32\";\nimport Hex        \"./Hex\";\nimport SHA224     \"./SHA224\";\nimport T          \"./Types\";\nimport U          \"./Utils\";\n\nimport Blob       \"mo:base/Blob\";\nimport Nat        \"mo:base/Nat\";\nimport Nat64      \"mo:base/Nat64\";\nimport Principal  \"mo:base/Principal\";\nimport Result     \"mo:base/Result\";\nimport Time       \"mo:base/Time\";\n\nmodule {\n  public type Memo = Nat64;\n\n  public type Tokens = {\n    e8s : Nat64;\n  };\n\n  public type TimeStamp = {\n    timestamp_nanos : Nat64;\n  };\n\n  public type AccountIdentifier = Blob;\n\n  public type SubAccount = Blob;\n\n  public type BlockIndex = Nat64;\n\n  public type TransferError = {\n    message : ?Text;\n    kind : {\n      #BadFee : {\n        expected_fee : Tokens;\n      };\n      #InsufficientFunds : {\n        balance : Tokens;\n      };\n      #TxTooOld : {\n        allowed_window_nanos : Nat64;\n      };\n      #TxCreatedInFuture;\n      #TxDuplicate : {\n        duplicate_of : BlockIndex;\n      };\n      #Other;\n    }\n  };\n\n  public type TransferArgs = {\n    memo : Memo;\n    amount : Tokens;\n    fee : Tokens;\n    from_subaccount : ?SubAccount;\n    to : AccountIdentifier;\n    created_at_time : ?TimeStamp;\n  };\n\n  public type TransferResult = Result.Result<T.TransferSuccess, TransferError>;\n\n  public func transfer (args : TransferArgs) : async TransferResult {\n    let result = await Ledger.transfer(args);\n    switch result {\n      case (#Ok index) {\n        #ok({blockHeight = index});\n      };\n      case (#Err err) {\n        switch err {\n          case (#BadFee kind) {\n            let expected_fee = kind.expected_fee;\n            #err({\n              message = ?(\"Bad Fee. Expected fee of \" # Nat64.toText(expected_fee.e8s) # \" but got \" # Nat64.toText(args.fee.e8s));\n              kind = #BadFee({expected_fee});\n            });\n          };\n          case (#InsufficientFunds kind) {\n            let balance = kind.balance;\n            #err({\n              message = ?(\"Insufficient balance. Current balance is \" # Nat64.toText(balance.e8s));\n              kind = #InsufficientFunds({balance});\n            })\n          };\n          case (#TxTooOld kind) {\n            let allowed_window_nanos = kind.allowed_window_nanos;\n            #err({\n              message = ?(\"Error - Tx Too Old. Allowed window of \" # Nat64.toText(allowed_window_nanos));\n              kind = #TxTooOld({allowed_window_nanos});\n            })\n          };\n          case (#TxCreatedInFuture) {\n            #err({\n              message = ?\"Error - Tx Created In Future\";\n              kind = #TxCreatedInFuture;\n            })\n          };\n          case (#TxDuplicate kind) {\n            let duplicate_of = kind.duplicate_of;\n            #err({\n              message = ?(\"Error - Duplicate transaction. Duplicate of \" # Nat64.toText(duplicate_of));\n              kind = #TxDuplicate({duplicate_of});\n            })\n          };\n        };\n      };\n    };\n  };\n\n  type AccountArgs = {\n    // Hex-encoded AccountIdentifier\n    account : Text;\n  };\n  type BalanceResult = Result.Result<BalanceSuccess, BalanceError>;\n\n  type BalanceSuccess = {\n    balance : Nat;\n  };\n  type BalanceError = {\n    message : ?Text;\n    kind : {\n      #InvalidToken;\n      #InvalidAccount;\n      #NotFound;\n      #Other;\n    };\n  };\n  public func balance(args : AccountArgs) : async BalanceResult {\n    switch (Hex.decode(args.account)) {\n      case (#err err) {\n        #err({\n          kind = #InvalidAccount;\n          message = ?\"Invalid account\";\n        });\n      };\n      case (#ok account) {\n        let balance = await Ledger.account_balance({account = Blob.fromArray(account)});\n        #ok({\n          balance = Nat64.toNat(balance.e8s);\n        });\n      };\n    };\n  };\n\n  public type GetICPAccountIdentifierArgs = {\n    principal : Principal;\n    subaccount : SubAccount;\n  };\n  public func getICPAccountIdentifier(args : GetICPAccountIdentifierArgs) : Blob {\n    A.accountIdentifier(args.principal, args.subaccount);\n  };\n\n  public type ICPVerifyInvoiceArgs = {\n    invoice : T.Invoice;\n    caller : Principal;\n    canisterId : Principal;\n  };\n  public func verifyInvoice(args : ICPVerifyInvoiceArgs) : async T.VerifyInvoiceResult {\n    let i = args.invoice;\n    let destinationResult = U.accountIdentifierToText({\n      accountIdentifier = i.destination;\n      canisterId = ?args.canisterId;\n    });\n    switch destinationResult {\n      case (#err err) {\n        #err({\n          kind = #InvalidAccount;\n          message = ?\"Invalid destination account\";\n        });\n      };\n      case (#ok destination) {\n        let balanceResult = await balance({account = destination});\n        switch balanceResult {\n          case (#err err) {\n            #err(err);\n          };\n          case (#ok b) {\n            let balance = b.balance;\n            // If balance is less than invoice amount, return error\n            if (balance < i.amount) {\n              return #err({\n                message = ?(\"Insufficient balance. Current Balance is \" # Nat.toText(balance));\n                kind = #NotYetPaid;\n              });\n            };\n\n            let verifiedAtTime : ?Time.Time = ?Time.now();\n\n            // TODO Transfer funds to default subaccount of invoice creator\n            let subaccount : SubAccount = U.generateInvoiceSubaccount({ caller = i.creator; id = i.id });\n\n            let transferResult = await transfer({\n              memo = 0;\n              fee = {\n                e8s = 10000;\n              };\n              amount = {\n                // Total amount, minus the fee\n                e8s = Nat64.sub(Nat64.fromNat(balance), 10000);\n              };\n              from_subaccount = ?subaccount;\n              to = U.getDefaultAccount({\n                canisterId = args.canisterId;\n                principal = i.creator;\n              });\n              created_at_time = null;\n            });\n            switch transferResult {\n              case (#ok result) {\n                let verifiedInvoice = {\n                  id = i.id;\n                  creator = i.creator;\n                  details = i.details;\n                  permissions = i.permissions;\n                  amount = i.amount;\n                  // update amountPaid\n                  amountPaid = balance;\n                  token = i.token;\n                  // update verifiedAtTime\n                  verifiedAtTime;\n                  // update paid\n                  paid = true; // since transfer has succeeded\n                  destination = i.destination;\n                };\n\n                #ok(#Paid {\n                  invoice = verifiedInvoice;\n                });\n              };\n              case (#err err) {\n                switch (err.kind) {\n                  case (#BadFee f) {\n                    #err({\n                      message = ?\"Bad fee\";\n                      kind = #TransferError;\n                    });\n                  };\n                  case (#InsufficientFunds f) {\n                    #err({\n                      message = ?\"Insufficient funds\";\n                      kind = #TransferError;\n                    });\n                  };\n                  case _ {\n                    #err({\n                      message = ?\"Could not transfer funds to invoice creator.\";\n                      kind = #TransferError;\n                    });\n                  }\n                };\n              };\n            };\n          };\n        };\n      }\n    };\n  };\n}\n","invoice-canister/src/invoice/SHA224.mo":"import Array \"mo:base/Array\";\nimport Iter \"mo:base/Iter\";\nimport Nat \"mo:base/Nat\";\nimport Nat8 \"mo:base/Nat8\";\nimport Nat32 \"mo:base/Nat32\";\nimport Nat64 \"mo:base/Nat64\";\n\nmodule {\n\n  private let K : [Nat32] = [\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,\n    0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,\n    0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,\n    0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,\n    0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,\n    0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,\n    0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,\n    0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,\n    0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2,\n  ];\n\n  private let S : [Nat32] = [\n    0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,\n    0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4,\n  ];\n\n  // Calculate a SHA224 hash.\n  public func sha224(data : [Nat8]) : [Nat8] {\n    let digest = Digest();\n    digest.write(data);\n    return digest.sum();\n  };\n\n  public class Digest() {\n\n    private let s = Array.thaw<Nat32>(S);\n\n    private let x = Array.init<Nat8>(64, 0);\n\n    private var nx = 0;\n\n    private var len : Nat64 = 0;\n\n    public func reset() {\n      for (i in Iter.range(0, 7)) {\n        s[i] := S[i];\n      };\n      nx := 0;\n      len := 0;\n    };\n\n    public func write(data : [Nat8]) {\n      var p = data;\n      len +%= Nat64.fromIntWrap(p.size());\n      if (nx > 0) {\n        let n = Nat.min(p.size(), 64 - nx);\n        for (i in Iter.range(0, n - 1)) {\n          x[nx + i] := p[i];\n        };\n        nx += n;\n        if (nx == 64) {\n          let buf = Array.freeze<Nat8>(x);\n          block(buf);\n          nx := 0;\n        };\n        p := Array.tabulate<Nat8>(p.size() - n, func (i) {\n          return p[n + i];\n        });\n      };\n      if (p.size() >= 64) {\n        let n = Nat64.toNat(Nat64.fromIntWrap(p.size()) & (^ 63));\n        let buf = Array.tabulate<Nat8>(n, func (i) {\n          return p[i];\n        });\n        block(buf);\n        p := Array.tabulate<Nat8>(p.size() - n, func (i) {\n          return p[n + i];\n        });\n      };\n      if (p.size() > 0) {\n        for (i in Iter.range(0, p.size() - 1)) {\n          x[i] := p[i];\n        };\n        nx := p.size();\n      };\n    };\n\n    public func sum() : [Nat8] {\n      var m = 0;\n      var n = len;\n      var t = Nat64.toNat(n) % 64;\n      var buf : [var Nat8] = [var];\n      if (56 > t) {\n        m := 56 - t;\n      } else {\n        m := 120 - t;\n      };\n      n := n << 3;\n      buf := Array.init<Nat8>(m, 0);\n      if (m > 0) {\n        buf[0] := 0x80;\n      };\n      write(Array.freeze<Nat8>(buf));\n      buf := Array.init<Nat8>(8, 0);\n      for (i in Iter.range(0, 7)) {\n        let j : Nat64 = 56 -% 8 *% Nat64.fromIntWrap(i);\n        buf[i] := Nat8.fromIntWrap(Nat64.toNat(n >> j));\n      };\n      write(Array.freeze<Nat8>(buf));\n      let hash = Array.init<Nat8>(28, 0);\n      for (i in Iter.range(0, 6)) {\n        for (j in Iter.range(0, 3)) {\n          let k : Nat32 = 24 -% 8 *% Nat32.fromIntWrap(j);\n          hash[4 * i + j] := Nat8.fromIntWrap(Nat32.toNat(s[i] >> k));\n        };\n      };\n      return Array.freeze<Nat8>(hash);\n    };\n\n    private func block(data : [Nat8]) {\n      var p = data;\n      var w = Array.init<Nat32>(64, 0);\n      while (p.size() >= 64) {\n        var j = 0;\n        for (i in Iter.range(0, 15)) {\n          j := i * 4;\n          w[i] :=\n            Nat32.fromIntWrap(Nat8.toNat(p[j + 0])) << 24 |\n            Nat32.fromIntWrap(Nat8.toNat(p[j + 1])) << 16 |\n            Nat32.fromIntWrap(Nat8.toNat(p[j + 2])) << 08 |\n            Nat32.fromIntWrap(Nat8.toNat(p[j + 3])) << 00;\n        };\n        var v1 : Nat32 = 0;\n        var v2 : Nat32 = 0;\n        var t1 : Nat32 = 0;\n        var t2 : Nat32 = 0;\n        for (i in Iter.range(16, 63)) {\n          v1 := w[i - 02];\n          v2 := w[i - 15];\n          t1 := rot(v1, 17) ^ rot(v1, 19) ^ (v1 >> 10);\n          t2 := rot(v2, 07) ^ rot(v2, 18) ^ (v2 >> 03);\n          w[i] :=\n              t1 +% w[i - 07] +%\n              t2 +% w[i - 16];\n        };\n        var a = s[0];\n        var b = s[1];\n        var c = s[2];\n        var d = s[3];\n        var e = s[4];\n        var f = s[5];\n        var g = s[6];\n        var h = s[7];\n        for (i in Iter.range(0, 63)) {\n          t1 := rot(e, 06) ^ rot(e, 11) ^ rot(e, 25);\n          t1 +%= (e & f) ^ (^ e & g) +% h +% K[i] +% w[i];\n          t2 := rot(a, 02) ^ rot(a, 13) ^ rot(a, 22);\n          t2 +%= (a & b) ^ (a & c) ^ (b & c);\n          h := g;\n          g := f;\n          f := e;\n          e := d +% t1;\n          d := c;\n          c := b;\n          b := a;\n          a := t1 +% t2;\n        };\n        s[0] +%= a;\n        s[1] +%= b;\n        s[2] +%= c;\n        s[3] +%= d;\n        s[4] +%= e;\n        s[5] +%= f;\n        s[6] +%= g;\n        s[7] +%= h;\n        p := Array.tabulate<Nat8>(p.size() - 64, func (i) {\n          return p[i + 64];\n        });\n      };\n    };\n  };\n\n  private let rot : (Nat32, Nat32) -> Nat32 = Nat32.bitrotRight;\n};\n","invoice-canister/src/invoice/Types.mo":"import Result     \"mo:base/Result\";\nimport Time       \"mo:base/Time\";\n\nmodule {\n/**\n* Base Types\n*/\n// #region Base Types\n  public type Token = {\n    symbol : Text;\n  };\n  public type TokenVerbose = {\n    symbol : Text;\n    decimals : Int;\n    meta : ?{\n      Issuer : Text;\n    };\n  };\n  public type AccountIdentifier = {\n    #text : Text;\n    #principal : Principal;\n    #blob : Blob;\n  };\n  public type Details = {\n    description : Text;\n    meta : Blob;\n  };\n  public type Permissions = {\n      canGet : [Principal];\n      canVerify : [Principal];\n  };\n  public type Invoice = {\n    id : Nat;\n    creator : Principal;\n    details : ?Details;\n    permissions : ?Permissions;\n    amount : Nat;\n    amountPaid : Nat;\n    token : TokenVerbose;\n    verifiedAtTime : ?Time.Time;\n    paid : Bool;\n    destination : AccountIdentifier;\n  };\n// #endregion\n\n/**\n* Service Args and Result Types\n*/\n\n// #region create_invoice\n  public type CreateInvoiceArgs = {\n    amount : Nat;\n    token : Token;\n    permissions: ?Permissions;\n    details : ?Details;\n  };\n  public type CreateInvoiceResult = Result.Result<CreateInvoiceSuccess, CreateInvoiceErr>;\n  public type CreateInvoiceSuccess = {\n    invoice : Invoice;\n  };\n  public type CreateInvoiceErr = {\n    message : ?Text;\n    kind : {\n      #BadSize;\n      #InvalidToken;\n      #InvalidAmount;\n      #InvalidDestination;\n      #InvalidDetails;\n      #MaxInvoicesReached;\n      #Other;\n    };\n  };\n// #endregion\n\n// #region Get Destination Account Identifier\n  public type GetDestinationAccountIdentifierArgs = {\n    token : Token;\n    caller : Principal;\n    invoiceId : Nat;\n  };\n  public type GetDestinationAccountIdentifierResult = Result.Result<GetDestinationAccountIdentifierSuccess, GetDestinationAccountIdentifierErr>;\n  public type GetDestinationAccountIdentifierSuccess = {\n    accountIdentifier : AccountIdentifier;\n  };\n  public type GetDestinationAccountIdentifierErr = {\n    message : ?Text;\n    kind : {\n        #InvalidToken;\n        #InvalidInvoiceId;\n        #Other;\n    };\n  };\n// #endregion\n\n// #region get_invoice\n  public type GetInvoiceArgs = {\n    id : Nat;\n  };\n  public type GetInvoiceResult = Result.Result<GetInvoiceSuccess, GetInvoiceErr>;\n  public type GetInvoiceSuccess = {\n    invoice : Invoice;\n  };\n  public type GetInvoiceErr = {\n    message : ?Text;\n    kind : {\n      #InvalidInvoiceId;\n      #NotFound;\n      #NotAuthorized;\n      #Other;\n    };\n  };\n// #endregion\n\n// #region get_balance\n  public type GetBalanceArgs = {\n    token : Token;\n  };\n  public type GetBalanceResult = Result.Result<GetBalanceSuccess, GetBalanceErr>;\n  public type GetBalanceSuccess = {\n    balance : Nat;\n  };\n  public type GetBalanceErr = {\n    message : ?Text;\n    kind : {\n      #InvalidToken;\n      #NotFound;\n      #Other;\n    };\n  };\n// #endregion\n\n// #region verify_invoice\n  public type VerifyInvoiceArgs = {\n    id : Nat;\n  };\n  public type VerifyInvoiceResult = Result.Result<VerifyInvoiceSuccess, VerifyInvoiceErr>;\n  public type VerifyInvoiceSuccess = {\n    #Paid : {\n      invoice : Invoice;\n    };\n    #AlreadyVerified : {\n      invoice : Invoice;\n    };\n  };\n  type VerifyInvoiceErr = {\n    message : ?Text;\n    kind : {\n      #InvalidInvoiceId;\n      #NotFound;\n      #NotYetPaid;\n      #NotAuthorized;\n      #Expired;\n      #TransferError;\n      #InvalidToken;\n      #InvalidAccount;\n      #Other;\n    };\n  };\n// #endregion\n\n// #region transfer\n  public type TransferArgs = {\n    amount : Nat;\n    token : Token;\n    destination : AccountIdentifier;\n  };\n  public type TransferResult = Result.Result<TransferSuccess, TransferError>;\n  public type TransferSuccess = {\n    blockHeight : Nat64;\n  };\n  public type TransferError = {\n    message : ?Text;\n    kind : {\n      #BadFee;\n      #InsufficientFunds;\n      #InvalidToken;\n      #InvalidDestination;\n      #Other;\n    };\n  };\n// #endregion\n\n// #region get_caller_identifier\n  public type GetAccountIdentifierArgs = {\n    token : Token;\n    principal : Principal;\n  };\n  public type GetAccountIdentifierResult = Result.Result<GetAccountIdentifierSuccess, GetAccountIdentifierErr>;\n  public type GetAccountIdentifierSuccess = {\n    accountIdentifier : AccountIdentifier;\n  };\n  public type GetAccountIdentifierErr = {\n    message : ?Text;\n    kind : {\n      #InvalidToken;\n      #Other;\n    };\n  };\n// #endregion\n\n// #region accountIdentifierToBlob\n  public type AccountIdentifierToBlobArgs = {\n    accountIdentifier : AccountIdentifier;\n    canisterId : ?Principal;\n  };\n  public type AccountIdentifierToBlobResult = Result.Result<AccountIdentifierToBlobSuccess, AccountIdentifierToBlobErr>;\n  public type AccountIdentifierToBlobSuccess = Blob;\n  public type AccountIdentifierToBlobErr = {\n    message : ?Text;\n    kind : {\n      #InvalidAccountIdentifier;\n      #Other;\n    };\n  };\n// #endregion\n\n// #region accountIdentifierToText\n  public type AccountIdentifierToTextArgs = {\n    accountIdentifier : AccountIdentifier;\n    canisterId : ?Principal;\n  };\n  public type AccountIdentifierToTextResult = Result.Result<AccountIdentifierToTextSuccess, AccountIdentifierToTextErr>;\n  public type AccountIdentifierToTextSuccess = Text;\n  public type AccountIdentifierToTextErr = {\n    message : ?Text;\n    kind : {\n      #InvalidAccountIdentifier;\n      #Other;\n    };\n  };\n// #endregion\n\n// #region ICP Transfer\n  public type Memo = Nat64;\n  public type SubAccount = Blob;\n  public type TimeStamp = {\n    timestamp_nanos : Nat64;\n  };\n  public type ICPTokens = {\n    e8s : Nat64;\n  };\n  public type ICPTransferError = {\n    message : ?Text;\n    kind : {\n      #BadFee : {\n        expected_fee : ICPTokens;\n      };\n      #InsufficientFunds : {\n        balance : ICPTokens;\n      };\n      #TxTooOld : {\n        allowed_window_nanos : Nat64;\n      };\n      #TxCreatedInFuture;\n      #TxDuplicate : {\n        duplicate_of : Nat;\n      };\n      #Other;\n    }\n  };\n\n  public type ICPTransferArgs = {\n    memo : Memo;\n    amount : ICPTokens;\n    fee : ICPTokens;\n    from_subaccount : ?SubAccount;\n    to : AccountIdentifier;\n    created_at_time : ?TimeStamp;\n  };\n\n  public type ICPTransferResult = Result.Result<TransferSuccess, ICPTransferError>;\n// #endregion\n};\n","invoice-canister/src/invoice/Utils.mo":"import A          \"./Account\";\nimport CRC32      \"./CRC32\";\nimport Hex        \"./Hex\";\nimport SHA224     \"./SHA224\";\nimport T          \"./Types\";\n\nimport Array      \"mo:base/Array\";\nimport Blob       \"mo:base/Blob\";\nimport Buffer     \"mo:base/Buffer\";\nimport Error      \"mo:base/Error\";\nimport Nat8       \"mo:base/Nat8\";\nimport Nat32      \"mo:base/Nat32\";\nimport Principal  \"mo:base/Principal\";\nimport Text       \"mo:base/Text\";\n\nmodule {\n  type AccountIdentifier = T.AccountIdentifier;\n\n  /**\n    * args : { accountIdentifier : AccountIdentifier, canisterId  : ?Principal }\n    * Takes an account identifier and returns a Blob\n    *\n    * Canister ID is required only for Principal, and will return an account identifier using that principal as a subaccount for the provided canisterId\n    */\n  public func accountIdentifierToBlob (args : T.AccountIdentifierToBlobArgs) : T.AccountIdentifierToBlobResult {\n    let accountIdentifier = args.accountIdentifier;\n    let canisterId = args.canisterId;\n    let err = {\n      kind = #InvalidAccountIdentifier;\n      message = ?\"Invalid account identifier\";\n    };\n    switch (accountIdentifier) {\n      case(#text(identifier)){\n        switch (Hex.decode(identifier)) {\n          case(#ok v){\n            let blob = Blob.fromArray(v);\n            if(A.validateAccountIdentifier(blob)){\n              #ok(blob);\n            } else {\n              #err(err);\n            }\n          };\n          case(#err _){\n            #err(err);\n          };\n        };\n      };\n      case(#principal principal){\n        switch(canisterId){\n          case (null){\n            #err({\n              kind = #Other;\n              message = ?\"Canister Id is required for account identifiers of type principal\";\n            })\n          };\n          case (? id){\n            let identifier = A.accountIdentifier(id, A.principalToSubaccount(principal));\n            if(A.validateAccountIdentifier(identifier)){\n              #ok(identifier);\n            } else {\n              #err(err);\n            }\n          };\n        }\n      };\n      case(#blob(identifier)){\n        if(A.validateAccountIdentifier(identifier)){\n          #ok(identifier);\n        } else {\n          #err(err);\n        }\n      };\n    };\n  };\n  /**\n    * args : { accountIdentifier : AccountIdentifier, canisterId  : ?Principal }\n    * Takes an account identifier and returns Hex-encoded Text\n    *\n    * Canister ID is required only for Principal, and will return an account identifier using that principal as a subaccount for the provided canisterId\n    */\n  public func accountIdentifierToText (args : T.AccountIdentifierToTextArgs) : T.AccountIdentifierToTextResult {\n    let accountIdentifier = args.accountIdentifier;\n    let canisterId = args.canisterId;\n    switch (accountIdentifier) {\n      case(#text(identifier)){\n        #ok(identifier);\n      };\n      case(#principal(identifier)){\n        let blobResult = accountIdentifierToBlob(args);\n        switch(blobResult){\n          case(#ok(blob)){\n            #ok(Hex.encode(Blob.toArray(blob)));\n          };\n          case(#err(err)){\n            #err(err);\n          };\n        };\n      };\n      case(#blob(identifier)){\n        let blobResult = accountIdentifierToBlob(args);\n        switch(blobResult){\n          case(#ok(blob)){\n            #ok(Hex.encode(Blob.toArray(blob)));\n          };\n          case(#err(err)){\n            #err(err);\n          };\n        };\n      };\n    };\n  };\n\n  type GenerateInvoiceSubaccountArgs = {\n    caller : Principal;\n    id : Nat;\n  };\n  /**\n    * Generates a subaccount for the given principal, to be used as an invoice destination. This is a subaccount, not a full accountIdentifier.\n    *\n    * args : { caller : Principal, id : Nat }\n    * Returns : Principal\n    */\n  public func generateInvoiceSubaccount (args : GenerateInvoiceSubaccountArgs) : Blob {\n    let idHash = SHA224.Digest();\n    // Length of domain separator\n    idHash.write([0x0A]);\n    // Domain separator\n    idHash.write(Blob.toArray(Text.encodeUtf8(\"invoice-id\")));\n    // Counter as Nonce\n    let idBytes = A.beBytes(Nat32.fromNat(args.id));\n    idHash.write(idBytes);\n    // Principal of caller\n    idHash.write(Blob.toArray(Principal.toBlob(args.caller)));\n\n    let hashSum = idHash.sum();\n    let crc32Bytes = A.beBytes(CRC32.ofArray(hashSum));\n    let buf = Buffer.Buffer<Nat8>(32);\n    Blob.fromArray(Array.append(crc32Bytes, hashSum));\n  };\n\n  type DefaultAccountArgs = {\n    // Hex-encoded AccountIdentifier\n    canisterId : Principal;\n    principal : Principal;\n  };\n  public func getDefaultAccount(args : DefaultAccountArgs) : Blob {\n    A.accountIdentifier(args.canisterId, A.principalToSubaccount(args.principal));\n  };\n\n  public type GetICPAccountIdentifierArgs = {\n    principal : Principal;\n    subaccount : T.SubAccount;\n  };\n  public func getICPAccountIdentifier(args : GetICPAccountIdentifierArgs) : Blob {\n    A.accountIdentifier(args.principal, args.subaccount);\n  };\n}\n","invoice-canister/src/invoice/main.mo":"import A          \"./Account\";\nimport Hex        \"./Hex\";\nimport ICP        \"./ICPLedger\";\nimport T          \"./Types\";\nimport U          \"./Utils\";\n\nimport Array      \"mo:base/Array\";\nimport Blob       \"mo:base/Blob\";\nimport Hash       \"mo:base/Hash\";\nimport HashMap    \"mo:base/HashMap\";\nimport Iter       \"mo:base/Iter\";\nimport Nat        \"mo:base/Nat\";\nimport Nat64      \"mo:base/Nat64\";\nimport Option     \"mo:base/Option\";\nimport Principal  \"mo:base/Principal\";\nimport Text       \"mo:base/Text\";\nimport Time       \"mo:base/Time\";\n\nactor Invoice {\n// #region Types\n  type Details = T.Details;\n  type Token = T.Token;\n  type TokenVerbose = T.TokenVerbose;\n  type AccountIdentifier = T.AccountIdentifier;\n  type Invoice = T.Invoice;\n// #endregion\n\n  let errInvalidToken =\n    #err({\n       message = ?\"This token is not yet supported. Currently, this canister supports ICP.\";\n       kind = #InvalidToken;\n    });\n\n/**\n* Application State\n*/\n\n// #region State\n  stable var entries : [(Nat, Invoice)] = [];\n  stable var invoiceCounter : Nat = 0;\n  let invoices : HashMap.HashMap<Nat, Invoice> = HashMap.fromIter(Iter.fromArray(entries), entries.size(), Nat.equal, Hash.hash);\n  entries := [];\n  let MAX_INVOICES = 30_000;\n// #endregion\n\n/**\n* Application Interface\n*/\n\n// #region Create Invoice\n  public shared ({caller}) func create_invoice (args : T.CreateInvoiceArgs) : async T.CreateInvoiceResult {\n    let id : Nat = invoiceCounter;\n    // increment counter\n    invoiceCounter += 1;\n    let inputsValid = areInputsValid(args);\n    if(not inputsValid) {\n      return #err({\n        message = ?\"Bad size: one or more of your inputs exceeds the allowed size.\";\n        kind = #BadSize;\n      });\n    };\n\n    if(id > MAX_INVOICES){\n      return #err({\n        message = ?\"The maximum number of invoices has been reached.\";\n        kind = #MaxInvoicesReached;\n      });\n    };\n\n    let destinationResult : T.GetDestinationAccountIdentifierResult = getDestinationAccountIdentifier({\n      token = args.token;\n      invoiceId = id;\n      caller\n    });\n\n    switch(destinationResult){\n      case (#err result) {\n        #err({\n          message = ?\"Invalid destination account identifier\";\n          kind = #InvalidDestination;\n        });\n      };\n      case (#ok result) {\n        let destination : AccountIdentifier = result.accountIdentifier;\n        let token = getTokenVerbose(args.token);\n\n        let invoice : Invoice = {\n          id;\n          creator = caller;\n          details = args.details;\n          permissions = args.permissions;\n          amount = args.amount;\n          amountPaid = 0;\n          token;\n          verifiedAtTime = null;\n          paid = false;\n          destination;\n        };\n\n        invoices.put(id, invoice);\n\n        #ok({invoice});\n      };\n    };\n  };\n\n  func getTokenVerbose(token : Token) : TokenVerbose {\n    switch(token.symbol){\n      case (\"ICP\") {\n        {\n          symbol = \"ICP\";\n          decimals = 8;\n          meta = ?{\n            Issuer = \"e8s\";\n          }\n        };\n\n      };\n      case (_) {\n        {\n          symbol = \"\";\n          decimals = 1;\n          meta = ?{\n            Issuer = \"\";\n          }\n        }\n      };\n    };\n  };\n\n  func areInputsValid(args : T.CreateInvoiceArgs) : Bool {\n    let token = getTokenVerbose(args.token);\n\n    var isValid = true;\n\n    switch (args.details){\n      case null {};\n      case (? details){\n        if (details.meta.size() > 32_000) {\n          isValid := false;\n        };\n        if (details.description.size() > 256) {\n          isValid := false;\n        };\n      };\n    };\n\n    switch (args.permissions){\n      case null {};\n      case (? permissions){\n        if (permissions.canGet.size() > 256 or permissions.canVerify.size() > 256) {\n          isValid := false;\n        };\n      };\n    };\n\n    return isValid;\n  };\n\n// #region Get Destination Account Identifier\n  func getDestinationAccountIdentifier (args : T.GetDestinationAccountIdentifierArgs) : T.GetDestinationAccountIdentifierResult {\n    let token = args.token;\n    switch (token.symbol) {\n      case \"ICP\" {\n        let canisterId = Principal.fromActor(Invoice);\n\n        let account = U.getICPAccountIdentifier({\n          principal = canisterId;\n          subaccount = U.generateInvoiceSubaccount({\n            caller = args.caller;\n            id = args.invoiceId;\n          });\n        });\n        let hexEncoded = Hex.encode(Blob.toArray(account));\n        let result : AccountIdentifier = #text(hexEncoded);\n        #ok({accountIdentifier = result});\n      };\n      case _ {\n        errInvalidToken;\n      };\n    };\n  };\n// #endregion\n// #endregion\n\n// #region Get Invoice\n  public shared query ({caller}) func get_invoice (args : T.GetInvoiceArgs) : async T.GetInvoiceResult {\n    let invoice = invoices.get(args.id);\n    switch invoice {\n      case null {\n        #err({\n          message = ?\"Invoice not found\";\n          kind = #NotFound;\n        });\n      };\n      case (?i) {\n        if (i.creator == caller) {\n          return #ok({invoice = i});\n        };\n        // If additional permissions are provided\n        switch (i.permissions) {\n          case (null) {\n            return #err({\n              message = ?\"You do not have permission to view this invoice\";\n              kind = #NotAuthorized;\n            });\n          };\n          case (?permissions) {\n            let hasPermission = Array.find<Principal>(\n              permissions.canGet,\n              func (x : Principal) : Bool {\n                return x == caller;\n              }\n            );\n            if (Option.isSome(hasPermission)) {\n              return #ok({invoice = i});\n            } else {\n              return #err({\n                message = ?\"You do not have permission to view this invoice\";\n                kind = #NotAuthorized;\n              });\n            };\n          };\n        };\n        #ok({invoice = i});\n      };\n    };\n  };\n// #endregion\n\n// #region Get Balance\n  public shared ({caller}) func get_balance (args : T.GetBalanceArgs) : async T.GetBalanceResult {\n    let token = args.token;\n    let canisterId = Principal.fromActor(Invoice);\n    switch (token.symbol) {\n      case \"ICP\" {\n        let defaultAccount = Hex.encode(\n          Blob.toArray(\n            U.getDefaultAccount({\n              canisterId;\n              principal = caller;\n            })\n         )\n        );\n        let balance = await ICP.balance({account = defaultAccount});\n        switch(balance) {\n          case (#err err) {\n            #err({\n              message = ?\"Could not get balance\";\n              kind = #NotFound;\n            });\n          };\n          case (#ok result){\n            #ok({balance = result.balance});\n          };\n        };\n      };\n      case _ {\n        errInvalidToken;\n      };\n    };\n  };\n// #endregion\n\n// #region Verify Invoice\n  public shared ({caller}) func verify_invoice (args : T.VerifyInvoiceArgs) : async T.VerifyInvoiceResult {\n    let invoice = invoices.get(args.id);\n    let canisterId = Principal.fromActor(Invoice);\n\n    switch invoice {\n      case null{\n        #err({\n          message = ?\"Invoice not found\";\n          kind = #NotFound;\n        });\n      };\n      case (?i) {\n        // Return if already verified\n        if (i.verifiedAtTime != null) {\n          return #ok(#AlreadyVerified {\n            invoice = i;\n          });\n        };\n        if (i.creator != caller) {\n          switch (i.permissions) {\n            case null {\n              return #err({\n                message = ?\"You do not have permission to verify this invoice\";\n                kind = #NotAuthorized;\n              });\n            };\n            case (?permissions) {\n              let hasPermission = Array.find<Principal>(\n                permissions.canVerify,\n                func (x : Principal) : Bool {\n                  return x == caller;\n                }\n              );\n              if (Option.isSome(hasPermission)) {\n                // May proceed\n              } else {\n                return #err({\n                  message = ?\"You do not have permission to verify this invoice\";\n                  kind = #NotAuthorized;\n                });\n              };\n            };\n          };\n        };\n\n        switch (i.token.symbol) {\n          case \"ICP\" {\n            let result : T.VerifyInvoiceResult = await ICP.verifyInvoice({\n              invoice = i;\n              caller;\n              canisterId;\n            });\n            switch result {\n              case (#ok value) {\n                switch (value) {\n                  case (#AlreadyVerified _) { };\n                  case (#Paid paidResult) {\n                    let replaced = invoices.replace(i.id, paidResult.invoice);\n                  };\n                };\n              };\n              case (#err _) {};\n            };\n            result;\n          };\n          case _ {\n            errInvalidToken;\n          };\n        };\n      };\n    };\n  };\n// #endregion\n\n// #region Transfer\n  public shared ({caller}) func transfer (args : T.TransferArgs) : async T.TransferResult {\n    let token = args.token;\n    let accountResult = U.accountIdentifierToBlob({\n      accountIdentifier = args.destination;\n      canisterId = ?Principal.fromActor(Invoice);\n    });\n    switch (accountResult) {\n      case (#err err) {\n        #err({\n          message = err.message;\n          kind = #InvalidDestination;\n        });\n      };\n      case (#ok destination) {\n        switch (token.symbol) {\n          case \"ICP\" {\n            let now = Nat64.fromIntWrap(Time.now());\n\n            let transferResult = await ICP.transfer({\n              memo = 0;\n              fee = {\n                e8s = 10000;\n              };\n              amount = {\n                // Total amount, minus the fee\n                e8s = Nat64.sub(Nat64.fromNat(args.amount), 10000);\n              };\n              from_subaccount = ?A.principalToSubaccount(caller);\n\n              to = destination;\n              created_at_time = null;\n            });\n            switch (transferResult) {\n              case (#ok result) {\n                #ok(result);\n              };\n              case (#err err) {\n                switch (err.kind) {\n                  case (#BadFee _) {\n                    #err({\n                      message = err.message;\n                      kind = #BadFee;\n                    });\n                  };\n                  case (#InsufficientFunds _) {\n                    #err({\n                      message = err.message;\n                      kind = #InsufficientFunds;\n                    });\n                  };\n                  case _ {\n                    #err({\n                      message = err.message;\n                      kind = #Other;\n                    });\n                  }\n                };\n              };\n            };\n          };\n          case _ {\n            errInvalidToken;\n          };\n        };\n      };\n    };\n  };\n// #endregion\n\n// #region get_account_identifier\n  /*\n    * Get Caller Identifier\n    * Allows a caller to the accountIdentifier for a given principal\n    * for a specific token.\n    */\n  public query func get_account_identifier (args : T.GetAccountIdentifierArgs) : async T.GetAccountIdentifierResult {\n    let token = args.token;\n    let principal = args.principal;\n    let canisterId = Principal.fromActor(Invoice);\n    switch (token.symbol) {\n      case \"ICP\" {\n        let subaccount = U.getDefaultAccount({principal; canisterId;});\n        let hexEncoded = Hex.encode(\n          Blob.toArray(subaccount)\n        );\n        let result : AccountIdentifier = #text(hexEncoded);\n        #ok({accountIdentifier = result});\n      };\n      case _ {\n        errInvalidToken;\n      };\n    };\n  };\n// #endregion\n\n// #region Utils\n  public func accountIdentifierToBlob (accountIdentifier : AccountIdentifier) : async T.AccountIdentifierToBlobResult {\n    U.accountIdentifierToBlob({\n      accountIdentifier;\n      canisterId = ?Principal.fromActor(Invoice);\n    });\n  };\n// #endregion\n\n// #region Upgrade Hooks\n  system func preupgrade() {\n    entries := Iter.toArray(invoices.entries());\n  };\n// #endregion\n}\n","invoice-canister/test/unit/Test.mo":"import A          \"../../src/invoice/Account\";\nimport Hex        \"../../src/invoice/Hex\";\nimport U          \"../../src/invoice/Utils\";\n\nimport Blob       \"mo:base/Blob\";\nimport Debug      \"mo:base/Debug\";\nimport Principal  \"mo:base/Principal\";\nimport Result     \"mo:base/Result\";\nimport Text       \"mo:base/Text\";\n\nimport ActorSpec \"./utils/ActorSpec\";\ntype Group = ActorSpec.Group;\n\nlet assertTrue = ActorSpec.assertTrue;\nlet describe = ActorSpec.describe;\nlet it = ActorSpec.it;\nlet skip = ActorSpec.skip;\nlet pending = ActorSpec.pending;\nlet run = ActorSpec.run;\n\nlet testPrincipal = Principal.fromText(\"rrkah-fqaaa-aaaaa-aaaaq-cai\");\nlet testCaller = Principal.fromText(\"ryjl3-tyaaa-aaaaa-aaaba-cai\");\nlet defaultSubaccount = A.defaultSubaccount();\nlet canisterId = ?testPrincipal;\n\nfunc defaultAccountBlob() : Blob {\n    let decoded = Hex.decode(\"082ecf2e3f647ac600f43f38a68342fba5b8e68b085f02592b77f39808a8d2b5\");\n    switch(decoded){\n      case(#err _) {\n        return Text.encodeUtf8(\"\");\n      };\n      case(#ok arr) {\n        return Blob.fromArray(arr);\n      };\n    }\n};\n\nfunc principalAccountBlob() : Blob {\n  let decoded = Hex.decode(\"333ee20adc61d719820ac133d10f010e531ed8496ffcc439145b3df1982552e7\");\n  switch (decoded) {\n    case (#err _) {\n      return Text.encodeUtf8(\"\");\n    };\n    case (#ok arr) {\n      return Blob.fromArray(arr);\n    };\n  }\n};\n\nlet success = run([\n  describe(\"ICP Tests\", [\n    describe(\"Account Identifiers Utilities\", [\n      it(\"should generate a valid account identifier\", do {\n        let account = A.accountIdentifier(testPrincipal, defaultSubaccount);\n        assertTrue(A.validateAccountIdentifier(account));\n      }),\n      it(\"should convert a principal to a subaccount\", do {\n        let subaccount = A.principalToSubaccount(testCaller);\n        // Subaccounts should have a length of 32\n        assertTrue(subaccount.size() == 32);\n      }),\n      it(\"should generate a valid default account for a caller\", do {\n        let subaccount = A.principalToSubaccount(testCaller);\n        let accountIdentifier = A.accountIdentifier(testPrincipal, subaccount);\n        assertTrue(A.validateAccountIdentifier(accountIdentifier));\n      }),\n      it(\"should convert a #text accountIdentifier to Text\", do {\n        let account = A.accountIdentifier(testPrincipal, defaultSubaccount);\n        let textResult = U.accountIdentifierToText({\n          accountIdentifier = #blob(account);\n          canisterId = null;\n        });\n        switch (textResult){\n          case (#err _) {\n            assertTrue(false);\n          };\n          case (#ok text) {\n            assertTrue(text == \"082ecf2e3f647ac600f43f38a68342fba5b8e68b085f02592b77f39808a8d2b5\");\n          };\n        }\n      }),\n      it(\"should convert a #principal accountIdentifier to Text\", do {\n        let id = #principal(testCaller);\n        let textResult = U.accountIdentifierToText({\n          accountIdentifier = id;\n          canisterId;\n        });\n        switch(textResult){\n          case(#err _) {\n            assertTrue(false);\n          };\n          case(#ok text) {\n            let principalAccount = \"333ee20adc61d719820ac133d10f010e531ed8496ffcc439145b3df1982552e7\";\n            assertTrue(text == principalAccount);\n          };\n        };\n      }),\n      it(\"should convert a #blob accountIdentifier to Text\", do {\n        let defaultBlob = defaultAccountBlob();\n        let textResult = U.accountIdentifierToText({\n          accountIdentifier = #blob(defaultBlob);\n          canisterId = null;\n        });\n        switch (textResult){\n          case (#err _) {\n            assertTrue(false);\n          };\n          case (#ok text) {\n            assertTrue(text == \"082ecf2e3f647ac600f43f38a68342fba5b8e68b085f02592b77f39808a8d2b5\");\n          };\n        }\n      }),\n      it(\"should convert a #text accountIdentifier to Blob\", do {\n        let id = #text(\"082ecf2e3f647ac600f43f38a68342fba5b8e68b085f02592b77f39808a8d2b5\");\n        let blobResult = U.accountIdentifierToBlob({\n          accountIdentifier = id;\n          canisterId = null;\n        });\n        switch(blobResult){\n          case(#err _) {\n            assertTrue(false);\n          };\n          case(#ok blob) {\n            let defaultBlob = defaultAccountBlob();\n            assertTrue(blob == defaultBlob);\n          };\n        };\n      }),\n      it(\"should convert a #principal accountIdentifier to Blob\", do {\n        // This should return an accountIdentifier with the canister as a principal and the passed principal as the subaccount\n        let id = #principal(testCaller);\n        let blobResult = U.accountIdentifierToBlob({\n          accountIdentifier = id;\n          canisterId;\n        });\n        switch(blobResult){\n          case(#err _) {\n            assertTrue(false);\n          };\n          case(#ok blob) {\n            let principalAccount = principalAccountBlob();\n            assertTrue(blob == principalAccount);\n          };\n        };\n      }),\n      it(\"should convert a #blob accountIdentifier to Blob\", do {\n        let defaultBlob = defaultAccountBlob();\n        let id = #blob(defaultBlob);\n        let blobResult = U.accountIdentifierToBlob({\n          accountIdentifier = id;\n          canisterId = null;\n        });\n        switch(blobResult){\n          case(#err _) {\n            assertTrue(false);\n          };\n          case(#ok blob) {\n            let defaultBlob = defaultAccountBlob();\n            assertTrue(blob == defaultBlob);\n          };\n        }\n      }),\n      it(\"should reject an invalid account identifier\", do {\n        let invalidBlob = Text.encodeUtf8(\"not valid\");\n        let id = #blob(invalidBlob);\n        let result = U.accountIdentifierToBlob({\n          accountIdentifier = id;\n          canisterId = null;\n        });\n        switch(result){\n          case(#err _) {\n            assertTrue(true);\n          };\n          case(#ok _) {\n            assertTrue(false);\n          };\n        };\n      }),\n    ]),\n    describe(\"Invoice Subaccount Creation\", [\n      it(\"should generate a valid invoice ID\", do {\n        let subaccount = U.generateInvoiceSubaccount({\n          caller = testCaller;\n          id = 0;\n        });\n        \n        assertTrue(A.validateAccountIdentifier(subaccount));\n      }),\n    ])\n  ]),\n]);\n\nif(success == false){\n  Debug.trap(\"Tests failed\");\n}\n","invoice-canister/test/unit/utils/ActorSpec.mo":"import Debug \"mo:base/Debug\";\nimport Array \"mo:base/Array\";\nimport Iter \"mo:base/Iter\";\nimport Int \"mo:base/Int\";\nimport Nat \"mo:base/Nat\";\nimport Text \"mo:base/Text\";\n\nmodule {\n  public type Group = {\n    name : Text;\n    groups : [Group];\n    status : Status;\n  };\n\n\n  type Status = {\n    failed : Nat;\n    passed : Nat;\n    pending : Nat;\n    skipped : Nat;\n  };\n\n  func eqStatus(x : Status, y : Status) : Bool {\n    x.failed == y.failed and x.passed == y.passed and x.pending == y.pending and x.skipped == y.skipped;\n  };\n\n  let emptyStatus : Status = {\n    failed = 0;\n    passed = 0;\n    pending = 0;\n    skipped = 0;\n  };\n\n  func appendStatus(x : Status, y : Status) : Status {\n    {\n      failed = x.failed + y.failed;\n      passed = x.passed + y.passed;\n      pending = x.pending + y.pending;\n      skipped = x.skipped + y.skipped;\n    };\n  };\n\n  func printStatus(status : Status) : Text {\n    \"Failed: \" # Int.toText(status.failed) # \", Passed: \" # Int.toText(status.passed) # \", Pending: \" # Int.toText(status.pending) # \", Skipped: \" # Int.toText(status.skipped);\n  };\n\n\n  public func run(groups_ : [Group]) : Bool {\n    let (groups, status) = getGroups(groups_);\n    printGroups(groups, \"\");\n    Debug.print(\"\\n\");\n    Debug.print(printStatus(status));\n    Debug.print(\"\\n\");\n    status.failed == 0;\n  };\n\n  func getGroups(groups_ : [Group]) : ([Group], Status) {\n    let groups = Array.thaw<Group>(groups_);\n    var status = emptyStatus;\n    for (index in groups_.keys()) {\n      let group = groups[index];\n      let (newGroups, newGroupsStatus) = getGroups(group.groups);\n      let newStatus = appendStatus(group.status, newGroupsStatus);\n      status := appendStatus(status, newStatus);\n      let newGroup = {\n        name = group.name;\n        groups = newGroups;\n        status = newStatus;\n      };\n      groups[index] := newGroup;\n    };\n    (Array.freeze<Group>(groups), status);\n  };\n\n  func printGroups(groups_ : [Group], indent : Text) {\n    for (group in groups_.vals()) {\n      let isDescribe = Iter.size(Array.keys(group.groups)) > 0;\n      let newline = if isDescribe \"\\n\" else \"\";\n      let status = group.status;\n      let statusText = if (isDescribe) {\n        \": \" # printStatus(status);\n      } else {\n        let failed = status.failed;\n        let passed = status.passed;\n        let pending = status.pending;\n        let skipped = status.skipped;\n        switch(failed, passed, pending, skipped) {\n          case (0, 0, 0, 0) { \"\"; };\n          case (1, 0, 0, 0) { \": Failed\"; };\n          case (0, 1, 0, 0) { \": Passed\"; };\n          case (0, 0, 1, 0) { \": Pending\"; };\n          case (0, 0, 0, 1) { \": Skipped\"; };\n          case (_, _, _, _) { \":\" # printStatus(status); };\n        };\n      };\n      Debug.print(newline # indent # group.name # statusText # \"\\n\");\n      printGroups(group.groups, indent # \"  \");\n    };\n  };\n\n\n  public func describe(name_ : Text, groups_ : [Group]) : Group {\n    {\n      name = name_;\n      groups = groups_;\n      status = emptyStatus;\n    };\n  };\n\n  public func it(name_ : Text, passed_ : Bool) : Group {\n    {\n      name = name_;\n      groups = [];\n      status = {\n        failed = if passed_ 0 else 1;\n        passed = if passed_ 1 else 0;\n        pending = 0;\n        skipped = 0;\n      };\n    };\n  };\n\n  public let test = it;\n\n  public func skip(name_ : Text, passed_ : Bool) : Group {\n    {\n      name = name_;\n      groups = [];\n      status = {\n        failed = 0;\n        passed = 0;\n        pending = 0;\n        skipped = 1;\n      };\n    };\n  };\n\n  public func pending(name_ : Text) : Group {\n    {\n      name = name_;\n      groups = [];\n      status = {\n        failed = 0;\n        passed = 0;\n        pending = 1;\n        skipped = 0;\n      };\n    };\n  };\n\n  public func assertTrue(x : Bool) : Bool {\n    x == true;\n  };\n\n  public func assertFalse(x : Bool) : Bool {\n    x == false;\n  };\n\n  public func assertAllTrue(xs : [Bool]) : Bool {\n    var allTrue = true;\n    for (val in xs.vals()) {\n      if (val == false) {\n        return false;\n      };\n      allTrue := allTrue and val;\n    };\n    allTrue;\n  };\n}\n","ledger-transfer/src/ledger_transfer/Account.mo":"import Array     \"mo:base/Array\";\nimport Blob      \"mo:base/Blob\";\nimport Nat8      \"mo:base/Nat8\";\nimport Nat32     \"mo:base/Nat32\";\nimport Principal \"mo:base/Principal\";\nimport Text      \"mo:base/Text\";\nimport CRC32     \"./CRC32\";\nimport SHA224    \"./SHA224\";\n\nmodule {\n  // 32-byte array.\n  public type AccountIdentifier = Blob;\n  // 32-byte array.\n  public type Subaccount = Blob;\n\n  func beBytes(n: Nat32) : [Nat8] {\n    func byte(n: Nat32) : Nat8 {\n      Nat8.fromNat(Nat32.toNat(n & 0xff))\n    };\n    [byte(n >> 24), byte(n >> 16), byte(n >> 8), byte(n)]\n  };\n\n  public func defaultSubaccount() : Subaccount {\n    Blob.fromArrayMut(Array.init(32, 0 : Nat8))\n  };\n\n  public func accountIdentifier(principal: Principal, subaccount: Subaccount) : AccountIdentifier {\n    let hash = SHA224.Digest();\n    hash.write([0x0A]);\n    hash.write(Blob.toArray(Text.encodeUtf8(\"account-id\")));\n    hash.write(Blob.toArray(Principal.toBlob(principal)));\n    hash.write(Blob.toArray(subaccount));\n    let hashSum = hash.sum();\n    let crc32Bytes = beBytes(CRC32.ofArray(hashSum));\n    Blob.fromArray(Array.append(crc32Bytes, hashSum))\n  };\n\n  public func validateAccountIdentifier(accountIdentifier : AccountIdentifier) : Bool {\n    if (accountIdentifier.size() != 32) {\n      return false;\n    };\n    let a = Blob.toArray(accountIdentifier);\n    let accIdPart    = Array.tabulate(28, func(i: Nat): Nat8 { a[i + 4] });\n    let checksumPart = Array.tabulate(4,  func(i: Nat): Nat8 { a[i] });\n    let crc32 = CRC32.ofArray(accIdPart);\n    Array.equal(beBytes(crc32), checksumPart, Nat8.equal)\n  };\n}\n","ledger-transfer/src/ledger_transfer/CRC32.mo":"import Blob  \"mo:base/Blob\";\nimport Nat8  \"mo:base/Nat8\";\nimport Nat32 \"mo:base/Nat32\";\n\nmodule {\n\n  let crc32Table : [Nat32] =\n   [ 0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f\n   , 0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988\n   , 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91, 0x1db71064, 0x6ab020f2\n   , 0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7\n   , 0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9\n   , 0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172\n   , 0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b, 0x35b5a8fa, 0x42b2986c\n   , 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59\n   , 0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423\n   , 0xcfba9599, 0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924\n   , 0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190, 0x01db7106\n   , 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433\n   , 0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d\n   , 0x91646c97, 0xe6635c01, 0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e\n   , 0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950\n   , 0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65\n   , 0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7\n   , 0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0\n   , 0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa\n   , 0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f\n   , 0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81\n   , 0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a\n   , 0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683, 0xe3630b12, 0x94643b84\n   , 0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1\n   , 0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb\n   , 0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc\n   , 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5, 0xd6d6a3e8, 0xa1d1937e\n   , 0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b\n   , 0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55\n   , 0x316e8eef, 0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236\n   , 0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe, 0xb2bd0b28\n   , 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d\n   , 0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f\n   , 0x72076785, 0x05005713, 0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38\n   , 0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242\n   , 0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777\n   , 0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69\n   , 0x616bffd3, 0x166ccf45, 0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2\n   , 0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc\n   , 0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9\n   , 0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693\n   , 0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94\n   , 0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d\n   ];\n\n  let seed : Nat32 = 0xffffffff;\n\n  public func ofArray(arr : [Nat8]) : Nat32 {\n    ofBlob(Blob.fromArray(arr))\n  };\n\n  // Returns CRC-32 checksum of a byte array encoded as big-endian.\n  public func ofBlob(blob: Blob) : Nat32 {\n    // See https://en.wikipedia.org/wiki/Cyclic_redundancy_check#CRC-32_algorithm\n    var crc = seed;\n    for (b in blob.vals()) {\n      crc := crc32Table[Nat32.toNat(crc ^ Nat32.fromNat(Nat8.toNat(b)) & 0xff)] ^ (crc >> 8);\n    };\n    crc ^ seed\n  };\n}\n","ledger-transfer/src/ledger_transfer/SHA224.mo":"import Array \"mo:base/Array\";\nimport Iter \"mo:base/Iter\";\nimport Nat \"mo:base/Nat\";\nimport Nat8 \"mo:base/Nat8\";\nimport Nat32 \"mo:base/Nat32\";\nimport Nat64 \"mo:base/Nat64\";\n\nmodule {\n\n  private let K : [Nat32] = [\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,\n    0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,\n    0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,\n    0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,\n    0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,\n    0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,\n    0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,\n    0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,\n    0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2,\n  ];\n\n  private let S : [Nat32] = [\n    0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,\n    0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4,\n  ];\n\n  // Calculate a SHA224 hash.\n  public func sha224(data : [Nat8]) : [Nat8] {\n    let digest = Digest();\n    digest.write(data);\n    return digest.sum();\n  };\n\n  public class Digest() {\n\n    private let s = Array.thaw<Nat32>(S);\n\n    private let x = Array.init<Nat8>(64, 0);\n\n    private var nx = 0;\n\n    private var len : Nat64 = 0;\n\n    public func reset() {\n      for (i in Iter.range(0, 7)) {\n        s[i] := S[i];\n      };\n      nx := 0;\n      len := 0;\n    };\n\n    public func write(data : [Nat8]) {\n      var p = data;\n      len +%= Nat64.fromIntWrap(p.size());\n      if (nx > 0) {\n        let n = Nat.min(p.size(), 64 - nx);\n        for (i in Iter.range(0, n - 1)) {\n          x[nx + i] := p[i];\n        };\n        nx += n;\n        if (nx == 64) {\n          let buf = Array.freeze<Nat8>(x);\n          block(buf);\n          nx := 0;\n        };\n        p := Array.tabulate<Nat8>(p.size() - n, func (i) {\n          return p[n + i];\n        });\n      };\n      if (p.size() >= 64) {\n        let n = Nat64.toNat(Nat64.fromIntWrap(p.size()) & (^ 63));\n        let buf = Array.tabulate<Nat8>(n, func (i) {\n          return p[i];\n        });\n        block(buf);\n        p := Array.tabulate<Nat8>(p.size() - n, func (i) {\n          return p[n + i];\n        });\n      };\n      if (p.size() > 0) {\n        for (i in Iter.range(0, p.size() - 1)) {\n          x[i] := p[i];\n        };\n        nx := p.size();\n      };\n    };\n\n    public func sum() : [Nat8] {\n      var m = 0;\n      var n = len;\n      var t = Nat64.toNat(n) % 64;\n      var buf : [var Nat8] = [var];\n      if (56 > t) {\n        m := 56 - t;\n      } else {\n        m := 120 - t;\n      };\n      n := n << 3;\n      buf := Array.init<Nat8>(m, 0);\n      if (m > 0) {\n        buf[0] := 0x80;\n      };\n      write(Array.freeze<Nat8>(buf));\n      buf := Array.init<Nat8>(8, 0);\n      for (i in Iter.range(0, 7)) {\n        let j : Nat64 = 56 -% 8 *% Nat64.fromIntWrap(i);\n        buf[i] := Nat8.fromIntWrap(Nat64.toNat(n >> j));\n      };\n      write(Array.freeze<Nat8>(buf));\n      let hash = Array.init<Nat8>(28, 0);\n      for (i in Iter.range(0, 6)) {\n        for (j in Iter.range(0, 3)) {\n          let k : Nat32 = 24 -% 8 *% Nat32.fromIntWrap(j);\n          hash[4 * i + j] := Nat8.fromIntWrap(Nat32.toNat(s[i] >> k));\n        };\n      };\n      return Array.freeze<Nat8>(hash);\n    };\n\n    private func block(data : [Nat8]) {\n      var p = data;\n      var w = Array.init<Nat32>(64, 0);\n      while (p.size() >= 64) {\n        var j = 0;\n        for (i in Iter.range(0, 15)) {\n          j := i * 4;\n          w[i] :=\n            Nat32.fromIntWrap(Nat8.toNat(p[j + 0])) << 24 |\n            Nat32.fromIntWrap(Nat8.toNat(p[j + 1])) << 16 |\n            Nat32.fromIntWrap(Nat8.toNat(p[j + 2])) << 08 |\n            Nat32.fromIntWrap(Nat8.toNat(p[j + 3])) << 00;\n        };\n        var v1 : Nat32 = 0;\n        var v2 : Nat32 = 0;\n        var t1 : Nat32 = 0;\n        var t2 : Nat32 = 0;\n        for (i in Iter.range(16, 63)) {\n          v1 := w[i - 02];\n          v2 := w[i - 15];\n          t1 := rot(v1, 17) ^ rot(v1, 19) ^ (v1 >> 10);\n          t2 := rot(v2, 07) ^ rot(v2, 18) ^ (v2 >> 03);\n          w[i] :=\n              t1 +% w[i - 07] +%\n              t2 +% w[i - 16];\n        };\n        var a = s[0];\n        var b = s[1];\n        var c = s[2];\n        var d = s[3];\n        var e = s[4];\n        var f = s[5];\n        var g = s[6];\n        var h = s[7];\n        for (i in Iter.range(0, 63)) {\n          t1 := rot(e, 06) ^ rot(e, 11) ^ rot(e, 25);\n          t1 +%= (e & f) ^ (^ e & g) +% h +% K[i] +% w[i];\n          t2 := rot(a, 02) ^ rot(a, 13) ^ rot(a, 22);\n          t2 +%= (a & b) ^ (a & c) ^ (b & c);\n          h := g;\n          g := f;\n          f := e;\n          e := d +% t1;\n          d := c;\n          c := b;\n          b := a;\n          a := t1 +% t2;\n        };\n        s[0] +%= a;\n        s[1] +%= b;\n        s[2] +%= c;\n        s[3] +%= d;\n        s[4] +%= e;\n        s[5] +%= f;\n        s[6] +%= g;\n        s[7] +%= h;\n        p := Array.tabulate<Nat8>(p.size() - 64, func (i) {\n          return p[i + 64];\n        });\n      };\n    };\n  };\n\n  private let rot : (Nat32, Nat32) -> Nat32 = Nat32.bitrotRight;\n};\n","ledger-transfer/src/ledger_transfer/main.mo":"import Ledger    \"canister:ledger\";\n\nimport Debug     \"mo:base/Debug\";\nimport Error     \"mo:base/Error\";\nimport Int       \"mo:base/Int\";\nimport HashMap   \"mo:base/HashMap\";\nimport List      \"mo:base/List\";\nimport Nat64     \"mo:base/Nat64\";\nimport Principal \"mo:base/Principal\";\nimport Time      \"mo:base/Time\";\n\nimport Account   \"./Account\";\n\nactor Self {\n  public type Post = {\n    text : Text;\n    created_at : Int;\n  };\n\n  public type Posts = List.List<Post>;\n\n  // Posts indexed by the author.\n  // Newest posts are at the front of the post list.\n  var posts : HashMap.HashMap<Principal, Posts> = HashMap.HashMap(10, Principal.equal, Principal.hash);\n\n  // Records a new message posted by the specified author.\n  func addPost(author : Principal, text : Text) {\n    let post = { text = text; created_at = Time.now(); };\n    \n    let newPosts = switch (posts.get(author)) {\n      case null { List.make(post) };\n      case (?oldPosts) { List.push(post, oldPosts) };\n    };\n\n    posts.put(author, newPosts);\n  };\n\n  // Returns the default account identifier of this canister.\n  func myAccountId() : Account.AccountIdentifier {\n    Account.accountIdentifier(Principal.fromActor(Self), Account.defaultSubaccount())\n  };\n\n  // Adds a new post.\n  public shared ({ caller }) func post(lit : Text) : async () {\n    addPost(caller, lit);\n  };\n\n  // Returns messages posted by the caller.\n  public shared query ({ caller }) func myPosts() : async Posts {\n    switch (posts.get(caller)) {\n      case null { null };\n      case (?p) { p };\n    }\n  };\n\n  // Returns canister's default account identifier as a blob.\n  public query func canisterAccount() : async Account.AccountIdentifier {\n    myAccountId()\n  };\n\n  // Returns current balance on the default account of this canister.\n  public func canisterBalance() : async Ledger.Tokens {\n    await Ledger.account_balance({ account = myAccountId() })\n  };\n\n  // Rewards the most prolific author of the last week with 1 token.\n  //\n  // Returns the principal of the winner, if there is one.\n  public func distributeRewards() : async ?Principal {\n    let weekNanos = 7 * 24 * 3600 * 1_000_000_000;\n    let now = Time.now();\n    let threshold = if (now < weekNanos) { 0 } else { now - weekNanos };\n\n    var maxPosts = 0;\n    var mostProlificAuthor : ?Principal = null;\n\n    // Go over all the posts and find the most prolific author.\n    for ((author, posts) in posts.entries()) {\n      let numFreshPosts = List.foldLeft(posts, 0 : Nat, func (acc : Nat, post : Post) : Nat {\n        if (post.created_at >= threshold) { acc + 1 } else { acc }\n      });\n      if (numFreshPosts > maxPosts) {\n        maxPosts := numFreshPosts;\n        mostProlificAuthor := ?author;\n      };\n    };\n    \n    switch (mostProlificAuthor) {\n      case null {};\n      case (?principal) {\n        // If there is a winner, transfer 1 Token to the winner.\n        let res = await Ledger.transfer({\n          memo = Nat64.fromNat(maxPosts);\n          from_subaccount = null;\n          to = Account.accountIdentifier(principal, Account.defaultSubaccount());\n          amount = { e8s = 100_000_000 };\n          fee = { e8s = 10_000 };\n          created_at_time = ?{ timestamp_nanos = Nat64.fromNat(Int.abs(now)) };\n        });\n        switch (res) {\n          case (#Ok(blockIndex)) {\n            Debug.print(\"Paid reward to \" # debug_show principal # \" in block \" # debug_show blockIndex);\n          };\n          case (#Err(#InsufficientFunds { balance })) {\n            throw Error.reject(\"Top me up! The balance is only \" # debug_show balance # \" e8s\");\n          };\n          case (#Err(other)) {\n            throw Error.reject(\"Unexpected error: \" # debug_show other);\n          };\n        };\n      };\n    };\n\n    mostProlificAuthor\n  };\n};\n","life/src/life/Grid.mo":"import State \"State\";\n\nmodule {\n\n  public class Grid(state : State.State) {\n\n    let grid = state;\n\n    let n = grid.size();\n\n    public func size() : Nat { n };\n\n    public func get(i : Nat, j : Nat) : State.Cell { grid[i][j] };\n\n    public func set(i : Nat, j : Nat, v : State.Cell) { grid[i][j] := v };\n\n    func count(i : Nat, j : Nat) : Nat { if (grid[i][j]) 1 else 0 };\n\n    func pred(i : Nat) : Nat { (n + i - 1) % n };\n    func succ(i : Nat) : Nat { (i + 1) % n };\n\n    func living(i : Nat, j : Nat) : Nat {\n      count(pred i, pred j) + count(pred i, j) + count(pred i, succ j) +\n      count(     i, pred j)                    + count(     i, succ j) +\n      count(succ i, pred j) + count(succ i, j) + count(succ i, succ j)\n    };\n\n    func nextCell(i : Nat, j : Nat) : State.Cell {\n      let l : Nat = living(i, j);\n      if (get(i, j))\n        l == 2 or l == 3\n      else\n        l == 3;\n    };\n\n    public func next(dst : Grid) {\n      for (i in grid.keys()) {\n        for (j in grid[i].keys()) {\n          dst.set(i, j, nextCell(i, j));\n        };\n      };\n    };\n\n    public func toText() : Text {\n      var t = \"\";\n      for (i in grid.keys()) {\n        for (j in grid[i].keys()) {\n          t #= if (get(i, j)) \"0\" else \" \";\n        };\n        if (i + 1 < n) {\n\t  t #= \"\\n\";\n\t}\n      };\n      t\n    };\n  };\n}\n","life/src/life/Random.mo":"import Nat = \"mo:base/Nat\";\nimport Nat32 = \"mo:base/Nat32\";\n\nmodule {\n  public func new() : { next : () -> Nat32 } =\n    object {\n      let modulus = 0x7fffffff;\n      var state : Nat32 = 1;\n\n      public func next() : Nat32\n      {\n        state := Nat32.fromNat(Nat32.toNat(state) * 48271 % modulus);\n        state;\n      };\n\n    };\n};\n\n","life/src/life/State.mo":"import Array \"mo:base/Array\";\n\nmodule {\n\n  public type Cell = Bool;\n  public type State = [[var Cell]];\n\n  public func new(size : Nat, f : (i : Nat, j : Nat) -> Cell) : State {\n    Array.tabulate(size, func (i : Nat) : [var Cell] {\n      let a : [var Cell] = Array.init(size, false);\n      for (j in a.keys()) {\n        a[j] := f(i,j);\n      };\n      a\n    });\n  }\n}\n","life/src/life/main.mo":"// local imports\nimport Random = \"Random\";\nimport State = \"State\";\nimport Grid = \"Grid\";\n\nactor Life {\n\n  let state = do {\n    let rand = Random.new();\n    State.new(64, func (i, j) { rand.next() % 2 == 1 });\n  };\n\n  var cur = Grid.Grid(state);\n\n  var nxt = Grid.Grid(State.new(cur.size(), func (i, j) { false; }));\n\n  public func next() : async Text {\n    cur.next(nxt);\n    let temp = cur;\n    cur := nxt;\n    nxt := temp;\n    cur.toText();\n  };\n\n  public query func current() : async Text {\n    cur.toText()\n  };\n\n};\n\n","life/versions/v1/life/Grid.mo":"import State \"State\";\n\nmodule {\n\n  public class Grid((#v1 state) : State.State) {\n\n    let grid = state;\n\n    let n = grid.size();\n\n    public func size() : Nat { n };\n\n    public func get(i : Nat, j : Nat) : State.Cell { grid[i][j] };\n\n    public func set(i : Nat, j : Nat, v : State.Cell) { grid[i][j] := v };\n\n    func count(i : Nat, j : Nat) : Nat { if (grid[i][j]) 1 else 0 };\n\n    func pred(i : Nat) : Nat { (n + i - 1) % n };\n    func succ(i : Nat) : Nat { (i + 1) % n };\n\n    func living(i : Nat, j : Nat) : Nat {\n      count(pred i, pred j) + count(pred i, j) + count(pred i, succ j) +\n      count(     i, pred j)                    + count(     i, succ j) +\n      count(succ i, pred j) + count(succ i, j) + count(succ i, succ j)\n    };\n\n    func nextCell(i : Nat, j : Nat) : State.Cell {\n      let l : Nat = living(i, j);\n      if (get(i, j))\n        l == 2 or l == 3\n      else\n        l == 3;\n    };\n\n    public func next(dst : Grid) {\n      for (i in grid.keys()) {\n        for (j in grid[i].keys()) {\n          dst.set(i, j, nextCell(i, j));\n        };\n      };\n    };\n\n    public func toText() : Text {\n      var t = \"\";\n      for (i in grid.keys()) {\n        for (j in grid[i].keys()) {\n          t #= if (get(i, j)) \"1\" else \" \";\n        };\n        if (i + 1 < n) {\n\t  t #= \"\\n\";\n\t}\n      };\n      t\n    };\n\n    public func toState() :  State.State {\n      #v1 grid\n    };\n\n };\n\n}\n","life/versions/v1/life/Random.mo":"import Nat = \"mo:base/Nat\";\nimport Nat32 = \"mo:base/Nat32\";\n\nmodule {\n  public func new() : { next : () -> Nat32 } =\n    object {\n      let modulus = 0x7fffffff;\n      var state : Nat32 = 1;\n\n      public func next() : Nat32\n      {\n        state := Nat32.fromNat(Nat32.toNat(state) * 48271 % modulus);\n        state;\n      };\n\n    };\n};\n\n","life/versions/v1/life/State.mo":"import Array \"mo:base/Array\";\n\nmodule {\n\n  public type Cell = Bool;\n  public type State = {\n    #v1 : [[var Cell]]\n  };\n\n  public func new(size : Nat, f : (i : Nat, j : Nat) -> Cell) : State {\n   #v1 (\n     Array.tabulate(size, func (i : Nat) : [var Cell] {\n        let a : [var Cell] = Array.init(size, false);\n        for (j in a.keys()) {\n          a[j] := f(i,j);\n        };\n        a\n      }))\n  }\n}\n","life/versions/v1/life/main.mo":"import Debug = \"mo:base/Debug\";\n// local imports\nimport Random = \"Random\";\nimport State = \"State\";\nimport Grid = \"Grid\";\n\nactor Life {\n\n  stable var state =\n    do {\n      let rand = Random.new();\n      State.new(64, func (i, j) { rand.next() % 2 == 1 });\n    };\n\n  system func preupgrade() {\n    state := cur.toState();\n  };\n\n  system func postupgrade() {\n    Debug.print(\"upgraded to v1!\");\n  };\n\n  public query func stableState() : async Text {\n    debug_show(cur.toState());\n  };\n\n  var cur = Grid.Grid(state);\n\n  var nxt = Grid.Grid(State.new(cur.size(), func (i, j) { false; }));\n\n  public func next() : async Text {\n    cur.next(nxt);\n    let temp = cur;\n    cur := nxt;\n    nxt := temp;\n    cur.toText();\n  };\n\n  public query func current() : async Text {\n    cur.toText()\n  };\n\n};\n","life/versions/v2/life/Grid.mo":"import Iter \"mo:base/Iter\";\nimport State \"State\";\n\nmodule {\n\n  public class Grid(state : State.State) {\n\n    let (#v2 ({size = n; bits : [var Nat64]})) =\n      switch state {\n        case (#v1 css) {\n          State.new(css.size(), func (i, j) { css[i][j] })\n        };\n        case (#v2 state) { #v2 state };\n      };\n\n    public func size() : Nat { n };\n\n    public func get(i : Nat, j : Nat) : State.Cell {\n      State.readBit(bits, i * n + j);\n    };\n\n    public func set(i : Nat, j : Nat, v : State.Cell) {\n      State.writeBit(bits, i * n + j, v);\n    };\n\n    func pred(i : Nat) : Nat { (n + i - 1) % n };\n\n    func succ(i : Nat) : Nat { (i + 1) % n };\n\n    func count(i : Nat, j : Nat) : Nat { if (get(i, j)) 1 else 0 };\n\n    func living(i : Nat, j : Nat) : Nat {\n      count(pred i, pred j) + count(pred i, j) + count(pred i, succ j) +\n      count(     i, pred j)                    + count(     i, succ j) +\n      count(succ i, pred j) + count(succ i, j) + count(succ i, succ j)\n    };\n\n    func nextCell(i : Nat, j : Nat) : State.Cell {\n      let l : Nat = living(i, j);\n      if (get(i, j))\n        l == 2 or l == 3\n      else\n        l == 3;\n    };\n\n    public func next(dst : Grid) {\n      for (i in Iter.range(0, n - 1)) {\n        for (j in Iter.range(0, n - 1)) {\n          dst.set(i, j, nextCell(i, j));\n        };\n      };\n    };\n\n    public func toText() : Text {\n      var t = \"\";\n      for (i in Iter.range(0, n - 1)) {\n        for (j in Iter.range(0, n - 1)) {\n          t #= if (get(i, j)) \"2\" else \" \";\n        };\n        if (i + 1 < n) {\n\t  t #= \"\\n\";\n\t}\n      };\n      t\n    };\n\n    public func toState() : State.State {\n      #v2 {size = n; bits = bits}\n    };\n\n  };\n}\n","life/versions/v2/life/Random.mo":"import Nat = \"mo:base/Nat\";\nimport Nat32 = \"mo:base/Nat32\";\n\nmodule {\n  public func new() : { next : () -> Nat32 } =\n    object {\n      let modulus = 0x7fffffff;\n      var state : Nat32 = 1;\n\n      public func next() : Nat32\n      {\n        state := Nat32.fromNat(Nat32.toNat(state) * 48271 % modulus);\n        state;\n      };\n\n    };\n};\n\n","life/versions/v2/life/State.mo":"import Array \"mo:base/Array\";\nimport Iter \"mo:base/Iter\";\nimport Nat64 \"mo:base/Nat64\";\n\nmodule {\n\n  public type Cell = Bool;\n\n  public type State = {\n    #v1 : [[var Cell]];\n    #v2 : {size : Nat; bits : [var Nat64]}\n  };\n\n  public func readBit(bits : [var Nat64], index : Nat) : Bool {\n    let bit = Nat64.fromNat(index);\n    let mask : Nat64 = 1 << (bit % 64);\n    (bits[Nat64.toNat(bit >> 6)] & mask) == mask\n  };\n\n  public func writeBit(bits : [var Nat64], index : Nat, v : Bool) {\n    let bit = Nat64.fromNat(index);\n    let mask : Nat64 = 1 << (bit % 64);\n    let i = Nat64.toNat(bit >> 6);\n    if v {\n      bits[i] |= mask\n    }\n    else {\n      bits[i] &= ^mask;\n    }\n  };\n\n  public func new(size : Nat, f : (i : Nat, j : Nat) -> Cell) :\n    {#v2 : {size : Nat; bits : [var Nat64]}} {\n    let words = (size * size) / 64 + 1;\n    let bits = Array.init<Nat64>(words, 0);\n    for (i in Iter.range(0, size - 1)) {\n      for (j in Iter.range(0, size - 1)) {\n        writeBit(bits, i * size + j, f(i, j));\n      }\n    };\n    #v2 {size = size; bits = bits}\n  }\n}\n","life/versions/v2/life/main.mo":"import Debug = \"mo:base/Debug\";\n// local imports\nimport Random = \"Random\";\nimport State = \"State\";\nimport Grid = \"Grid\";\n\nactor Life {\n\n  stable var state : State.State =\n    do {\n      let rand = Random.new();\n      State.new(64, func (i, j) { rand.next() % 2 == 1 });\n    };\n\n  system func preupgrade() {\n    state := cur.toState();\n  };\n\n  system func postupgrade() {\n    Debug.print(\"upgraded to v2!\");\n  };\n\n  public query func stableState() : async Text {\n    debug_show(cur.toState());\n  };\n\n  var cur = Grid.Grid(state);\n\n  var nxt = Grid.Grid(State.new(cur.size(), func (i, j) { false; }));\n\n  public func next() : async Text {\n    cur.next(nxt);\n    let temp = cur;\n    cur := nxt;\n    nxt := temp;\n    cur.toText();\n  };\n\n  public query func current() : async Text {\n    cur.toText()\n  };\n\n};\n","minimal-counter-dapp/src/minimal_dapp/main.mo":"actor {\n\n  var counter : Nat = 0;\n\n  public func count() : async Nat {\n    counter += 1;\n    return counter;\n  };\n\n  public query func getCount() : async Nat {\n    return counter;\n  };\n\n  public func reset() : async Nat {\n    counter := 0;\n    return counter;\n  };\n};\n","persistent-storage/src/persistent_storage/main.mo":"actor {\n\n  stable var counter : Nat = 0;\n\n  public func increment() : async Nat {\n    counter += 1;\n    return counter;\n  };\n\n  public query func get() : async Nat {\n    return counter;\n  };\n\n  public func reset() : async Nat {\n    counter := 0;\n    return counter;\n  };\n};\n","phone-book/src/phone-book/Main.mo":"import Map \"mo:base/HashMap\";\nimport Text \"mo:base/Text\";\n\nactor {\n\n  type Name = Text;\n  type Phone = Text;\n\n  type Entry = {\n    desc: Text;\n    phone: Phone;\n  };\n\n  let phonebook = Map.HashMap<Name, Entry>(0, Text.equal, Text.hash);\n\n  public func insert(name : Name, entry : Entry): async () {\n    phonebook.put(name, entry);\n  };\n\n  public query func lookup(name : Name) : async ?Entry {\n    phonebook.get(name)\n  };\n};\n","pub-sub/src/pub/Main.mo":"// Publisher\nimport List \"mo:base/List\";\n\nactor Publisher {\n\n  type Counter = {\n    topic : Text;\n    value : Nat;\n  };\n\n  type Subscriber = {\n    topic : Text;\n    callback : shared Counter -> ();\n  };\n\n  stable var subscribers = List.nil<Subscriber>();\n\n  public func subscribe(subscriber : Subscriber) {\n    subscribers := List.push(subscriber, subscribers);\n  };\n\n  public func publish(counter : Counter) {\n    for (subscriber in List.toArray(subscribers).vals()) {\n      if (subscriber.topic == counter.topic) {\n        subscriber.callback(counter);\n      };\n    };\n  };\n}\n","pub-sub/src/sub/Main.mo":"// Subscriber\n\nimport Publisher \"canister:pub\";\n\nactor Subscriber {\n\n  type Counter = {\n    topic : Text;\n    value : Nat;\n  };\n\n  var count: Nat = 0;\n\n  public func init(topic0 : Text) {\n    Publisher.subscribe({\n      topic = topic0;\n      callback = updateCount;\n    });\n  };\n\n  public func updateCount(counter : Counter) {\n    count += counter.value;\n  };\n\n  public query func getCount() : async Nat {\n    count;\n  };\n}\n","quicksort/src/Main.mo":"import Int \"mo:base/Int\";\nimport Quicksort \"Quicksort\";\n\nactor Main {\n\n  // Sort an array of integers.\n  public query func sort(xs : [Int]) : async [Int] {\n    return Quicksort.sortBy(xs, Int.compare);\n  };\n};\n","quicksort/src/Quicksort.mo":"import Array \"mo:base/Array\";\nimport Order \"mo:base/Order\";\nimport Int \"mo:base/Int\";\n\nmodule Quicksort {\n\n  type Order = Order.Order;\n\n  // Sort the elements of an array using the given comparison function.\n  public func sortBy<X>(xs : [X], f : (X, X) -> Order) : [X] {\n    let n = xs.size();\n    if (n < 2) {\n      return xs;\n    } else {\n      let result = Array.thaw<X>(xs);\n      sortByHelper<X>(result, 0, n - 1, f);\n      return Array.freeze<X>(result);\n    };\n  };\n\n  private func sortByHelper<X>(\n    xs : [var X],\n    l : Int,\n    r : Int,\n    f : (X, X) -> Order,\n  ) {\n    if (l < r) {\n      var i = l;\n      var j = r;\n      var swap  = xs[0];\n      let pivot = xs[Int.abs(l + r) / 2];\n      while (i <= j) {\n        while (Order.isLess(f(xs[Int.abs(i)], pivot))) {\n          i += 1;\n        };\n        while (Order.isGreater(f(xs[Int.abs(j)], pivot))) {\n          j -= 1;\n        };\n        if (i <= j) {\n          swap := xs[Int.abs(i)];\n          xs[Int.abs(i)] := xs[Int.abs(j)];\n          xs[Int.abs(j)] := swap;\n          i += 1;\n          j -= 1;\n        };\n      };\n      if (l < j) {\n        sortByHelper<X>(xs, l, j, f);\n      };\n      if (i < r) {\n        sortByHelper<X>(xs, i, r, f);\n      };\n    };\n  };\n};\n","random_maze/src/random_maze/main.mo":"import Random \"mo:base/Random\";\nimport Array \"mo:base/Array\";\nimport List \"mo:base/List\";\nimport Stack \"mo:base/Stack\";\nimport Iter \"mo:base/Iter\";\nimport Blob \"mo:base/Blob\";\nimport Nat \"mo:base/Nat\";\nimport Debug \"mo:base/Debug\";\n\n/// Generate a random maze using cryptographic randomness.\n///\n/// Illustrates library `Random.mo` for cryptographic randomness. In particlar:\n///\n/// * asynchronous requests for initial and additional entropy using\n///   shared function `Random.blob()`; and\n/// * generating bounded, discrete random numbers using class `Random.Finite()`.\n\nactor {\n\n  type Maze = [[var Nat8]];\n\n  let hall : Nat8 = 0;\n  let wall : Nat8 = 1;\n\n  func visit(n : Nat8) : Nat8 {\n    n | 2\n  };\n\n  func visited(n : Nat8) : Bool {\n    n & 2 == 2\n  };\n\n  func bit(b : Bool) : Nat {\n    if (b) 1 else 0;\n  };\n\n  /// Given finite source of randomness `f`,\n  /// return an optional random number between [0..`max`)\n  /// (using rejection sampling).\n  /// Return of `null` indicates `f` is exhausted and should be replaced.\n  func chooseMax(f : Random.Finite, max : Nat) : ? Nat {\n    assert max > 0;\n    do ? {\n      if (max == 1) return ? 0;\n      var k = bit(f.coin()!);\n      var n = max / 2;\n      while (n > 1) {\n        k := k * 2 + bit(f.coin()!);\n        n := n / 2;\n      };\n      if (k < max)\n        return ? k\n      else chooseMax(f, max) !; // retry\n    };\n  };\n\n  func unvisited(i : Nat, j : Nat, m : Maze) : List.List<(Nat,Nat)> {\n    let max: Nat = m.size() - 1;\n    var cs = List.nil<(Nat,Nat)>();\n    if (i > 1 and not visited(m[i - 2][j]))\n      // The <(Nat,Nat)> type annotation is not required, but it can slience the underflow warning for i - 2\n      cs := List.push<(Nat,Nat)>((i - 2, j), cs);\n    if (i + 1 < max and not visited(m[i + 2][j]))\n      cs := List.push((i + 2, j), cs);\n    if (j > 1 and not visited(m[i][j - 2]))\n      cs := List.push<(Nat,Nat)>((i, j - 2), cs);\n    if (j + 1 < max and not visited(m[i][j + 2]))\n      cs := List.push((i, j + 2), cs);\n    cs;\n  };\n\n  func toText(maze : Maze) : Text {\n    var t = \"\\n\";\n    for (row in maze.vals()) {\n      for (col in row.vals()) {\n        t #= if (col == wall) \"\" else \"\";\n      };\n    t #= \"\\n\";\n    };\n    t\n  };\n\n  /// Given n, returns a maze of n * n cells,\n  /// separated by n + 1 partial walls.\n  ///\n  /// https://en.wikipedia.org/wiki/Maze_generation_algorithm\n  /// https://en.wikipedia.org/wiki/Maze_generation_algorithm#Iterative_implementation\n  public func generate(size : Nat) : async Text {\n\n    let n = Nat.max(1, size / 2);\n\n    // Construct a maze of mutable, unvisited walls\n    let m = Array.tabulate<[var Nat8]>(2 * n + 1,\n      func i { Array.init(2 * n + 1, wall) });\n\n    // Use iterative depth-first search on odd numbered entries\n    // to turn walls into cells connected by random halls\n    let s = Stack.Stack<(Nat,Nat)>();\n    let entropy = await Random.blob(); // get initial entropy\n    var f = Random.Finite(entropy);\n\n    m[0][1] := hall; // Entrance\n    m[2*n][2*n-1] := hall; // Exit\n\n    m[1][1] := visit(hall);\n    s.push((1, 1));\n    loop {\n      switch (s.pop()) {\n        case null return toText(m);\n        case (?(i, j)) {\n          let us = unvisited(i, j, m);\n          if (not List.isNil(us)) {\n            switch (chooseMax(f, List.size(us))) {\n              case (? k) {\n                s.push((i, j));\n                let ? (i1, j1) = List.get(us, k);\n                // connect cell (i, j) and (i1, j1)\n                m[if (i == i1) i else (Nat.min(i, i1) + 1)]\n                  [if (j == j1) j else (Nat.min(j, j1) + 1)] := hall;\n                m[i1][j1] := visit(hall);\n                s.push((i1, j1));\n              };\n              case null { // not enough entropy\n                Debug.print(\"need more entropy...\");\n                let entropy = await Random.blob(); // get more entropy\n                f := Random.Finite(entropy);\n                s.push((i,j)); // continue from (i,j)\n              }\n            }\n          }\n        }\n      }\n    }\n  };\n\n};\n","simple-to-do/src/Main.mo":"import Map \"mo:base/HashMap\";\nimport Hash \"mo:base/Hash\";\nimport Nat \"mo:base/Nat\";\nimport Iter \"mo:base/Iter\";\nimport Text \"mo:base/Text\";\n\n// Define the actor\nactor Assistant {\n\n  type ToDo = {\n    description: Text;\n    completed: Bool;\n  };\n\n  func natHash(n : Nat) : Hash.Hash { \n    Text.hash(Nat.toText(n))\n  };\n\n  var todos = Map.HashMap<Nat, ToDo>(0, Nat.equal, natHash);\n  var nextId : Nat = 0;\n\n  public query func getTodos() : async [ToDo] {\n    Iter.toArray(todos.vals());\n  };\n\n  // Returns the ID that was given to the ToDo item\n  public func addTodo(description : Text) : async Nat {\n    let id = nextId;\n    todos.put(id, { description = description; completed = false });\n    nextId += 1;\n    id\n  };\n\n  public func completeTodo(id : Nat) : async () {\n    ignore do ? {\n      let description = todos.get(id)!.description;\n      todos.put(id, { description; completed = true });\n    }\n  };\n\n  public query func showTodos() : async Text {\n    var output : Text = \"\\n___TO-DOs___\";\n    for (todo : ToDo in todos.vals()) {\n      output #= \"\\n\" # todo.description;\n      if (todo.completed) { output #= \" \"; };\n    };\n    output # \"\\n\"\n  };\n\n  public func clearCompleted() : async () {\n    todos := Map.mapFilter<Nat, ToDo, ToDo>(todos, Nat.equal, natHash, \n              func(_, todo) { if (todo.completed) null else ?todo });\n  };\n}\n","superheroes/src/superheroes/Main.mo":"import List \"mo:base/List\";\nimport Option \"mo:base/Option\";\nimport Trie \"mo:base/Trie\";\nimport Nat32 \"mo:base/Nat32\";\n\nactor Superheroes {\n\n  /**\n   * Types\n   */\n\n  // The type of a superhero identifier.\n  public type SuperheroId = Nat32;\n\n  // The type of a superhero.\n  public type Superhero = {\n    name : Text;\n    superpowers : List.List<Text>;\n  };\n\n  /**\n   * Application State\n   */\n\n  // The next available superhero identifier.\n  private stable var next : SuperheroId = 0;\n\n  // The superhero data store.\n  private stable var superheroes : Trie.Trie<SuperheroId, Superhero> = Trie.empty();\n\n  /**\n   * High-Level API\n   */\n\n  // Create a superhero.\n  public func create(superhero : Superhero) : async SuperheroId {\n    let superheroId = next;\n    next += 1;\n    superheroes := Trie.replace(\n      superheroes,\n      key(superheroId),\n      Nat32.equal,\n      ?superhero,\n    ).0;\n    return superheroId;\n  };\n\n  // Read a superhero.\n  public query func read(superheroId : SuperheroId) : async ?Superhero {\n    let result = Trie.find(superheroes, key(superheroId), Nat32.equal);\n    return result;\n  };\n\n  // Update a superhero.\n  public func update(superheroId : SuperheroId, superhero : Superhero) : async Bool {\n    let result = Trie.find(superheroes, key(superheroId), Nat32.equal);\n    let exists = Option.isSome(result);\n    if (exists) {\n      superheroes := Trie.replace(\n        superheroes,\n        key(superheroId),\n        Nat32.equal,\n        ?superhero,\n      ).0;\n    };\n    return exists;\n  };\n\n  // Delete a superhero.\n  public func delete(superheroId : SuperheroId) : async Bool {\n    let result = Trie.find(superheroes, key(superheroId), Nat32.equal);\n    let exists = Option.isSome(result);\n    if (exists) {\n      superheroes := Trie.replace(\n        superheroes,\n        key(superheroId),\n        Nat32.equal,\n        null,\n      ).0;\n    };\n    return exists;\n  };\n\n  /**\n   * Utilities\n   */\n\n  // Create a trie key from a superhero identifier.\n  private func key(x : SuperheroId) : Trie.Key<SuperheroId> {\n    return { hash = x; key = x };\n  };\n};\n","threshold-ecdsa/src/ecdsa_example_motoko/main.mo":"import Cycles \"mo:base/ExperimentalCycles\";\nimport Error \"mo:base/Error\";\nimport Principal \"mo:base/Principal\";\n\nactor {\n  // Only the ecdsa methods in the IC management canister is required here.\n  type IC = actor {\n    ecdsa_public_key : ({\n      canister_id : ?Principal;\n      derivation_path : [Blob];\n      key_id : { curve: { #secp256k1; } ; name: Text };\n    }) -> async ({ public_key : Blob; chain_code : Blob; });\n    sign_with_ecdsa : ({\n      message_hash : Blob;\n      derivation_path : [Blob];\n      key_id : { curve: { #secp256k1; } ; name: Text };\n    }) -> async ({ signature : Blob });\n  };\n\n  let ic : IC = actor(\"aaaaa-aa\");\n\n  public shared (msg) func public_key() : async { #Ok : { public_key: Blob }; #Err : Text } {\n    let caller = Principal.toBlob(msg.caller);\n    try {\n      let { public_key } = await ic.ecdsa_public_key({\n          canister_id = null;\n          derivation_path = [ caller ];\n          key_id = { curve = #secp256k1; name = \"dfx_test_key\" };\n      });\n      #Ok({ public_key })\n    } catch (err) {\n      #Err(Error.message(err))\n    }\n  };\n\n  public shared (msg) func sign(message_hash: Blob) : async { #Ok : { signature: Blob };  #Err : Text } {\n    assert(message_hash.size() == 32);\n    let caller = Principal.toBlob(msg.caller);\n    try {\n      Cycles.add(10_000_000_000);\n      let { signature } = await ic.sign_with_ecdsa({\n          message_hash;\n          derivation_path = [ caller ];\n          key_id = { curve = #secp256k1; name = \"dfx_test_key\" };\n      });\n      #Ok({ signature })\n    } catch (err) {\n      #Err(Error.message(err))\n    }\n  };\n}\n\n","whoami/src/Main.mo":"import Principal \"mo:base/Principal\";\n\nshared (install) actor class WhoAmI(someone : Principal) =\n  this { // Bind the optional `this` argument (any name will do)\n\n  // Return the principal identifier of the wallet canister that installed this\n  // canister.\n  public query func installer() : async Principal {\n    return install.caller;\n  };\n\n  // Return the principal identifier that was provided as an installation\n  // argument to this canister.\n  public query func argument() : async Principal {\n    return someone;\n  };\n\n  // Return the principal identifier of the caller of this method.\n  public shared (message) func whoami() : async Principal {\n    return message.caller;\n  };\n\n  // Return the principal identifier of this canister.\n  public func id() : async Principal {\n    return await whoami();\n  };\n\n  // Return the principal identifier of this canister via the optional `this` binding.\n  // This is much quicker than `id()` above, since it avoids the latency of `await whoami()`.\n  public func idQuick() : async Principal {\n    return Principal.fromActor(this);\n  };\n};\n","tipjar/src/logger/TextLogger.mo":"// Persistent logger keeping track of what is going on.\n\nimport Array \"mo:base/Array\";\nimport Buffer \"mo:base/Buffer\";\nimport Deque \"mo:base/Deque\";\nimport List \"mo:base/List\";\nimport Nat \"mo:base/Nat\";\nimport Option \"mo:base/Option\";\nimport Principal \"mo:base/Principal\";\n\nimport Logger \"mo:ic-logger/Logger\";\n\nactor TextLogger {\n  let OWNER = Principal.fromText(\"y5mgz-ye6pv-bg3mu-purwq-cowuz-gkva5-hdsrv-leuqd-53hfi-kyjr4-oae\");\n\n  stable var state : Logger.State<Text> = Logger.new<Text>(0, null);\n  let logger = Logger.Logger<Text>(state);\n\n  // Principals that are allowed to log messages.\n  stable var allowed : [Principal] = [OWNER];\n\n  // Set allowed principals.\n  public shared (msg) func allow(ids: [Principal]) {\n    assert(msg.caller == OWNER);\n    allowed := ids;\n  };\n\n  // Add a set of messages to the log.\n  public shared (msg) func append(msgs: [Text]) {\n    assert(Option.isSome(Array.find(allowed, func (id: Principal) : Bool { msg.caller == id })));\n    logger.append(msgs);\n  };\n\n  // Return log stats, where:\n  //   start_index is the first index of log message.\n  //   bucket_sizes is the size of all buckets, from oldest to newest.\n  public query func stats() : async Logger.Stats {\n    logger.stats()\n  };\n\n  // Return the messages between from and to indice (inclusive).\n  public shared query (msg) func view(from: Nat, to: Nat) : async Logger.View<Text> {\n    assert(msg.caller == OWNER);\n    logger.view(from, to)\n  };\n\n  // Drop past buckets (oldest first).\n  public shared (msg) func pop_buckets(num: Nat) {\n    assert(msg.caller == OWNER);\n    logger.pop_buckets(num)\n  }\n}\n","tipjar/src/tipjar/Util.mo":"import AccountId \"mo:accountid/AccountId\";\nimport Array \"mo:base/Array\";\nimport Blob \"mo:base/Blob\";\nimport Debug \"mo:base/Debug\";\nimport Iter \"mo:base/Iter\";\nimport Nat \"mo:base/Nat\";\nimport Nat64 \"mo:base/Nat64\";\nimport Nat8 \"mo:base/Nat8\";\nimport Option \"mo:base/Option\";\nimport Prelude \"mo:base/Prelude\";\nimport Principal \"mo:base/Principal\";\nimport Result \"mo:base/Result\";\nimport Text \"mo:base/Text\";\nimport Time \"mo:base/Time\";\n\nimport Queue \"mo:mutable-queue/Queue\";\n\nmodule Util {\n\n  // For each canister, we keep a number of historical cycle balance/usage data.\n  // At an interval of 8 hours, 30 means keeping data for the past 10 days.\n  let MAX_HISTORY = 30;\n\n  public type Queue<T> = Queue.Queue<T>;\n  public type Cycle = Nat;\n\n  public type Token = { e8s: Nat64 };\n\n  public type Balance = { icp: { var e8s: Nat64 }; var cycle: Cycle };\n\n  public type BalanceInfo = { icp: Token; cycle: Cycle };\n\n  public type Allocation = {\n    canister: Canister;\n    var alias: ?Text;\n    var allocated: Cycle;\n    var donated: Cycle;\n  };\n\n  public type AllocationInfo = {\n    canister: CanisterInfo;\n    alias: Text;\n    allocated: Cycle;\n    donated: Cycle;\n  };\n\n  public type UserStatus = {\n    #DepositingCycle;\n    #DepositSuccess;\n    #DepositError: Text;\n  };\n\n  public type User = {\n    id: Principal;\n    // A user can delegate all its cycle balance to another user.\n    // This is used to merge a temporary account into an authenticated account.\n    var delegate: ?Principal;\n    balance: Balance;\n    allocations: Queue<Allocation>;\n    var last_updated: Time.Time;\n    var status: ?UserStatus;\n  };\n\n  public type UserInfo = {\n    id: Principal;\n    account: Text;\n    balance: BalanceInfo;\n    allocations: [AllocationInfo];\n    last_updated: Time.Time;\n    status: ?UserStatus;\n  };\n\n  public type Donor = {\n    id: Principal;\n    allocation: Allocation;\n  };\n\n  public type Usage = {\n    cycle: Cycle;\n    period: Time.Time;\n  };\n\n  public type Canister = {\n    id: Principal;\n    first_checked: Time.Time;\n    var last_checked: Time.Time;\n    var last_donated: Time.Time;\n    cycle_balances: Queue<Cycle>;\n    usage: Queue<Usage>;\n    donors: Queue<Donor>;\n    var error: ?Text;\n  };\n\n  public type CanisterInfo = {\n    id: Principal;\n    first_checked: Time.Time;\n    last_checked: Time.Time;\n    last_checked_balance: Cycle;\n    average_balance: Cycle;\n    total_allocation: Cycle;\n    total_donated: Cycle;\n    usage: [Usage];\n    error: ?Text;\n  };\n\n  // Same as Option.unwrap, but without the annoying warning.\n  func unwrap<T>(x: ?T) : T {\n    switch x {\n      case null { Prelude.unreachable() };\n      case (?x_) { x_ };\n    }\n  };\n\n  // Convert Balance to BalanceInfo.\n  public func balanceInfo(balance: Balance) : BalanceInfo {\n    { icp = { e8s = balance.icp.e8s }; cycle = balance.cycle }\n  };\n\n  // Convert Canister to CanisterInfo.\n  public func canisterInfo(canister: Canister) : CanisterInfo {\n    { id = canister.id;\n      first_checked = canister.first_checked;\n      last_checked = canister.last_checked;\n      last_checked_balance = getCanisterCycle(canister);\n      average_balance = getCanisterAverageCycle(canister);\n      total_allocation = getCanisterAllocation(canister);\n      total_donated = getCanisterDonated(canister);\n      usage = Queue.toArray(canister.usage);\n      error = canister.error;\n    }\n  };\n\n  // Convert Allocation to AllocationInfo.\n  public func allocationInfo(allocation: Allocation) : AllocationInfo {\n    { canister = canisterInfo(allocation.canister);\n      alias = Option.get(allocation.alias, \"\");\n      allocated = allocation.allocated;\n      donated = allocation.donated; }\n  };\n\n  // Convert User to UserInfo. The 'self' parameter (tipjar's canister id)\n  // is used to calculate account number.\n  public func userInfo(self: Principal, user: User) : UserInfo {\n    let subaccount = Util.principalToSubAccount(user.id);\n    let account = toHex(AccountId.fromPrincipal(self, ?subaccount));\n    { id = user.id;\n      account = account;\n      balance = balanceInfo(user.balance);\n      allocations = Iter.toArray(Iter.map(Queue.toIter(user.allocations), allocationInfo));\n      last_updated = user.last_updated;\n      status = user.status;\n    }\n  };\n\n  // Convert principal id to subaccount id.\n  public func principalToSubAccount(id: Principal) : [Nat8] {\n    let p = Blob.toArray(Principal.toBlob(id));\n    Array.tabulate(32, func(i : Nat) : Nat8 {\n      if (i >= p.size() + 1) 0\n      else if (i == 0) (Nat8.fromNat(p.size()))\n      else (p[i - 1])\n    })\n  };\n\n  // Set a user's delegate field. Note that this doesn't call 'transferAccount'.\n  // Return false if the user is already delegated.\n  public func delegateUser(user: User, delegate: Principal) : Bool {\n    switch (user.delegate) {\n      case null { user.delegate := ?delegate; true };\n      case (?_) { false };\n    }\n  };\n\n  // Transfer everything (except ICP balance) from one User to another User.\n  // For the remaining ICP balance, it will still require the 'from_user' to 'poll'\n  // and then it will be converted into cycles and deposit to 'to_user' account.\n  public func transferAccount(from_user: User, to_user: User) {\n    assert(Option.get(Option.map(from_user.delegate,\n      func (id: Principal) : Bool { id == to_user.id }), false));\n    let now = Time.now();\n    to_user.balance.cycle := to_user.balance.cycle + from_user.balance.cycle;\n    from_user.balance.cycle := 0;\n    from_user.last_updated := now;\n    to_user.last_updated := now;\n    label L loop {\n      switch (Queue.popFront(from_user.allocations)) {\n        case null { break L; };\n        case (?alloc) {\n          let donor = removeDonor(alloc.canister, from_user.id);\n          assert(Option.isSome(donor));\n          switch (findAllocation(to_user, alloc.canister.id)) {\n            case null {\n              ignore Queue.pushBack(to_user.allocations, alloc);\n              ignore Queue.pushBack(alloc.canister.donors,\n                { id = to_user.id; allocation = alloc })\n            };\n            case (?existing_alloc) {\n              existing_alloc.allocated := existing_alloc.allocated + alloc.allocated;\n              existing_alloc.donated := existing_alloc.donated + alloc.donated;\n            }\n          }\n        }\n      }\n    }\n  };\n\n  // Lookup a user by id.\n  public func findUser(users: Queue<User>, id: Principal) : ?User {\n    Queue.find(users, eqId(id))\n  };\n\n  // Return a new 'User' struct, filled with default values.\n  public func newUser(id: Principal) : User {\n    { id = id;\n      var delegate = null;\n      balance = { icp = { var e8s = 0 : Nat64 }; var cycle = 0 };\n      allocations = Queue.empty();\n      var last_updated = 0;\n      var status = null;\n    };\n  };\n\n  // Same as 'findUser', but will create a new user if it doesn't already exist.\n  public func findOrCreateNewUser(users: Queue<User>, id: Principal) : User {\n    switch (findUser(users, id)) {\n      case (?user) user;\n      case null {\n        let user = newUser(id);\n        user.last_updated := Time.now();\n        ignore Queue.pushFront(user, users);\n        user\n      }\n    }\n  };\n\n  // Set the status field of a user (and last_updated).\n  public func setUserStatus(user: User, status: ?UserStatus) {\n      user.status := status;\n      user.last_updated := Time.now();\n  };\n\n  // Set the ICP balance of a user (and last_updated if the balance has changed).\n  public func setUserICP(user: User, icp: Token) : Bool {\n    if (icp.e8s != user.balance.icp.e8s) {\n      user.balance.icp.e8s := icp.e8s;\n      user.last_updated := Time.now();\n      true\n    } else false\n  };\n\n  // Set the cycle balance of a user (and last_updated if the balance has changed).\n  public func setUserCycle(user: User, cycle: Cycle) : Bool {\n    if (cycle != user.balance.cycle) {\n      user.balance.cycle := cycle;\n      user.last_updated := Time.now();\n      true\n    } else false\n  };\n\n  // Return the last known cycle balance of a canister.\n  // Note that we have an invariant that its cycle balance history is non-empty.\n  // This is guaranteed at the creation of a canister.\n  public func getCanisterCycle(canister: Canister) : Cycle {\n    unwrap(Queue.last(canister.cycle_balances))\n  };\n\n  // Return the total cycle allocation of a canister from all its donors.\n  public func getCanisterAllocation(canister: Canister) : Cycle {\n    Queue.fold(canister.donors, 0,\n      func(s: Cycle, alloc: Donor) : Cycle { s + alloc.allocation.allocated });\n  };\n\n  // Return the total donated cycle of a canister from all its donors.\n  public func getCanisterDonated(canister: Canister) : Cycle {\n    Queue.fold(canister.donors, 0,\n        func(s: Cycle, alloc: Donor) : Cycle { s + alloc.allocation.donated });\n  };\n\n  // Round up cycle to the nearest 1TC. This is used to avoid getting\n  // a lower and lower average over time.\n  public func roundUp(cycle: Cycle) : Cycle {\n    (cycle + 999_999_999_999) / 1_000_000_000_000 * 1_000_000_000_000\n  };\n\n  // Return the average cycle balance of a canister (over the past MAX_HISTORY\n  // number of checks).\n  public func getCanisterAverageCycle(canister: Canister) : Cycle {\n    let cycles = canister.cycle_balances;\n    Queue.fold(cycles, 0, Nat.add) / Queue.size(cycles)\n  };\n\n  // Add a new cycle check of a canister (and update its last_checked).\n  public func addCanisterCycleCheck(canister: Canister, cycle: Cycle) {\n    while (Queue.size(canister.cycle_balances) >= MAX_HISTORY) {\n      ignore Queue.popFront(canister.cycle_balances);\n    };\n    ignore Queue.pushBack(canister.cycle_balances, cycle);\n    canister.last_checked := Time.now();\n  };\n\n  // Deduct required cycles from all donors of a canister in order to fill\n  // the gap. Return the actual total deduction, which may be lower than the\n  // requested gap.\n  // Each donor will contribute according to the ratio of their allocation\n  // over the total allocation.\n  public func deductCanisterDonation(canister: Canister, gap: Cycle) : Cycle {\n    if (gap == 0) { return 0 };\n    let total_allocated = getCanisterAllocation(canister);\n    if (total_allocated == 0) { return 0 };\n    var total = 0;\n    for (donor in Queue.toIter(canister.donors)) {\n      let allocation = donor.allocation;\n      var to_donate = gap * allocation.allocated / total_allocated;\n      if (to_donate > allocation.allocated) {\n        to_donate := allocation.allocated;\n      };\n      total := total + to_donate;\n      allocation.allocated := allocation.allocated - to_donate;\n      allocation.donated := allocation.donated + to_donate;\n    };\n    total\n  };\n\n  // Lookup a user's allocation for the given canister.\n  public func findAllocation(user: User, canister_id: Principal) : ?Allocation {\n    Queue.find(user.allocations, func (alloc: Allocation) : Bool { alloc.canister.id == canister_id })\n  };\n\n  // Set a user's allocation for a given canister.\n  // The allocation could fail due to insufficient balance, and in that case the\n  // max usable cycle is returned.\n  public func setAllocation(user: User, canister: Canister, alias: ?Text, amount: Cycle)\n      : Result.Result<Allocation, Cycle> {\n    let now = Time.now();\n    func setAlias(alloc: Allocation) {\n      let set = switch (alloc.alias, alias) {\n        case (_, null) false;\n        case (?s, ?t) { if (s != t) { alloc.alias := alias; true } else false };\n        case (null, ?_) { alloc.alias := alias; true };\n      };\n      if set {\n        user.last_updated := now;\n      }\n    };\n    switch (findAllocation(user, canister.id)) {\n      case (?alloc) {\n        var total = alloc.allocated + user.balance.cycle;\n        if (total >= amount) {\n          ignore setUserCycle(user, total - amount);\n          alloc.allocated := amount;\n          setAlias(alloc);\n          #ok(alloc)\n        } else (#err(total));\n      };\n      case null {\n        if (user.balance.cycle >= amount) {\n          ignore setUserCycle(user, user.balance.cycle - amount);\n          let alloc : Allocation = { canister = canister; var alias = null;\n                                     var allocated = amount; var donated = 0 };\n          let donor : Donor = { id = user.id; allocation = alloc };\n          ignore Queue.pushFront(donor, canister.donors);\n          ignore Queue.pushFront(alloc, user.allocations);\n          user.last_updated := Time.now();\n          setAlias(alloc);\n          #ok(alloc)\n        } else {\n          #err(user.balance.cycle)\n        }\n      };\n    }\n  };\n\n  // Remove a donor from the canister's donor list.\n  public func removeDonor(canister: Canister, id: Principal) : ?Donor {\n    Queue.removeOne(canister.donors, eqId(id))\n  };\n\n  // Add a new cycle dontation to a canister's donation history\n  // (of MAX_HISTORY number of entries).\n  public func addDonation(canister: Canister, cycle: Cycle) {\n    while (Queue.size(canister.usage) >= MAX_HISTORY) {\n      ignore Queue.popFront(canister.usage);\n    };\n    let now = Time.now();\n    ignore Queue.pushBack(canister.usage,\n      { cycle = cycle; period = now - canister.last_donated });\n    canister.last_donated := now;\n  };\n\n  // Lookup a canister by id.\n  public func findCanister(canisters: Queue<Canister>, id: Principal) : ?Canister {\n    Queue.find(canisters, eqId(id))\n  };\n\n  // Same as 'findCanister' but will create a new canister if it didn't exist.\n  public func findOrAddCanister(canisters: Queue<Canister>, id: Principal, cycle: Cycle)\n      : Canister {\n    switch (findCanister(canisters, id)) {\n      case (?canister) canister;\n      case null {\n        let now = Time.now();\n        let canister : Canister = {\n              id = id;\n              first_checked = now;\n              var last_checked = now;\n              var last_donated = now;\n              cycle_balances = Queue.make(cycle);\n              usage = Queue.empty();\n              donors = Queue.empty();\n              var error = null;\n            };\n        ignore Queue.pushFront(canister, canisters);\n        canister\n      }\n    }\n  };\n\n  // Helper function to be used with 'find' calls.\n  public func eqId(id: Principal) : { id: Principal } -> Bool {\n    func (x: { id: Principal }) { x.id == id }\n  };\n\n  let hexChars = [\"0\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"a\",\"b\",\"c\",\"d\",\"e\",\"f\"];\n\n  public func toHex(arr: [Nat8]): Text {\n    Text.join(\"\", Iter.map<Nat8, Text>(Iter.fromArray(arr), func (x: Nat8) : Text {\n      let a = Nat8.toNat(x / 16);\n      let b = Nat8.toNat(x % 16);\n      hexChars[a] # hexChars[b]\n    }))\n  };\n}\n","tipjar/src/tipjar/main.mo":"import AccountId \"mo:accountid/AccountId\";\nimport Array \"mo:base/Array\";\nimport Blob \"mo:base/Blob\";\nimport Cycles \"mo:base/ExperimentalCycles\";\nimport Debug \"mo:base/Debug\";\nimport Error \"mo:base/Error\";\nimport Hash \"mo:base/Hash\";\nimport Int \"mo:base/Int\";\nimport Nat \"mo:base/Nat\";\nimport Nat8 \"mo:base/Nat8\";\nimport Option \"mo:base/Option\";\nimport Result \"mo:base/Result\";\nimport Principal \"mo:base/Principal\";\nimport Time \"mo:base/Time\";\nimport TrieSet \"mo:base/TrieSet\";\n\nimport Ledger \"canister:ledger\";\nimport Logger \"canister:logger\";\nimport Blackhole \"canister:blackhole\";\n\nimport Queue \"mo:mutable-queue/Queue\";\nimport Util \"./Util\";\n\nshared (installation) actor class TipJar() = self {\n\n  // Some administrative functions are only accessible by who created this canister.\n  let OWNER = installation.caller;\n\n  // ICP fees (TODO: this ideally should come from the ledger instead of being hard coded).\n  let FEE = 10000 : Nat64;\n\n  // Minimum ICP deposit required before converting to cycles.\n  let MIN_DEPOSIT = FEE * 10;\n\n  // The current method of converting ICP to cycles is by sending ICP to the\n  // cycle minting canister with a memo.\n  let CYCLE_MINTING_CANISTER = Principal.fromText(\"rkp4c-7iaaa-aaaaa-aaaca-cai\");\n  let TOP_UP_CANISTER_MEMO = 0x50555054 : Nat64;\n\n  // Wait for CHECK_INTERVAL before checking a canister's cycle balance again.\n  let CHECK_INTERVAL = 3600 * 8_000_000_000;\n\n  // The minimum gap (from the average) required before we topup a canister.\n  let MIN_CYCLE_GAP = 100_000_000_000;\n\n  // The minimum cycle balance for the TipJar canister to keep working.\n  let MIN_RESERVE = 1_000_000_000_000;\n\n  // The maximum number of canisters per user account.\n  let MAX_CANISTERS_PER_USER = 200;\n\n  // Interface of the IC00 management canister. At the moment we only need\n  // 'deposit_cycles' to unconditionally send cycles to another canister.\n  type Management = actor { deposit_cycles : ({canister_id: Principal}) -> async (); };\n\n  type Balance = Util.Balance;\n  type User = Util.User;\n  type Canister = Util.Canister;\n  type Token = Util.Token;\n  type Cycle = Util.Cycle;\n  type Queue<T> = Queue.Queue<T>;\n  type Result<O, E> = Result.Result<O, E>;\n\n  // General stats that we track.\n  type TipJar = { var funded: Cycle; var allocated: Cycle; var donated: Cycle; };\n  stable var tipjar : TipJar = { var funded = 0; var allocated = 0; var donated = 0 };\n\n  // Return this canister's cycle balance without counting users' funds.\n  func selfBalance() : Cycle {\n    let cycles = Cycles.balance();\n    if (cycles >= tipjar.funded) (cycles - tipjar.funded) else 0\n  };\n\n  // Convert Error to Text.\n  func show_error(err: Error) : Text {\n    debug_show({ error = Error.code(err); message = Error.message(err); })\n  };\n\n  // Helper to create logging function.\n  func logger(name: Text) : Text -> async () {\n    let prefix = \"[\" # Int.toText(Time.now()) # \"/\";\n    func(s: Text) : async () {\n      Logger.append([prefix # Int.toText(Time.now() / 1_000_000_000) # \"] \" # name # \": \" # s])\n    }\n  };\n\n  //////////////////////////////////////////////////////////////////////////\n  // User related operations\n  //////////////////////////////////////////////////////////////////////////\n\n  stable var canisters_v3: Queue<Canister> = Queue.empty();\n  stable var users_v3: Queue<User> = Queue.empty();\n\n  // Use this function to get the user list instead of the stable variable itself.\n  func all_users() : Queue<User> {\n    return users_v3;\n  };\n\n  // Use this function to get the canister list instead of the stable variable itself.\n  func all_canisters() : Queue<Canister> {\n    return canisters_v3;\n  };\n\n  // Convert User to UserInfo.\n  func userInfo(user: User) : Util.UserInfo {\n    Util.userInfo(Principal.fromActor(self), user)\n  };\n\n  // Find a user by id.\n  func findUser(id: Principal) : ?User {\n    Util.findUser(all_users(), id)\n  };\n\n  // Same as 'findUser' but will create a new user if not found.\n  func findOrCreateNewUser(id: Principal) : User {\n    Util.findOrCreateNewUser(all_users(), id)\n  };\n\n  type DelegateError = {\n    #UserNotFound;\n    #AlreadyDelegated;\n    #DoubleDelegateNotAllowed;\n  };\n\n  // Delegate caller's account to the given user id.\n  // The given user id doesn't need to have an existing account, but if it does,\n  // it must be an already delegated account. it means double delegation is not\n  // allowed.\n  // Delegation can only be done once.\n  public shared (arg) func delegate(id: Principal) : async Result<(), DelegateError> {\n    let log = logger(\"delegate\");\n    assert(not Principal.isAnonymous(id));\n    switch (findUser(arg.caller)) {\n      case null { #err(#UserNotFound) };\n      case (?user) {\n        if (Util.delegateUser(user, id)) {\n          ignore log(\"Delegated \" # debug_show({ from = user.id; to = id;\n                                                 balance = user.balance }));\n          if (user.balance.cycle > 0 or Queue.size(user.allocations) > 0) {\n            let delegate = Util.findOrCreateNewUser(all_users(), id);\n            // target user cannot be delegated\n            if (Option.isSome(delegate.delegate)) {\n              ignore log(\"DoublyDelegated \" # debug_show({ user = userInfo(delegate) }));\n               return #err(#DoubleDelegateNotAllowed);\n            };\n            Util.transferAccount(user, delegate);\n          };\n          #ok(())\n        } else {\n          ignore log(\"AlreadyDelegated \" # debug_show({\n            user = userInfo(user);\n            delegate = Option.map(Option.chain(user.delegate, findUser), userInfo); }));\n          #err(#AlreadyDelegated)\n        }\n      };\n    }\n  };\n\n  // Return 'UserInfo' of the caller.\n  // Note that it will return a default value even when the caller doesn't have an account.\n  public shared query (arg) func aboutme() : async Util.UserInfo {\n    userInfo(Option.get(findUser(arg.caller), Util.newUser(arg.caller)))\n  };\n\n  // Test function that directly calls ledger's notify. Used by admin for debugging only.\n  public shared (arg) func testNotify(id: Principal, icp: Token, height: Ledger.BlockIndex) {\n    assert(arg.caller == OWNER);\n    let user = Option.unwrap(findUser(id));\n    let deposit : Deposit = { user = user; icp = icp };\n    depositing := ?(deposit, #Notify(height));\n  };\n\n  // Return self check statistics. Used by admin for debugging only.\n  // TODO: also check balance discrepencies.\n  public shared (arg) func selfCheck() : async Text {\n    assert(arg.caller == OWNER);\n    // (userid, canisterid)\n    type Pair = (Principal, Principal);\n    func hash(x: Pair) : Hash.Hash {\n      Hash.hashNat8([Principal.hash(x.0), Principal.hash(x.1)])\n    };\n    func eq(x: Pair, y: Pair) : Bool { x.0 == y.0 and x.1 == y.1 };\n    var set = TrieSet.empty<Pair>();\n    var out = \"\";\n    for (user in Queue.toIter(all_users())) {\n       out := out # \"User \" # Principal.toText(user.id) # \"\\n\";\n       for (alloc in Queue.toIter(user.allocations)) {\n          let elem = (user.id, alloc.canister.id);\n          if (TrieSet.mem(set, elem, hash(elem), eq)) {\n             out := out # \"  Duplicate allocation \" # Principal.toText(alloc.canister.id) # \"\\n\";\n          };\n          set := TrieSet.put(set, elem, hash(elem), eq);\n       }\n    };\n    for (canister in Queue.toIter(all_canisters())) {\n       out := out # \"Canister \" # Principal.toText(canister.id) # \"\\n\";\n       for (donor in Queue.toIter(canister.donors)) {\n          let elem = (donor.id, canister.id);\n          if (not TrieSet.mem(set, elem, hash(elem), eq)) {\n            out := out # \"\\n  Missing donor \" # Principal.toText(donor.id) # \"\\n\";\n          }\n       }\n    };\n    out\n  };\n\n  type AllocationError = {\n    #CanisterStatusError: Text;\n    #InsufficientBalance: Cycle;\n    #UserDoesNotExist;\n    #AliasTooLong: Nat;\n    #AliasTooShort: Nat;\n    #TooManyCanisters: Nat;\n    #AccessDenied;\n  };\n\n  public type AllocationInput = {\n    canister: Principal;\n    alias: ?Text;\n    allocated: Cycle;\n  };\n\n  // Create an allocation by setting aside some cycles that will be donated to a given canister.\n  // Return updated UserInfo if successful.\n  public shared (arg) func allocate(alloc: AllocationInput)\n      : async Result<Util.UserInfo, AllocationError> {\n    let log = logger(\"allocate\");\n    switch (alloc.alias) {\n      case null ();\n      case (?s) {\n        if (s.size() < 3) {\n          return #err(#AliasTooShort(3));\n        } else if (s.size() > 20) {\n          return #err(#AliasTooLong(20));\n        }\n      }\n    };\n    switch (findUser(arg.caller)) {\n      case null { #err(#UserDoesNotExist) };\n      case (?user) {\n        if (Queue.size(user.allocations) >= MAX_CANISTERS_PER_USER) {\n          return #err(#TooManyCanisters(MAX_CANISTERS_PER_USER));\n        };\n        switch (Util.findCanister(all_canisters(), alloc.canister)) {\n          case (?canister) {\n            let before = Util.getCanisterAllocation(canister);\n            switch (Util.setAllocation(user, canister, alloc.alias, alloc.allocated)) {\n              case (#err(usable)) {\n                #err(#InsufficientBalance(usable))\n              };\n              case (#ok(allocation)) {\n               let after = Util.getCanisterAllocation(canister);\n               tipjar.allocated := tipjar.allocated + after - before;\n               ignore log(\"Allocated \" #\n                 debug_show({ asked = alloc; allocated = Util.allocationInfo(allocation) }));\n               #ok(userInfo(user))\n              }\n            }\n          };\n          case null {\n            try {\n              ignore log(\"BeforeCanisterStatus \" # debug_show({ asked = alloc }));\n              let cycle = if (alloc.canister == Principal.fromActor(self)) {\n                  selfBalance()\n                }  else {\n                  (await Blackhole.canister_status({ canister_id = alloc.canister })).cycles;\n                };\n              let canister = Util.findOrAddCanister(all_canisters(), alloc.canister, cycle);\n              let before = Util.getCanisterAllocation(canister);\n              switch (Util.setAllocation(user, canister, alloc.alias, alloc.allocated)) {\n                case (#err(usable)) {\n                  #err(#InsufficientBalance(usable))\n                };\n                case (#ok(allocation)) {\n                  ignore log(\"AfterCanisterStatus \" #\n                    debug_show({ allocated = Util.allocationInfo(allocation) }));\n                  let after = Util.getCanisterAllocation(canister);\n                  tipjar.allocated := tipjar.allocated + after - before;\n                  #ok(userInfo(user))\n                }\n              };\n            } catch(err) {\n              ignore log(\"AfterCanisterStatus \" # show_error(err));\n              #err(#CanisterStatusError(Error.message(err)))\n            }\n          };\n        }\n      }\n    }\n  };\n\n  //////////////////////////////////////////////////////////////////////////\n  // System related operations\n  //////////////////////////////////////////////////////////////////////////\n\n  // We we are in stopping mode, new deposits or topup will not be processed.\n  var stopping = false;\n\n  type Deposit = { user: User; icp: Token; };\n\n  // Deposit queue. Require users to ping to be added to this queue.\n  stable var deposits : Queue<Deposit> = Queue.empty();\n\n  type Stage = {\n    #Mint;\n    #MintCalled;\n    #Notify: Ledger.BlockIndex;\n    #NotifyCalled;\n  };\n\n  type Depositing = (Deposit, Stage);\n\n  // Current deposit in progress.\n  var depositing : ?Depositing = null;\n\n  // Stop future system activities after finishing pending ones.\n  public shared (arg) func stop(val: Bool) {\n    assert(arg.caller == OWNER);\n    stopping := val;\n  };\n\n  // A user has to 'ping' to see updated account balance.\n  // If some ICP is received, it will be inserted into the deposit queue.\n  public shared (arg) func ping(for_user: ?Principal) {\n    // Do nothing when we are stopping.\n    if (stopping) return;\n    let log = logger(\"ping\");\n\n    // Allow admin to ping on behalf of a user.\n    let id = switch (for_user, arg.caller == OWNER) {\n      case (?id, true) id;\n      case _ (arg.caller);\n    };\n\n    // Disallow anonymous user.\n    assert(not Principal.isAnonymous(id));\n\n    let subaccount = Util.principalToSubAccount(id);\n    let account = Blob.fromArray(AccountId.fromPrincipal(Principal.fromActor(self), ?subaccount));\n    try {\n      let icp = await Ledger.account_balance({ account = account });\n      if (icp.e8s >= MIN_DEPOSIT and\n          Option.isNull(Queue.find<Deposit>(deposits, func(x) { x.user.id == id })) and\n          not (Option.getMapped(depositingInfo(), Util.eqId(id), false))) {\n        let user = findOrCreateNewUser(id);\n        ignore log(\"AccountBalance \" # debug_show({\n          user = id;\n          icp = { old = user.balance.icp; new = icp };\n          delegate = Option.isSome(user.delegate);\n          }));\n        ignore Util.setUserICP(user, icp);\n        Util.setUserStatus(user, ?#DepositingCycle);\n        ignore Queue.pushBack(deposits, { user = user; icp = icp });\n        return;\n      };\n      switch (findUser(id)) {\n        case null ();\n        case (?user) {\n          if (Util.setUserICP(user, icp)) {\n            ignore log(\"AccountBalance \" # debug_show({\n              user = id;\n              icp = { old = user.balance.icp; new = icp };\n              delegate = Option.isSome(user.delegate);\n            }));\n          }\n        }\n      }\n    } catch(err) {\n      ignore log(\"AccountBalance \" # debug_show ({ user = id; err = show_error(err) }))\n    }\n  };\n\n  // Poll the deposit queue to convert from ICP to Cycle.\n  // Inflight deposit should block canister topup, and vice versa.\n  // Note that this is called from heartbeat, but can also be called manually by admin.\n  public shared (arg) func poll() {\n    // Only admin or self can call poll.\n    if (not (arg.caller == Principal.fromActor(self) or arg.caller == OWNER)) return;\n\n    // Only start working on the next deposit if we are not stopping.\n    if (Option.isNull(depositing) and not stopping) {\n      switch (Queue.popFront(deposits)) {\n        case null return;\n        case (?deposit) {\n          // We must TRAP if there is a topup in progress to avoid changing deposit queue.\n          assert(Option.isNull(topping_up));\n          depositing := ?(deposit, #Mint)\n        };\n      }\n    };\n    let log = logger(\"poll\");\n    switch depositing {\n      case (?(deposit, #Mint)) {\n        let user = deposit.user;\n        let from_subaccount = Util.principalToSubAccount(user.id);\n        let to_subaccount = Util.principalToSubAccount(Principal.fromActor(self));\n        let account = AccountId.fromPrincipal(CYCLE_MINTING_CANISTER, ?to_subaccount);\n        ignore log(\"BeforeTransfer \" # debug_show({ user = user.id; deposit = deposit.icp }));\n        try {\n          depositing := ?(deposit, #MintCalled);\n          let result = await Ledger.transfer({\n                to = Blob.fromArray(account);\n                fee = { e8s = FEE };\n                memo = TOP_UP_CANISTER_MEMO;\n                from_subaccount = ?Blob.fromArray(from_subaccount);\n                amount = { e8s = deposit.icp.e8s - 2 * FEE };\n                created_at_time = null;\n              });\n          ignore log(\"AfterTransfer \" # debug_show({ result = result; }));\n          switch (result) {\n            case (#Ok(block_height)) {\n              depositing := ?(deposit, #Notify(block_height));\n            };\n            case (#Err(err)) {\n              depositing := null;\n              Util.setUserStatus(user, ?#DepositError(debug_show(err)));\n            }\n          }\n        } catch(err) {\n          // TODO: notify user?\n          ignore log(\"AfterTransfer \" # show_error(err));\n          depositing := null;\n          Util.setUserStatus(user, ?#DepositError(Error.message(err)));\n        }\n      };\n      case (?(deposit, #Notify(block_height))) {\n        let user = deposit.user;\n        let from_subaccount = Util.principalToSubAccount(user.id);\n        let to_subaccount = Util.principalToSubAccount(Principal.fromActor(self));\n        let starting_cycles = Cycles.balance();\n        ignore log(\"BeforeNotify \" #\n          debug_show({ user = user.id; deposit = deposit.icp; starting_cycles = starting_cycles; }));\n        try {\n          depositing := ?(deposit, #NotifyCalled);\n          await Ledger.notify_dfx({\n              to_canister = CYCLE_MINTING_CANISTER;\n              block_height = block_height;\n              from_subaccount = ?Blob.fromArray(from_subaccount);\n              to_subaccount = ?Blob.fromArray(to_subaccount);\n              max_fee = { e8s = FEE };\n            });\n          let ending_cycles = Cycles.balance();\n          ignore log(\"AfterNotify \" # debug_show({ ending_cycles = ending_cycles; }));\n          if (ending_cycles < starting_cycles) {\n            // TODO: notify user\n          } else {\n            tipjar.funded := tipjar.funded + ending_cycles - starting_cycles;\n            let beneficiary = Option.get(Option.chain(user.delegate, findUser), user);\n            let old_cycle = beneficiary.balance.cycle;\n            ignore Util.setUserCycle(beneficiary,\n              beneficiary.balance.cycle + ending_cycles - starting_cycles);\n            ignore log(\"TopUpCycle \" # debug_show({\n              user = beneficiary.id; delegate = beneficiary.id != user.id;\n              old = old_cycle; new = beneficiary.balance.cycle; }));\n          };\n          Util.setUserStatus(user, ?#DepositSuccess);\n        } catch(err) {\n          Util.setUserStatus(user, ?#DepositError(Error.message(err)));\n          ignore log(\"AfterNotify \" # show_error(err))\n        };\n        depositing := null;\n      };\n      case (_) ();\n    }\n  };\n\n  // When we are ready to topup a canister, we add it to the topup_queue.\n  var topup_queue : Queue<Canister> = Queue.empty<Canister>();\n\n  // The canister that we are currently trying to topup.\n  var topping_up : ?Canister = null;\n\n  // Poll the topup queue to top up the next canister.\n  // Inflight topup should block user deposit, and vice versa.\n  // Note that this is called from heartbeat, but can also be called manually by admin.\n  public shared (arg) func topup() {\n    // Do nothing if we are already doing a topup, or caller is not self or admin.\n    if (Option.isSome(topping_up) or\n        not (arg.caller == Principal.fromActor(self) or arg.caller == OWNER)) return;\n\n    switch (Queue.popFront(topup_queue)) {\n      case null { return };\n      case (?canister) {\n        let log = logger(\"topup\");\n        let average = Util.roundUp(Util.getCanisterAverageCycle(canister));\n        let cycle = Util.getCanisterCycle(canister);\n        if (cycle + MIN_CYCLE_GAP <= average) {\n          let gap = Nat.sub(average, cycle);\n          // can't allow tipjar to go below MIN_RESERVE.\n          if (gap + MIN_RESERVE > Cycles.balance()) return;\n          let donation = Util.deductCanisterDonation(canister, gap);\n          if (donation == 0) { return };\n          if (donation > gap) { return };                // Can't fail\n          if (tipjar.funded < donation) {                // Can't fail\n            ignore log(\"ConsistencyError \" #\n              debug_show({ funded = tipjar.funded; donation = donation }));\n            return\n          };\n          if (tipjar.allocated < donation) {             // Can't fail\n            ignore log(\"ConsistencyError \" #\n              debug_show({ allocated = tipjar.allocated; donation = donation }));\n            return\n          };\n          Util.addDonation(canister, donation);\n          tipjar.funded := tipjar.funded - donation;\n          tipjar.donated := tipjar.donated + donation;\n          tipjar.allocated := tipjar.allocated - donation;\n          // only need to make deposit call when not topping up self\n          if (canister.id != Principal.fromActor(self)) {\n            assert(Option.isNull(depositing)); // TRAP when depositing is in progress\n            topping_up := ?canister;\n            ignore log(\"BeforeDeposit \" #\n              debug_show({ canister = canister.id; cycle = donation }));\n            let management : Management = actor(\"aaaaa-aa\");\n            try {\n              Cycles.add(donation);\n              await management.deposit_cycles({canister_id = canister.id});\n              ignore log(\"AfterDeposit\")\n            } catch (err) {\n              ignore log(\"AfterDeposit \" # show_error(err))\n            };\n            topping_up := null;\n          } else {\n            ignore log(\"SelfDeposit \"\n              # debug_show({ canister = canister.id; cycle = donation }));\n          }\n        }\n      }\n    }\n  };\n\n  system func heartbeat() : async () {\n    // Always try to poll to finish the current depositing process.\n    poll();\n\n    // Always try to topup to the finish queued topup jobs.\n    topup();\n\n    // Do nothing if we are stopping.\n    if (stopping) return;\n\n    // Check next canister to see if it needs to be topped up. Note that\n    // all canisters are always arranged in the order of last_checked.\n    switch (Queue.first(all_canisters())) {\n      case null ();\n      case (?canister) {\n        if (canister.last_checked + CHECK_INTERVAL < Time.now()) {\n          let log = logger(\"heartbeat\");\n          canister.last_checked := Time.now();\n          ignore Queue.rotate(all_canisters());\n          ignore log(\"BeforeCheck \" # debug_show({ canister = canister.id }));\n          // This canister is specially handled.\n          let cycle = if (canister.id == Principal.fromActor(self)) {\n             selfBalance()\n          } else {\n            try {\n              let status = await Blackhole.canister_status({ canister_id = canister.id });\n              canister.error := null;\n              status.cycles\n            } catch(err) {\n              canister.error := ?debug_show(Error.code(err));\n              ignore log(\"AfterCheck \" # show_error(err));\n              return;\n            }\n          };\n          Util.addCanisterCycleCheck(canister, cycle);\n          ignore log(\"AfterCheck \" # debug_show({ cycle = cycle }));\n          if (cycle + MIN_CYCLE_GAP <= Util.roundUp(Util.getCanisterAverageCycle(canister))) {\n            ignore log(\"EnqueueTopUp \" # debug_show({ canister = canister.id }));\n            ignore Queue.pushBack(topup_queue, canister);\n          }\n        }\n      }\n    }\n  };\n\n  //////////////////////////////////////////////////////////////////////////\n  // Stats\n  //////////////////////////////////////////////////////////////////////////\n\n  type Stats = { donors: Nat; canisters: Nat; funded: Nat; allocated: Nat; donated: Nat; info: Text };\n  type DepositingInfo = { id: Principal; icp: Token; stage: Stage };\n\n  func depositingInfo() : ?DepositingInfo {\n    Option.map(depositing, func(d: Depositing) : DepositingInfo {\n      { id = d.0.user.id; icp = d.0.icp; stage = d.1 }\n    })\n  };\n\n  // Return system stats, with extra info if the caller is admin.\n  public shared query (msg) func stats() : async Stats {\n    let info = if (msg.caller == OWNER) {\n            debug_show({\n              owner = OWNER;\n              stopping = stopping;\n              depositing = depositingInfo();\n              topping_up = Option.map(topping_up, func(c: Canister) : Principal { c.id });\n              pending_deposit = Queue.size(deposits);\n              pending_topup = Queue.size(topup_queue);\n              balance = selfBalance();\n              canisters = Array.map(Queue.toArray(all_canisters()),\n                            func (x:Canister):Principal {x.id});\n            })} else \"\";\n    { donors = Queue.size(all_users());\n      canisters = Queue.size(all_canisters());\n      funded = tipjar.funded;\n      allocated = tipjar.allocated;\n      donated = tipjar.donated;\n      info = info;\n    }\n  };\n\n}\n","ic-drive/src/icdrive/FileHandle.mo":"import Array \"mo:base/Array\";\nimport Buffer \"mo:base/Buffer\";\nimport Blob \"mo:base/Blob\";\nimport Bool \"mo:base/Bool\";\nimport Debug \"mo:base/Debug\";\nimport Cycles \"mo:base/ExperimentalCycles\";\nimport Int \"mo:base/Int\";\nimport Iter \"mo:base/Iter\";\nimport Nat \"mo:base/Nat\";\nimport Nat8 \"mo:base/Nat8\";\nimport Principal \"mo:base/Principal\";\nimport Text \"mo:base/Text\";\nimport Time \"mo:base/Time\";\nimport TrieMap \"mo:base/TrieMap\";\nimport FileTypes \"./backend/fileTypes\";\n\nshared (msg) actor class FileHandle (){\n\n  type UserId = FileTypes.UserId;\n  type UserName = FileTypes.UserName;\n  public type FileId = FileTypes.FileId;\n  public type ChunkId = FileTypes.ChunkId;\n  public type ChunkData = FileTypes.ChunkData;\n  public type FileInfo = FileTypes.FileInfo;\n  public type FileInfo2 = FileTypes.FileInfo2;\n  public type FileInit = FileTypes.FileInit;\n\n  stable var fileEntries : [(FileId, FileInfo)] = [];\n  stable var chunkEntries : [(ChunkId, ChunkData)] = [];\n  stable var public_file_url_entries : [(Text, FileId)] = [];\n  \n  var state = FileTypes.empty();\n  stable var owner:Principal = msg.caller;\n  var fileUrlTrieMap = TrieMap.TrieMap<Text, FileId>(Text.equal, Text.hash);\n\n  public query(msg) func getOwner() : async Principal{\n    owner\n  };\n  // Create owner of canister\n  public query(msg) func getCanisterID() : async Principal{\n    msg.caller;\n  };\n  public shared(msg) func createOwner(newOwner: Principal) : async Principal {\n    assert(msg.caller==owner);\n    owner := newOwner;\n    await getCanisterID();\n  };\n\n  // Create file\n  func createFile_(fileData : FileInit, userName: UserName) : async ?FileId {\n    let now = Time.now();\n    let fileId = userName # \"-\" # fileData.name # \"-\" # (Int.toText(now));\n\n    switch (state.files2.get(fileId)) {\n    case (?_) { /* error -- ID already taken. */ null };\n    case null { /* ok, not taken yet. */\n            state.files2.put(fileId, {\n              fileId = fileId;\n              userName = userName;\n              name = fileData.name;\n              createdAt = now;\n              chunkCount = fileData.chunkCount;\n              fileSize = fileData.fileSize;\n              mimeType = fileData.mimeType;\n              thumbnail = fileData.thumbnail;\n              marked = fileData.marked;\n              sharedWith = [];\n              madePublic = false;\n              fileHash = \"\";\n              folder = fileData.folder;\n            });\n\n          ?fileId\n        };\n    };\n  };\n\n  public shared(msg) func createFile(i : FileInit, userName: UserName) : async ?FileId {\n    do?{\n      assert(msg.caller==owner);\n      let fileId = await createFile_(i, userName);\n      fileId!\n    }\n  };\n\n  // Get all files\n  public query(msg) func getFiles() : async ?[FileInfo2] {\n    do?{\n      assert(msg.caller==owner);\n      let b = Buffer.Buffer<FileInfo2>(0);\n      for ((k,v) in state.files2.entries()) {\n          b.add(v);\n      };\n      b.toArray()\n    }\n  };\n\n  // Mark File\n  public shared(msg) func markFile(fileId : FileId) : async ?() {\n    do ? {\n      assert(msg.caller==owner);\n      var fileInfo = state.files2.get(fileId)!;\n      state.files2.put(fileId, {\n        userName = fileInfo.userName;\n        createdAt = fileInfo.createdAt ;\n        fileId = fileId ;\n        name = fileInfo.name ;\n        chunkCount = fileInfo.chunkCount ;\n        fileSize = fileInfo.fileSize;\n        mimeType = fileInfo.mimeType ;\n        thumbnail = fileInfo.thumbnail;\n        marked= not(fileInfo.marked) ;\n        sharedWith = fileInfo.sharedWith ;\n        madePublic = fileInfo.madePublic;\n        fileHash = fileInfo.fileHash;\n        folder = fileInfo.folder;\n      });\n    }\n  };\n\n  func chunkId(fileId : FileId, chunkNum : Nat) : ChunkId {\n    fileId # (Nat.toText(chunkNum));\n  };\n\n  // Put File Chunk\n  public shared(msg) func putFileChunk\n    (fileId : FileId, chunkNum : Nat, chunkData : ChunkData) : async ()\n  {\n    assert(msg.caller==owner);\n    state.chunks.put(chunkId(fileId, chunkNum), chunkData);\n  };\n\n  // Get File Chunk\n  public query(msg) func getFileChunk(fileId : FileId, chunkNum : Nat) : async ?ChunkData {\n    assert(msg.caller==owner);\n    state.chunks.get(chunkId(fileId, chunkNum));\n  };\n\n  // Delete File\n  func deleteFile_(fileInfo : FileInfo2) : () {\n    for (j in Iter.range(1, fileInfo.chunkCount)) {\n      state.chunks.delete(chunkId(fileInfo.fileId, j));\n    };\n    state.files2.delete(fileInfo.fileId);\n  };\n\n  public shared(msg) func deleteFile(fileId : FileId) : async ?() {\n    do ? {\n      assert(msg.caller==owner);\n      let fileInfo = state.files2.get(fileId)!;\n      deleteFile_(fileInfo);\n    }\n  };\n\n  // Share File\n  public shared(msg) func shareFile(fileId : FileId, userNameShared : UserName) : async ?(Text) {\n    do ? {\n      assert(msg.caller==owner);\n      let fileInfo = state.files2.get(fileId)!;      // Info of File\n\n      //if(msg.caller!=fileInfo.userId){  // User cant reshare other users file\n      //  return(?\"Unauthorized\");\n      //};\n      //if(msg.caller==shareId){  // User cant share file to himself\n      //  return(?\"Unauthorized\");\n      //};\n      state.files2.put(fileId, {\n        userName = fileInfo.userName;\n        createdAt = fileInfo.createdAt ;\n        fileId = fileInfo.fileId ;\n        name = fileInfo.name ;\n        chunkCount = fileInfo.chunkCount ;\n        fileSize = fileInfo.fileSize;\n        mimeType = fileInfo.mimeType ;\n        thumbnail = fileInfo.thumbnail;\n        marked = fileInfo.marked ;\n        sharedWith = Array.append<Text>(fileInfo.sharedWith, [userNameShared]);\n        madePublic = fileInfo.madePublic;\n        fileHash = fileInfo.fileHash;\n        folder = fileInfo.folder;\n      });\n      return(?\"Success\")\n    }\n  };\n  \n  //Authorization for sharing to be added\n  public shared(msg) func addSharedFile(fileInfo : FileInfo2) : async () {\n    state.files2.put(fileInfo.fileId, fileInfo)\n  };\n\n  public query(msg) func getSharedFileChunk(fileId : FileId, chunkNum : Nat, userName: UserName) : async ?ChunkData {\n    do?{\n      let fileInfo = state.files2.get(fileId)!;\n      var flag = 0;\n      for (j in fileInfo.sharedWith.vals()) {\n        if(userName==j){\n          flag := 1;\n        };\n      };\n      assert(flag==1);\n      state.chunks.get(chunkId(fileId, chunkNum))!;\n    };\n  };\n\n  public shared(msg) func deleteSharedFile(fileId : FileId) : async ?() {\n    do ? {\n      assert(msg.caller==owner);\n      let fileInfo = state.files2.get(fileId)!;\n      state.files2.delete(fileInfo.fileId);\n    }\n  };\n\n  //Public Files\n  public shared(msg) func makeFilePublic(fileId : FileId, fileHash: Text) : async ?() {\n    do ? {\n      assert(msg.caller==owner);\n      let fileInfo = state.files2.get(fileId)!;\n      fileUrlTrieMap.put(fileHash, fileId);\n      state.files2.put(fileId, {\n        userName = fileInfo.userName;\n        createdAt = fileInfo.createdAt ;\n        fileId = fileId ;\n        name = fileInfo.name ;\n        chunkCount = fileInfo.chunkCount ;\n        fileSize = fileInfo.fileSize;\n        mimeType = fileInfo.mimeType ;\n        thumbnail = fileInfo.thumbnail;\n        marked = fileInfo.marked ;\n        sharedWith = [] ;\n        madePublic = true;\n        fileHash = fileHash;\n        folder = fileInfo.folder;\n      });\n    }\n  };\n\n  public query(msg) func getPublicFileMeta(fileHash : Text) : async ?FileInfo2 {\n    do?{\n      let fileId = fileUrlTrieMap.get(fileHash)!;\n      let fileInfo = state.files2.get(fileId)!;\n    };\n  };\n\n  public query(msg) func getPublicFileChunk(fileId : FileId, chunkNum : Nat) : async ?ChunkData {\n    do?{\n      let fileInfo = state.files2.get(fileId)!;\n      if(fileInfo.madePublic==true){\n        state.chunks.get(chunkId(fileId, chunkNum))!;\n      } else{\n        Blob.fromArray([]);\n      }\n    };\n  };\n\n  public shared(msg) func changeFileDirectory(fileInfoTemp : FileId, folder: Text) : async ?() {\n    do ? {\n      assert(msg.caller==owner);\n      let fileInfo = state.files2.get(fileInfoTemp)!;\n      state.files2.put(fileInfo.fileId, {\n        userName = fileInfo.userName;\n        createdAt = fileInfo.createdAt;\n        fileId = fileInfo.fileId;\n        name = fileInfo.name;\n        chunkCount = fileInfo.chunkCount;\n        fileSize = fileInfo.fileSize;\n        mimeType = fileInfo.mimeType;\n        thumbnail = fileInfo.thumbnail;\n        marked = fileInfo.marked;\n        sharedWith = fileInfo.sharedWith;\n        madePublic = fileInfo.madePublic;\n        fileHash = fileInfo.fileHash;\n        folder = folder;\n      });\n    }\n  };\n\n  // public query(msg) func getPublicFileEntire(file_hash: Text) : async ?ChunkData {\n  //   do?{\n  //     let fileId = fileUrlTrieMap.get(file_hash)!;\n  //     let file_info = state.files2.get(fileId)!;\n  //     if(file_info.madePublic==true){\n  //       var temp : [Nat8] = [];\n  //       let chunkCount = file_info.chunkCount;\n  //       for (j in Iter.range(1, chunkCount)) {\n  //         let k = state.chunks.get(chunkId(fileId, j))!;\n  //         temp := Array.append<Nat8>(temp, k);\n  //       };\n  //       temp;\n  //     } else{\n  //       Blob.fromArray([]);\n  //     }\n  //   };\n  // };\n\n  public shared(msg) func removeFilePublic(fileId : FileId) : async ?() {\n    do ? {\n      assert(msg.caller==owner);\n      let fileInfo = state.files2.get(fileId)!;\n      state.files2.put(fileId, {\n        userName = fileInfo.userName;\n        createdAt = fileInfo.createdAt ;\n        fileId = fileId ;\n        name = fileInfo.name ;\n        chunkCount = fileInfo.chunkCount ;\n        fileSize = fileInfo.fileSize;\n        mimeType = fileInfo.mimeType ;\n        thumbnail = fileInfo.thumbnail;\n        marked = fileInfo.marked ;\n        sharedWith = fileInfo.sharedWith ;\n        madePublic = false;\n        fileHash = \"\";\n        folder = fileInfo.folder;\n      });\n    }\n  };\n\n  //Get Cycles\n  public query(msg) func getCycles() : async Nat {\n    Cycles.balance()\n  };\n\n  //Backup and Recover\n  system func preupgrade() {\n    fileEntries := Iter.toArray(state.files.entries());\n    chunkEntries := Iter.toArray(state.chunks.entries());\n    public_file_url_entries := Iter.toArray(fileUrlTrieMap.entries());\n  };\n\n  system func postupgrade() {\n    for ((fileId, fileInfo) in fileEntries.vals()) {\n      let fileMetaData = {\n        userName = fileInfo.userName;\n        createdAt = fileInfo.createdAt;\n        fileId = fileId;\n        name = fileInfo.name;\n        chunkCount = fileInfo.chunkCount;\n        fileSize = fileInfo.fileSize;\n        mimeType = fileInfo.mimeType;\n        thumbnail = \"\";\n        marked = fileInfo.marked;\n        sharedWith = fileInfo.sharedWith;\n        madePublic = fileInfo.madePublic;\n        fileHash = fileInfo.fileHash;\n        folder = \"\";\n      };\n      Debug.print(fileId);\n      state.files2.put(fileId, fileMetaData);\n    };\n\n    for ((chunkId, chunkData) in chunkEntries.vals()) {\n      state.chunks.put(chunkId, chunkData);\n    };\n\n    //Restore URL Hash and Data\n    for ((hash, data) in public_file_url_entries.vals()) {\n      fileUrlTrieMap.put(hash, data);\n    };\n    \n    fileEntries := [];\n    chunkEntries := [];\n    public_file_url_entries := [];\n  };\n\n///////////////////////////////////////////////////// TEST  //////////////////////////////////////\n\n};\n","ic-drive/src/icdrive/backend/database.mo":"import ProfileTypes \"profileTypes\";\nimport HashMap \"mo:base/HashMap\";\nimport Principal \"mo:base/Principal\";\nimport Time \"mo:base/Time\";\nimport Text \"mo:base/Text\";\nimport Iter \"mo:base/Iter\";\n\nmodule {\n  \n  type Profile = ProfileTypes.Profile;\n  type UserId = ProfileTypes.UserId;\n  type FileCanister = ProfileTypes.FileCanister;\n  type UserName = ProfileTypes.UserName;\n\n  func makeProfile(userId: UserId, userName: UserName, fileCanister: FileCanister, email: Text): Profile {\n    {\n      id = userId;\n      fileCanister = fileCanister;\n      userName = userName;\n      name = \"Anonymous\";\n      email = email;\n      createdAt = Time.now();\n      updateCanister = false;\n    }\n  };\n\n  func isEq(x: UserId, y: UserId): Bool { x == y };\n  func isEqUserName(x: UserName, y: UserName): Bool { x == y };\n\n  public class User() {\n    \n    let hashMap = HashMap.HashMap<UserId, Profile>(1, isEq, Principal.hash);\n    let hashMapUserName = HashMap.HashMap<UserName, UserId>(1, isEqUserName, Text.hash);\n\n    public func createOne(userId: UserId, userName: UserName, fileCanister: FileCanister, email: Text) {\n      hashMap.put(userId, makeProfile(userId, userName, fileCanister, email));\n      hashMapUserName.put(userName, userId);\n    };\n\n//    public func updateOne(userId: UserId, profile: Profile) {\n//      hashMap.put(userId, profile);\n//    };\n\n    public func findOne(userId: UserId): ?Profile {\n      hashMap.get(userId);\n    };\n\n    public func getUserId(userName: UserName): ?UserId {\n      hashMapUserName.get(userName);\n    };\n\n    // Functions used for creating backup of state\n    public func getAllUsers(): [(UserId, Profile)] {\n      Iter.toArray(hashMap.entries())\n    };\n    public func getAllUsersNames(): [(UserName, UserId)] {\n      Iter.toArray(hashMapUserName.entries())\n    };\n\n    public func insertUsers(userId: UserId, profile: Profile) {\n      hashMap.put(userId, profile);\n    };\n    public func insertUsersNames(userName: UserName, userId: UserId) {\n      hashMapUserName.put(userName, userId);\n    };\n\n    public func updateDone(userId: UserId, profile: Profile) {\n      hashMap.put(userId, profile);\n    };\n\n  };\n\n};","ic-drive/src/icdrive/backend/fileTypes.mo":"import Principal \"mo:base/Principal\";\nimport TrieMap \"mo:base/TrieMap\";\nimport Text \"mo:base/Text\";\nimport Int \"mo:base/Int\";\nimport Bool \"mo:base/Bool\";\nimport Blob \"mo:base/Blob\";\nimport Nat8 \"mo:base/Nat8\";\n\nmodule {\n  \n  public type UserId = Principal;\n  public type UserName = Text;\n  public type FileId = Text; // chosen by createFile\n  public type ChunkId = Text; // FileId # (toText(ChunkNum))\n  public type ChunkData = Blob; // encoded as ??\n  public type Map<X, Y> = TrieMap.TrieMap<X, Y>;\n\n  public type FileInit = {\n    name: Text;\n    chunkCount: Nat;\n    fileSize: Nat;\n    mimeType: Text;\n    thumbnail: Text;\n    marked: Bool;\n    sharedWith: [UserName];\n    folder: Text;\n  };\n\n  public type FileInfo = {\n    fileId : FileId;\n    userName: UserName;\n    createdAt : Int;\n    name: Text;\n    chunkCount: Nat;\n    fileSize: Nat;\n    mimeType: Text;\n    marked: Bool;\n    sharedWith: [UserName];\n    madePublic: Bool;\n    fileHash: Text;\n  };\n\n  public type FileInfo2 = {\n    fileId : FileId;\n    userName: UserName;\n    createdAt : Int;\n    name: Text;\n    chunkCount: Nat;\n    fileSize: Nat;\n    mimeType: Text;\n    thumbnail: Text;\n    marked: Bool;\n    sharedWith: [UserName];\n    madePublic: Bool;\n    fileHash: Text;\n    folder: Text;\n  };\n\n  public type State = {\n    /// all files.\n    files : Map<FileId, FileInfo>;\n    /// all chunks.\n    chunks : Map<ChunkId, ChunkData>;\n\n    /// all files.\n    files2 : Map<FileId, FileInfo2>;\n  };\n\n  public func empty () : State {\n\n    let st : State = {\n      chunks = TrieMap.TrieMap<ChunkId, ChunkData>(Text.equal, Text.hash);\n      files = TrieMap.TrieMap<FileId, FileInfo>(Text.equal, Text.hash);\n      files2 = TrieMap.TrieMap<FileId, FileInfo2>(Text.equal, Text.hash);\n    };\n    st\n  };\n\n};\n","ic-drive/src/icdrive/backend/profileTypes.mo":"import Principal \"mo:base/Principal\";\nimport Text \"mo:base/Text\";\n\nmodule {\n  \n  public type FileCanister = Principal;\n  public type UserId = Principal;\n  public type UserName = Text;\n\n  public type CanisterSettings = {\n      controllers : [Principal];\n  };\n  public type UpdateSettingsParams = {\n      canister_id: Principal;\n      settings: CanisterSettings;\n  };\n  public type ICActor = actor {\n      update_settings: shared(params: UpdateSettingsParams) -> async ();\n  };\n\n  public type Profile = {\n    id: UserId;\n    userName: UserName;\n    fileCanister: FileCanister;\n    name : Text;\n    email: Text;\n    createdAt: Int;\n    updateCanister: Bool;\n  };\n\n  public type PublicUrl = {\n    data: Text;\n    id: Principal;\n  };\n\n};\n","ic-drive/src/icdrive/main.mo":"import Array \"mo:base/Array\";\nimport Blob \"mo:base/Blob\";\nimport Cycles \"mo:base/ExperimentalCycles\";\nimport Database \"./backend/database\";\nimport Debug \"mo:base/Debug\";\nimport FileHandle \"FileHandle\";\nimport FileTypes \"./backend/fileTypes\";\nimport TrieMap \"mo:base/TrieMap\";\nimport Int \"mo:base/Int\";\nimport Iter \"mo:base/Iter\";\nimport Nat \"mo:base/Nat\";\nimport Principal \"mo:base/Principal\";\nimport ProfileTypes \"./backend/profileTypes\";\nimport Text \"mo:base/Text\";\n\nshared (msg) actor class icdrive (){\n\n  let admin = msg.caller;\n  type Profile = ProfileTypes.Profile;\n  type UserId = ProfileTypes.UserId;\n  type UserName = ProfileTypes.UserName;\n  type FileCanister = ProfileTypes.FileCanister;\n  type PublicUrl = ProfileTypes.PublicUrl;\n  type FileId = FileTypes.FileId;\n  type FileInfo = FileTypes.FileInfo;\n  type FileInit = FileTypes.FileInit;\n\n  type CanisterSettings = ProfileTypes.CanisterSettings;\n  type UpdateSettingsParams = ProfileTypes.UpdateSettingsParams;\n  type ICActor = ProfileTypes.ICActor;\n\n  let IC: ICActor = actor(\"aaaaa-aa\");\n  var user: Database.User = Database.User();\n\n  stable var user_entries : [(UserId, Profile)] = [];\n  stable var user_name_entries : [(UserName, UserId)] = [];\n\n  stable var feedback : [Text] = [];\n  stable var userCount : Nat = 0;\n\n  public shared(msg) func createProfile(userName: UserName, email: Text) : async ?FileCanister {\n    switch(user.findOne(msg.caller)){\n      case null{\n        Cycles.add(600_000_000_000);\n        let fileHandleObj = await FileHandle.FileHandle(); // dynamically install a new Canister\n        \n        let canId = await fileHandleObj.createOwner(msg.caller);\n        user.createOne(msg.caller, userName, canId, email);\n        \n        let settings: CanisterSettings = {\n        controllers = [admin, msg.caller];\n        };\n        let params: UpdateSettingsParams = {\n            canister_id = canId;\n            settings = settings;\n        };\n        await IC.update_settings(params);\n        userCount := userCount + 1;\n        \n        return(?canId);\n      };\n      case (?_){\n        return(null);\n      };\n    }\n  };\n\n  public query(msg) func checkUserName(userName: UserName) : async Bool {\n    switch (user.getUserId(userName)) {\n    case (?_) { /* error -- ID already taken. */ true };\n    case null { /* ok, not taken yet. */ false };\n    };\n  };\n\n  public query(msg) func getProfile() : async ?Profile {\n    user.findOne(msg.caller);\n  };\n\n  public query(msg) func getUserCanister(userName: UserName) : async ?FileCanister {\n    do?{\n      let userId = user.getUserId(userName)!;\n      let profile = user.findOne(userId)!;\n      profile.fileCanister\n    }\n  };\n\n  public query(msg) func getCanister(userId: UserId) : async ?FileCanister {\n    do?{\n      let profile = user.findOne(userId)!;\n      profile.fileCanister\n    }\n  };\n\n  public query(msg) func getUserName(userId: UserId) : async ?UserName {\n    do?{\n      let profile = user.findOne(userId)!;\n      profile.userName\n    }\n  };\n\n  //Feedback\n  public shared(msg) func addFeedback(feed: Text) : async() {\n    feedback := Array.append<Text>(feedback, [feed]);\n  };\n\n  public query(msg) func getFeedback(password: Text) : async [Text] {\n    if (password == \"process.env.password\") {\n        feedback\n    } else {\n        []\n    }\n  };\n\n  //user count\n  public query(msg) func getUserCount(password: Text) : async Nat {\n    if (password == \"process.env.password\") {\n        userCount\n    } else {\n        0\n    }\n  };\n\n  public query(msg) func userProfile(password: Text) : async [(UserId, Profile)] {\n    if (password == \"process.env.password\") {\n        user.getAllUsers()\n    } else {\n        []\n    }\n  };\n\n  //Backup and Recover\n  public shared(msg) func updateDone() : async?() {\n    do?{\n      let profile = user.findOne(msg.caller)!;\n      user.updateDone(msg.caller, {\n        id = profile.id;\n        userName = profile.userName;\n        fileCanister = profile.fileCanister;\n        name = profile.name;\n        email = profile.email;\n        createdAt = profile.createdAt;\n        updateCanister = false;\n      });\n    }\n  };\n  \n  system func preupgrade() {\n    user_entries := user.getAllUsers();\n    user_name_entries := user.getAllUsersNames();\n  };\n\n  system func postupgrade () {\n    //Restore UserId Profile\n    for ((userId, profile) in user_entries.vals()) {\n      user.insertUsers(userId, {\n        id = profile.id;\n        userName = profile.userName;\n        fileCanister = profile.fileCanister;\n        name = profile.name;\n        email = profile.email;\n        createdAt = profile.createdAt;\n        updateCanister = true;\n      });\n    };\n    //Restore Username UserId\n    for ((userName, userId) in user_name_entries.vals()) {\n      user.insertUsersNames(userName, userId);\n    };\n    \n    user_entries := [];\n    user_name_entries := [];\n  };\n\n  ////////////////////////////////////Testing/////////////////////////////////////////////\n  public query(msg) func getAdmin() : async Principal {\n    admin\n  };\n};","cancan/backend/Access.mo":"import Text \"mo:base/Text\";\nimport Array \"mo:base/Array\";\nimport Principal \"mo:base/Principal\";\n\nimport Debug \"mo:base/Debug\";\n\nimport Types \"Types\";\nimport Role \"Role\";\nimport Rel \"Rel\";\nimport RelObj \"RelObj\";\nimport SeqObj \"SeqObj\";\n\nmodule {\n\n  /// Access control log stores all of the checks and their outcomes,\n  // e.g., for debugging and auditing security.\n  public module Log {\n    public module Check {\n      /// An access check consists of a caller, a username and a user action.\n      public type Check = {\n        caller : Principal;\n        userAction : Types.UserAction;\n        actionTarget : Types.ActionTarget\n      };\n    };\n    public module Event {\n      /// An access event is an access control check, its calling context, and its outcome.\n      public type Event = {\n        time : Int; // using mo:base/Time and Time.now() : Int\n        check : Check.Check;\n        isOk : Bool;\n      };\n      public func equal(x:Event, y:Event) : Bool { x == y };\n    };\n    public type Log = SeqObj.Seq<Event.Event>;\n  };\n\n  public class Access(\n    init : {\n    admin : Principal;\n    uploaded : RelObj.RelObj<Types.UserId, Types.VideoId>\n  } )\n  {\n\n    /// initial administrator (who grants admin role to others, potentially)\n    public let admin : Principal = init.admin;\n\n    /// access log.\n    public var log : Log.Log =\n      SeqObj.Seq<Log.Event.Event>(Log.Event.equal, null);\n\n    /// # Definition of userPrincipal and userRole (general binary relations, not 1:1):\n    ///\n    /// - Each principal may be authorized with multiple usernames.\n    /// - Those usernames may be shared among multiple principals.\n    /// - Each username may have multiple roles,\n    ///   especially as we introduce more moderation features, later.\n    ///\n\n    /// Relating usernames and roles.\n    public var userRole : RelObj.RelObj<Types.UserId, Types.Role> =\n      RelObj.RelObj<Types.UserId, Role.Role>\n    ((Text.hash, Role.hash), (Text.equal, Role.equal));\n\n    /// Relating usernames and (system-level) principal identifiers.\n    public var userPrincipal : RelObj.RelObj<Types.UserId, Principal> =\n      RelObj.RelObj<Types.UserId, Principal>\n    ((Text.hash, Principal.hash), (Text.equal, Principal.equal));\n\n    /// Get the maximal role for a user.\n    public func userMaxRole(user : Types.UserId) : Types.Role {\n      let roles = userRole.get0(user);\n      switch (roles.size()) {\n        case 0 { #guest };\n        case 1 { roles[0] };\n        case 2 { Role.max(roles[0], roles[1]) };\n        case 3 { Role.max(roles[0], Role.max(roles[1], roles[2])) };\n        case _ {\n               // impossible, or broken invariants: only three possible roles.\n               assert false;\n               #guest\n             };\n      }\n    };\n\n    /// Get the maximal role for a caller,\n    /// considering all possible user names associated with principal.\n    public func callerMaxRole(p : Principal) : Types.Role {\n      if (p == admin) { #admin } else {\n        let usernames = userPrincipal.get1(p);\n        let userRoles = Array.map<Types.UserId, Types.Role>(usernames, userMaxRole);\n        Array.foldLeft(userRoles, #guest, Role.max)\n      }\n    };\n\n    /// Perform a systematic (and logged) service-access check.\n    ////\n    /// `check(caller, userAction, userId)`\n    /// checks that `userAction` is permitted by the caller as `userId`,\n    /// returning `?()` if so, and `null` otherwise.\n    ///\n    /// This function is meant to be used as a protective guard,\n    /// starting each service call, before any other CanCan service logic,\n    /// (before it changes or accesses any state, to guard against unauthorized access).\n    ///\n    /// To audit the CanCan service for security, we need to check that this call is used\n    /// appropriately in each call, and that its logic (below) is correct.\n    ///\n    /// In English, the logic is as follows:\n    ///\n    /// First, use the current state to resolve the caller Principal\n    /// to all available roles, preferring the highest access according to the ordering:\n    ///\n    ///       (minimal access) #guest  <  #user  <  #admin (maximal access)\n    ///\n    /// The role #guest is for new Principals that are not recognized.\n    ///\n    /// Then, we apply these role-based rules:\n    ///\n    /// - #guest-role callers can create currently non-existent usernames,\n    ///    and they may perform no other user actions (no updates and no views).\n    ///\n    /// - #user-role callers can update their own data,\n    ///    and they may only view (not update) other users' data.\n    ///\n    /// - #admin-role callers can perform any action on any user (for simplicity, for now.\n    ///   In a full production setting, we need audit trails, and different sub-roles for admins.)\n    ///\n    public func check(\n      time_ : Int,\n      caller_ : Principal,\n      userAction_ : Types.UserAction,\n      actionTarget_ : Types.ActionTarget,\n    )\n      : ?()\n    {\n      let result = switch (callerMaxRole(caller_)) {\n        case (#admin) {\n               // success; full power, and full responsibility.\n               ?()\n             };\n        case (#guest) {\n               // guests just create users.\n               if(userAction_ == #create) { ?() }\n               else { null }\n             };\n        case (#user) {\n               switch userAction_ {\n                 case (#view) { ?() };\n                 case (#create) { ?() };\n                 case (#admin) { null };\n                 case (#update) {\n                        switch actionTarget_ {\n                          case (#pubView) { ?() };\n                          case (#all) { null };\n                          case (#user i) {\n                                 if (userPrincipal.isMember(i, caller_)) {\n                                   ?()\n                                 } else { null }\n                               };\n                          case (#video v) {\n                                 let users = init.uploaded.get1(v);\n                                 switch (users.size()) {\n                                 case 1 { if (userPrincipal.isMember(users[0], caller_)) {\n                                            ?()\n                                          } else { null } };\n                                 // invariant: exactly only one video uploader per video.\n                                 case _ { assert false; null };\n                                 }\n                               };\n                        }\n                      };\n               }\n             };\n\n      };\n      let accessEvent : Log.Event.Event =\n        {\n          time = time_;\n          caller = caller_;\n          isOk = result == ?();\n          check = { caller = caller_;\n                    userAction = userAction_;\n                    actionTarget = actionTarget_ ; } };\n      // print all access events for debugging\n      Debug.print (debug_show accessEvent);\n      // recall: this log will only be saved for updates, not queries; IC semantic rules.\n      log.add(accessEvent);\n      result\n    };\n  };\n}\n","cancan/backend/Base.mo":"/// Candids for PRs to base.\nimport BaseArray \"mo:base/Array\";\n\nmodule {\n  public module Array {\n    // true iff array is superset of members array.\n    // order does not matter.\n    public func containsAll<X>(array : [X], members : [X], equal : (X, X) -> Bool) : Bool {\n      for (m in members.vals()) {\n        switch (BaseArray.find<X>(array, func (x : X) : Bool { equal(m, x) })) {\n          case null { return false };\n          case _ { };\n        }\n      };\n      return true\n    };\n  }\n}\n","cancan/backend/Demo.mo":"import Types \"Types\";\n\n/// Demo script types\nmodule {\n  public type UserId = Types.UserId;\n  public type VideoId = Types.VideoId;\n\n  public type Command = {\n    #reset : Types.TimeMode ;\n    #putRewardTransfer : { sender : UserId ; receiver : UserId ; amount : Nat };\n    #createTestData : { users : [UserId] ; videos : [(UserId, VideoId)] };\n    #putSuperLike : { userId : UserId ; videoId : VideoId ; superLikes : Bool };\n    #putProfileFollow : { userId : UserId ; toFollow : UserId ; follows : Bool }; \n    #assertVideoVirality : { videoId : VideoId ; isViral : Bool };\n    #assertVideoFeed : { userId : UserId ; limit : ?Nat ; videosPred : VideosPred };\n };\n  \n  public type VideosPred = {\n    #containsAll : [VideoId] ; // order independent check.\n    #equals : [VideoId] ; // order dependent check.\n  };\n\n  public type Result = {\n    #ok ;\n    #err : Text\n  };\n\n  public type TraceCommand = {\n    command : Command ;\n    result : Result ;\n  };\n\n  public type Trace = {\n    status : {#ok ; #err } ;\n    trace : [TraceCommand]\n  };\n\n}\n","cancan/backend/Param.mo":"/// CanCan domain-logic parameters.\n///\n/// Parameters to the service's publicly visible behavior\nmodule {\n  /// Time mode.\n  ///\n  /// Controls how the actor records time and names unique IDs.\n  ///\n  /// For deployment (timeMode = #ic), the time is system time (nanoseconds since 1970-01-01).\n  ///\n  /// For scripts and CI-based testing, we want to predict and control time from a #script.\n  public let timeMode : {#script; #ic} =\n    #ic; // deterministic, small-number times in scripts.\n\n  /// Super like limit.\n  ///\n  /// Users may not super like more than this many videos per \"recent duration of time\".\n  public let maxRecentSuperLikes : Nat = 10;\n\n  /// Abuse flag limit.\n  ///\n  /// Users may not abuse-flag more than this many videos per \"recent duration of time\".\n  public let maxRecentAbuseFlags : Nat = 10;\n\n  /// Super like viral threshold.\n  ///\n  /// When a video has this many super likes, the system \"emits\" a viralVideo signal.\n  /// That signal triggers other actions within the domain logic of CanCan (TBD).\n  public let superLikeViralThreshold : Nat = 5;\n\n  /// Recent past duration of time.\n  ///\n  /// Users may not super like more than a limited number of videos per this duration of time.\n  ///\n  /// The units depends on the value of `timeMode`.\n  /// Time units is nanoseconds (since 1970-01-01) when timeMMode is #ic.\n  /// Time units is script-determined (often beginning at 0) when timeMode is #script.\n  ///\n  public let recentPastDuration : Int = 50_000_000_000;\n\n  public let rewardsForUploader : Nat = 50;\n  public let rewardsForSuperliker : Nat = 10;\n\n  /// Duration for a drop day\n  public let dropDayDuration : Nat = 1_000_000_000;\n  /// Duration from the end of last drop day to the start the next drop\n  public let dropDayNextDuration : Nat = 0_000_000_000;\n\n\n  /// Content moderation\n  ///\n  /// Automated BE policy, based on a simple threshold.\n  /// If more than this number of distinct users flag a video or user,\n  /// the BE logic omits that user or video from all query results.\n  /// They become \"redacted\" from the API results.\n  ///\n  /// Later, we can have more refined policies,\n  /// perhaps based on more sophisticated distributed moderation practices.\n  ///\n  public let contentModerationThreshold : Nat = 2;\n}\n","cancan/backend/Rel.mo":"import Trie \"mo:base/Trie\";\nimport List \"mo:base/List\";\nimport Iter \"mo:base/Iter\";\nimport Hash \"mo:base/Hash\";\nimport Text \"mo:base/Text\";\nimport Prelude \"mo:base/Prelude\";\n\n/// Binary relation representation.\n///\n/// https://en.wikipedia.org/wiki/Binary_relation\n///\n/// Properties of this implementation:\n///\n/// - Uses (purely functional) tries from base library.\n/// - Each operation is fast (sublinear, O(log n) time).\n/// - Relations permit cheap O(1)-time copies; versioned history is possible.\n///\n/// Use this representation to implement binary relations (e.g.,\n/// CanCan videos and CanCan users) that can be represented, merged\n/// and analyzed separately from the data that they relate.\n///\n/// The goal of this representation is to isolate common patterns for\n/// relations, and reduce the boilerplate of the alternative (bespoke\n/// system) design, where each kind of thing has internal collections\n/// (arrays or lists or maps) of the things to which it is related.\n/// That representation can be reconstituted as a view of this one.\n///\nmodule {\n  public type HashPair<X, Y> =\n    ( X -> Hash.Hash,\n      Y -> Hash.Hash );\n\n  public type EqualPair<X, Y> =\n    ( (X, X) -> Bool,\n      (Y, Y) -> Bool) ;\n\n  /// Relation between X's and Y's.\n  ///\n  /// Uses two (related) hash tries, for the edges in each direction.\n  /// Holds the hash and equal functions for the tries.\n  public type Rel<X, Y> = {\n    forw : Trie.Trie2D<X, Y, ()> ;\n    back : Trie.Trie2D<Y, X, ()> ;\n    hash : HashPair<X, Y> ;\n    equal : EqualPair<X, Y> ;\n  };\n\n  /// Relation between X's and Y's.\n  ///\n  /// Shared type (no hash or equal functions).\n  public type RelShared<X, Y> = {\n    forw : Trie.Trie2D<X, Y, ()> ;\n    //\n    // No HO functions, and no backward direction:\n    // In a serialized message form, the backward direction is redundant\n    // and can be recomputed in linear time from the forw field.\n    //\n    // back : Trie.Trie2D<Y, X, ()> ;\n  };\n\n  public func share<X, Y>( rel : Rel<X, Y> ) : RelShared<X, Y> {\n    { forw = rel.forw ;\n      // back = rel.back ;\n    }\n  };\n\n  public func fromShare<X, Y>( rel : RelShared<X, Y>,\n                               hash_ : HashPair<X, Y>,\n                               equal_ : EqualPair<X, Y> ) : Rel<X, Y>\n  {\n    { forw = rel.forw ;\n      back = invert(rel.forw);\n      hash = hash_ ;\n      equal = equal_\n    }\n  };\n\n  public func keyOf0<X, Y>( rel : Rel<X, Y>,  x : X) : Trie.Key<X> {\n    { key = x ; hash = rel.hash.0(x) }\n  };\n\n  public func keyOf1<X, Y>( rel : Rel<X, Y>,  y : Y) : Trie.Key<Y> {\n    { key = y ; hash = rel.hash.1(y) }\n  };\n\n  public func keyOf<X, Y>( rel : Rel<X, Y>, p : (X, Y))\n    : (Trie.Key<X>, Trie.Key<Y>)\n  {\n    (keyOf0(rel, p.0),\n     keyOf1(rel, p.1))\n  };\n\n  public func empty<X, Y>( hash_ : HashPair<X, Y>,\n                           equal_ : EqualPair<X, Y>) : Rel<X, Y> {\n    {\n      forw = Trie.empty();\n      back = Trie.empty();\n      hash = hash_ ;\n      equal = equal_\n    }\n  };\n\n  public func isMember<X, Y>(rel : Rel<X, Y>, x : X, y : Y) : Bool {\n    switch (Trie.find<X, Trie.Trie<Y, ()>>(rel.forw, keyOf0(rel, x), rel.equal.0)) {\n    case null false;\n    case (?t) {\n           switch (Trie.find<Y, ()>(t, keyOf1(rel, y), rel.equal.1)) {\n           case null false;\n           case _ true;\n           }\n         };\n    }\n  };\n\n  public func getRelated0<X, Y>(rel : Rel<X, Y>, x : X) : Iter.Iter<Y> {\n    let t = Trie.find<X, Trie.Trie<Y, ()>>(rel.forw, keyOf0(rel, x), rel.equal.0);\n    switch t {\n      // to do -- define as Iter.empty()\n      case null { object { public func next() : ?Y { null } } };\n      case (?t) { iterAll(t) };\n    }\n  };\n\n  public func getRelated1<X, Y>(rel : Rel<X, Y>, y : Y) : Iter.Iter<X> {\n    let t = Trie.find(rel.back, keyOf1(rel, y), rel.equal.1);\n    switch t {\n      case null { object { public func next() : ?X { null } } };\n      case (?t) { iterAll(t) };\n    }\n  };\n\n  public func put<X, Y>( rel : Rel<X, Y>, p : (X, Y)) : Rel<X, Y> {\n    let k = keyOf(rel, p);\n    {\n      forw = Trie.put2D(rel.forw, k.0, rel.equal.0, k.1, rel.equal.1, ()) ;\n      back = Trie.put2D(rel.back, k.1, rel.equal.1, k.0, rel.equal.0, ()) ;\n      hash = rel.hash ;\n      equal = rel.equal ;\n    }\n  };\n\n  public func delete<X, Y>( rel : Rel<X, Y>, p : (X, Y)) : Rel<X, Y> {\n    let k = (keyOf0(rel, p.0), keyOf1(rel, p.1));\n    {\n      forw = Trie.remove2D(rel.forw, k.0, rel.equal.0, k.1, rel.equal.1).0 ;\n      back = Trie.remove2D(rel.back, k.1, rel.equal.1, k.0, rel.equal.0).0 ;\n      hash = rel.hash ;\n      equal = rel.equal ;\n    }\n  };\n\n  func invert<X, Y>(rel : Trie.Trie2D<X, Y, ()>) : Trie.Trie2D<Y, X, ()> {\n    Prelude.nyi() // to do -- for testing / upgrades sub-story\n  };\n\n  // helper for getRelated{0,1}\n  func iterAll<K>(t : Trie.Trie<K, ()>)\n    : Iter.Iter<K>\n    =\n    object {\n    var stack = ?(t, null) : List.List<Trie.Trie<K, ()>>;\n    public func next() : ?K {\n      switch stack {\n      case null { null };\n      case (?(trie, stack2)) {\n             switch trie {\n             case (#empty) {\n                    stack := stack2;\n                    next()\n                  };\n             case (#leaf({keyvals=null})) {\n                    stack := stack2;\n                    next()\n                  };\n             case (#leaf({size=c; keyvals=?((k2, _), kvs)})) {\n                    stack := ?(#leaf({size=c-1; keyvals=kvs}), stack2);\n                    ?k2.key\n                  };\n             case (#branch(br)) {\n                    stack := ?(br.left, ?(br.right, stack2));\n                    next()\n                  };\n             }\n           }\n      }\n    }\n  };\n\n\n}\n","cancan/backend/RelObj.mo":"import Trie \"mo:base/Trie\";\nimport List \"mo:base/List\";\nimport Iter \"mo:base/Iter\";\nimport Hash \"mo:base/Hash\";\nimport Text \"mo:base/Text\";\nimport Prelude \"mo:base/Prelude\";\n\nimport Rel \"Rel\";\n\n/// OO-based binary relation representation.\n///\n/// See also: Rel module.\nmodule {\n  public class RelObj<X, Y>(\n    hash : Rel.HashPair<X, Y>,\n    equal : Rel.EqualPair<X, Y>)\n  {\n    var rel = Rel.empty<X,Y>(hash, equal);\n    public func put(x : X, y : Y) {\n      rel := Rel.put(rel, (x, y))\n    };\n    public func delete(x : X, y : Y) {\n      rel := Rel.delete(rel, (x, y))\n    };\n    public func isMember(x : X, y : Y) : Bool {\n      Rel.isMember(rel, x, y)\n    };\n    public func get0(x : X) : [Y] {\n      Iter.toArray(Rel.getRelated0(rel, x))\n    };\n    public func get1(y : Y) : [X] {\n      Iter.toArray(Rel.getRelated1(rel, y))\n    };\n    public func get0Size(x : X) : Nat {\n      Iter.size(Rel.getRelated0(rel, x))\n    };\n    public func get1Size(y : Y) : Nat {\n      Iter.size(Rel.getRelated1(rel, y))\n    };\n    public func getMap0<Z>(x : X, f : Y -> Z) : [Z] {\n      Iter.toArray(Iter.map(Rel.getRelated0(rel, x), f))\n    };\n    public func getMap1<Z>(y : Y, f : X -> Z) : [Z] {\n      Iter.toArray(Iter.map(Rel.getRelated1(rel, y), f))\n    };\n  };\n}\n","cancan/backend/Role.mo":"import Hash \"mo:base/Hash\";\nimport Types \"Types\";\n\nmodule {\npublic type Role = Types.Role;\n\npublic func equal(r1 : Role, r2 : Role) : Bool {\n  r1 == r2\n};\n\npublic func max(r1 : Role, r2 : Role) : Role {\n  switch (r1, r2) {\n    case (#admin, _) { #admin };\n    case (_, #admin) { #admin };\n    case (#user, #user) { #user };\n    case (#user, #guest) { #user };\n    case (#guest, #user) { #user };\n    case (#guest, #guest) { #guest };\n  }\n};\n\npublic func hash(r : Role) : Hash.Hash {\n  switch r {\n  case (#user) 0;\n  case (#admin) 1;\n  case (#guest) 2;\n  };\n};\n}\n","cancan/backend/SeqObj.mo":"import Sequence \"mo:sequence/Sequence\";\nimport Iter \"mo:base/Iter\";\n\nmodule {\n  public class Seq<X>(equal : (X, X) -> Bool, initial : ?Sequence.Sequence<X>)\n  {\n    var seq = switch initial {\n      case null { Sequence.empty<X>() };\n      case (?s) { s };\n    };\n    var _append = Sequence.defaultAppend<X>();\n\n    public func sequence() : Sequence.Sequence<X> {\n      seq\n    };\n\n    public func clone() : Seq<X> {\n      Seq<X>(equal, ?seq) // O(1), by sharing immutable rep of seq.\n    };\n\n    public func append(t : Seq<X>) {\n      seq := _append(seq, t.sequence())\n    };\n\n    public func prepend(t : Seq<X>) {\n      seq := _append(t.sequence(), seq)\n    };\n\n    public func add(x : X) {\n      seq := _append(seq, Sequence.make(x))\n    };\n\n    public func vals() : Iter.Iter<X> {\n      Sequence.iter(seq, #fwd)\n    };\n\n    public func revVals() : Iter.Iter<X> {\n      Sequence.iter(seq, #bwd)\n    };\n\n    public func getLast() : ?X {\n      do ? {\n        let (_, x) = Sequence.popBack(seq)!;\n        x\n      }\n    };\n  };\n}\n","cancan/backend/State.mo":"import Hash \"mo:base/Hash\";\nimport Prelude \"mo:base/Prelude\";\nimport Text \"mo:base/Text\";\nimport Int \"mo:base/Int\";\nimport Trie \"mo:base/Trie\";\nimport TrieMap \"mo:base/TrieMap\";\n\n// import non-base primitives\nimport Access \"Access\";\nimport Role \"Role\";\nimport Rel \"Rel\";\nimport RelObj \"RelObj\";\nimport SeqObj \"SeqObj\";\n\n// types in separate file\nimport Types \"./Types\";\n\n/// Internal CanCan canister state.\nmodule {\n\n  // Our representation of (binary) relations.\n  public type RelShared<X, Y> = Rel.RelShared<X, Y>;\n  public type Rel<X, Y> = RelObj.RelObj<X, Y>;\n\n  // Our representation of finite mappings.\n  public type MapShared<X, Y> = Trie.Trie<X, Y>;\n  public type Map<X, Y> = TrieMap.TrieMap<X, Y>;\n\n  public type ChunkId = Types.ChunkId;\n  public type ChunkData = Types.ChunkData;\n\n  public module Event {\n\n    public type CreateProfile = {\n      userName : Text;\n      pic: ?Types.ProfilePic;\n    };\n\n    public type CreateVideo = {\n      info : Types.VideoInit;\n    };\n\n    public type LikeVideo = {\n      source : Types.UserId;\n      target : Types.VideoId;\n      likes : Bool; // false for an \"unlike\" event\n    };\n\n    public type SuperLikeVideo = {\n      source : Types.UserId;\n      target : Types.VideoId;\n      superLikes : Bool; // false for an \"un-Super-like\" event\n    };\n\n    public type RewardPointTransfer = {\n      sender : Types.UserId;\n      receiver : Types.UserId;\n      amount : Nat;\n    };\n\n    public type SuperLikeVideoFail = {\n      source : Types.UserId;\n      target : Types.VideoId;\n    };\n\n    /// A viral video signal.\n    public type ViralVideo = {\n      video : Types.VideoId;\n      uploader : Types.UserId;\n      superLikers : [ViralVideoSuperLiker];\n    };\n\n    /// A viral video signal query.\n    public type ViralVideoQuery = {\n      video : Types.VideoId;\n    };\n\n    /// A viral video's super liker is credited\n    // based on time relative to other super likers.\n    public type ViralVideoSuperLiker = {\n      user : Types.UserId ;\n      time : Int ;\n    };\n\n    /// A signal precipitates further autonomous events.\n    /// (Like an \"event continuation\" within the DSL of events).\n    public type Signal = {\n      #viralVideo : ViralVideo;\n    };\n\n    public type SignalQuery = {\n      #viralVideo : ViralVideoQuery\n    };\n\n    /// An abuse flag event occurs when a reporting user\n    /// sets or clears the abuse toggle in their UI for a video or user.\n    public type AbuseFlag = {\n      reporter : Types.UserId;\n      target : {\n        #video : Types.VideoId;\n        #user : Types.UserId;\n      };\n      flag : Bool;\n    };\n\n    public type EventKind = {\n      #reset : Types.TimeMode;\n      #createProfile : CreateProfile;\n      #createVideo : CreateVideo;\n      #likeVideo : LikeVideo;\n      #superLikeVideo : SuperLikeVideo;\n      #superLikeVideoFail : SuperLikeVideoFail;\n      #rewardPointTransfer : RewardPointTransfer;\n      #emitSignal : Signal;\n      #abuseFlag : AbuseFlag;\n    };\n\n    public type Event = {\n      id : Nat; // unique ID, to avoid using time as one (not always unique)\n      time : Int; // using mo:base/Time and Time.now() : Int\n      kind : EventKind;\n    };\n\n    public func equal(x:Event, y:Event) : Bool { x == y };\n    public type Log = SeqObj.Seq<Event>;\n  };\n\n  /// State (internal CanCan use only).\n  ///\n  /// Not a shared type because of OO containers and HO functions.\n  /// So, cannot send in messages or store in stable memory.\n  ///\n  public type State = {\n    access : Access.Access;\n\n    /// event log.\n    eventLog : Event.Log;\n    var eventCount : Nat;\n\n    /// all profiles.\n    profiles : Map<Types.UserId, Profile>;\n\n    /// all profile pictures (aka thumbnails).\n    profilePics : Map<Types.UserId, Types.ProfilePic>;\n\n    rewards: Map<Types.UserId, Nat>;\n\n    messages: Rel<Types.UserId, Types.Message>;\n\n    /// all videos.\n    videos : Map<Types.VideoId, Video>;\n\n    /// all video pictures (aka thumbnails).\n    videoPics : Map<Types.VideoId, Types.VideoPic>;\n\n    /// follows relation: relates profiles and profiles.\n    follows : Rel<Types.UserId, Types.UserId>;\n\n    /// likes relation: relates profiles and videos.\n    likes : Rel<Types.UserId, Types.VideoId>;\n\n    /// super likes relation: relates profiles and videos.\n    superLikes : Rel<Types.UserId, Types.VideoId>;\n\n    /// uploaded relation: relates profiles and videos.\n    uploaded : Rel<Types.UserId, Types.VideoId>;\n\n    /// all chunks.\n    chunks : Map<Types.ChunkId, ChunkData>;\n\n    /// Users may place an abuse flag on videos and other users.\n    abuseFlagUsers : Rel<Types.UserId, Types.UserId>;\n    abuseFlagVideos : Rel<Types.UserId, Types.VideoId>;\n  };\n\n  // (shared) state.\n  //\n  // All fields have stable types.\n  // This type can be stored in stable memory, for upgrades.\n  //\n  // All fields have shared types.\n  // This type can be sent in messages.\n  // (But messages may not benefit from tries; should instead use arrays).\n  //\n  public type StateShared = {\n    /// all profiles.\n    profiles : MapShared<Types.UserId, Profile>;\n\n    /// all users. see andrew for disambiguation\n    users : MapShared<Principal, Types.UserId>;\n\n    /// all videos.\n    videos : MapShared<Types.VideoId, Video>;\n\n    rewards: MapShared<Types.UserId, Nat>;\n\n    /// follows relation: relates profiles and profiles.\n    follows : RelShared<Types.UserId, Types.UserId>;\n\n    /// likes relation: relates profiles and videos.\n    likes : RelShared<Types.UserId, Types.VideoId>;\n\n    /// uploaded relation: relates profiles and videos.\n    uploaded : RelShared<Types.UserId, Types.VideoId>;\n\n    /// all chunks.\n    chunks : MapShared<Types.ChunkId, ChunkData>;\n  };\n\n  /// User profile.\n  public type Profile = {\n    userName : Text ;\n    createdAt : Types.Timestamp;\n  };\n\n  /// Video.\n  public type Video = {\n    userId : Types.UserId;\n    createdAt : Types.Timestamp;\n    uploadedAt : Types.Timestamp;\n    viralAt: ?Types.Timestamp;\n    caption: Text;\n    tags: [Text];\n    viewCount: Nat;\n    name: Text;\n    chunkCount: Nat;\n  };\n\n  public func empty (init : { admin : Principal }) : State {\n    let equal = (Text.equal, Text.equal);\n    let hash = (Text.hash, Text.hash);\n    func messageEqual(a: Types.Message, b: Types.Message) : Bool = a == b;\n    func messageHash(m: Types.Message) : Hash.Hash = Int.hash(m.id); // id is unique, so hash is unique\n    let uploaded_ = RelObj.RelObj<Types.UserId, Types.VideoId>(hash, equal);\n    let st : State = {\n      access = Access.Access({ admin = init.admin ; uploaded = uploaded_ });\n      profiles = TrieMap.TrieMap<Types.UserId, Profile>(Text.equal, Text.hash);\n      rewards = TrieMap.TrieMap<Types.UserId, Nat>(Text.equal, Text.hash);\n      messages = RelObj.RelObj((Text.hash, messageHash), (Text.equal, messageEqual));\n      chunks = TrieMap.TrieMap<ChunkId, ChunkData>(Text.equal, Text.hash);\n      profilePics = TrieMap.TrieMap<Types.UserId, Types.ProfilePic>(Text.equal, Text.hash);\n      videos = TrieMap.TrieMap<Types.VideoId, Video>(Text.equal, Text.hash);\n      videoPics = TrieMap.TrieMap<Types.VideoId, Types.VideoPic>(Text.equal, Text.hash);\n      follows = RelObj.RelObj(hash, equal);\n      likes = RelObj.RelObj(hash, equal);\n      superLikes = RelObj.RelObj(hash, equal);\n      uploaded = uploaded_;\n      eventLog = SeqObj.Seq<Event.Event>(Event.equal, null);\n      var eventCount = 0;\n      abuseFlagVideos = RelObj.RelObj(hash, equal);\n      abuseFlagUsers = RelObj.RelObj(hash, equal);\n    };\n    st\n  };\n\n  public func share(state : State) : StateShared {\n    Prelude.nyi() // to do -- for testing / upgrades sub-story\n  };\n\n  public func fromShared(share : StateShared) : State {\n    Prelude.nyi() // to do -- for testing / upgrades sub-story\n  };\n\n}\n","cancan/backend/Types.mo":"/// Public-facing types.\nmodule {\n\npublic type Timestamp = Int; // See mo:base/Time and Time.now()\n\npublic type VideoId = Text; // chosen by createVideo\npublic type UserId = Text; // chosen by createUser\npublic type ChunkId = Text; // VideoId # (toText(ChunkNum))\n\npublic type ProfilePic = [Nat8]; // encoded as a PNG file\npublic type VideoPic = [Nat8]; // encoded as a PNG file\npublic type ChunkData = [Nat8]; // encoded as ???\n\n/// Role for a caller into the service API.\n/// Common case is #user.\npublic type Role = {\n  // caller is a user\n  #user;\n  // caller is the admin\n  #admin;\n  // caller is not yet a user; just a guest\n  #guest\n};\n\n/// Action is an API call classification for access control logic.\npublic type UserAction = {\n  /// Create a new user name, associated with a principal and role #user.\n  #create;\n  /// Update an existing profile, or add to its videos, etc.\n  #update;\n  /// View an existing profile, or its videos, etc.\n  #view;\n  /// Admin action, e.g., getting a dump of logs, etc\n  #admin\n};\n\n/// An ActionTarget identifies the target of a UserAction.\npublic type ActionTarget = {\n  /// User's profile or videos are all potential targets of action.\n  #user : UserId ;\n  /// Exactly one video is the target of the action.\n  #video : VideoId ;\n  /// Everything is a potential target of the action.\n  #all;\n  /// Everything public is a potential target (of viewing only)\n  #pubView\n};\n\n/// profile information provided by service to front end views -- Pic is separate query\npublic type ProfileInfo = {\n userName: Text;\n following: [UserId];\n followers: [UserId];\n uploadedVideos: [VideoId];\n likedVideos: [VideoId];\n hasPic: Bool;\n rewards: Nat;\n abuseFlagCount: Nat; // abuseFlags counts other users' flags on this profile, for possible blurring.\n};\n\npublic type AllowanceBalance = {\n  /// Non-zero balance of the given amount (the allowance unit varies by use).\n  #nonZero : Nat;\n  /// Zero now, and will be zero until the IC reaches the given time.\n  #zeroUntil : Timestamp;\n  /// No allowance at all, ever.\n  #zeroForever\n};\n\n/// \"Deeper\" version of ProfileInfo.\n///\n/// Gives Video- and ProfileInfos instead of merely Ids in the results.\npublic type ProfileInfoPlus = {\n  userName: Text;\n following: [ProfileInfo];\n followers: [ProfileInfo];\n uploadedVideos: [VideoInfo];\n likedVideos: [VideoInfo];\n hasPic: Bool;\n rewards: Nat;\n abuseFlagCount: Nat; // abuseFlags counts other users' flags on this profile, for possible blurring.\n /// viewerHasFlagged is\n /// ?true if we (the User requesting this profile) has flagged this profile for abuse.\n /// ?false if not, and\n /// null if no specific requesting user is defined by context.\n viewerHasFlagged: ?Bool;\n /// null if not giving a self view of the profile, otherwise, gives UserAllowances for userName.\n allowances: ?UserAllowances;\n};\n\n/// Some user actions may not occur more than X number of times per 24 hours.\n/// Equivalently, these actions are limited by \"allowances\" that are replenished every 24 hours.\n/// These allowances are quasi-private information, since they leak user data, indirectly.\npublic type UserAllowances = {\n  abuseFlags : AllowanceBalance ;\n  superLikes : AllowanceBalance ;\n};\n\n/// video information provided by front end to service, upon creation.\npublic type VideoInit = {\n userId : UserId;\n name: Text;\n createdAt : Timestamp;\n caption: Text;\n tags: [Text];\n chunkCount: Nat;\n};\n\n/// video information provided by service to front end views -- Pic is separate query\npublic type VideoInfo = {\n videoId : VideoId;\n userId : UserId;\n pic: ?VideoPic;\n createdAt : Timestamp;\n uploadedAt : Timestamp;\n viralAt: ?Timestamp;\n caption: Text;\n tags: [Text];\n likes: [UserId];\n superLikes: [UserId];\n viewCount: Nat;\n name: Text;\n chunkCount: Nat;\n abuseFlagCount: Nat; // abuseFlags counts other users' flags on this profile, for possible blurring.\n /// viewerHasFlagged is\n /// ?true if we (the User requesting this profile) has flagged this profile for abuse.\n /// ?false if not, and\n /// null if no specific requesting user is defined by context.\n viewerHasFlagged: ?Bool; // true if we (the User requesting this profile) has flagged this profile for abuse.\n};\n\npublic type VideoResult = (VideoInfo, ?VideoPic);\npublic type VideoResults = [VideoResult];\n\n/// Notification messages\npublic type Message = {\n  id: Nat;\n    time: Timestamp;\n    event: Event;\n};\npublic type Event = {\n    #uploadReward: { rewards: Nat; videoId: VideoId };\n    #superlikerReward: { rewards: Nat; videoId: VideoId };\n    #transferReward: { rewards: Nat };\n};\n\n/// For test scripts, the script controls how time advances, and when.\n/// For real deployment, the service uses the IC system as the time source.\npublic type TimeMode = { #ic ; #script : Int };\n\n/// CanCan canister's service type.\n///\n/// #### Conventions\n///\n/// - The service (not front end) generates unique ids for new profiles and videos.\n/// - (On behalf of the user, the front end chooses the created profile's `userName`, not `userId`).\n/// - Shared functions return `null` when given invalid IDs, or when they suffer other failures.\n/// - The `Pic` param for putting Videos and Profiles is optional, and can be put separately from the rest of the info.\n///   This de-coupled design is closer to how the front end used BigMap in its initial (current) design.\n///\n/// #### Naming conventions:\n///\n///  - three prefixes: `create`, `get` and `put`.\n///  - `create`- prefix only for id-generating functions (only two).\n///  - `get`- prefix for (query) calls that only ready data.\n///  - `put`- prefix for (update) calls that overwrite data.\n///\npublic type Service = actor {\n\n  createProfile : (userName : Text, pic : ?ProfilePic) -> async ?UserId;\n  getProfileInfo : query (userId : UserId) -> async ?ProfileInfo;\n  getProfilePlus : query (userId : UserId) -> async ?ProfileInfoPlus;\n  getProfilePic : query (userId : UserId) -> async ?ProfilePic;\n  putProfilePic : (userId : UserId, pic : ?ProfilePic) -> async ?();\n\n  getFeedVideos : /*query*/ (userId : UserId, limit : ?Nat) -> async ?VideoResults;\n  getProfileVideos : /*query*/ (userId : UserId, limit : ?Nat) -> async ?VideoResults;\n  getSearchVideos : query (userId : UserId, terms : [Text], limit : ?Nat) -> async ?VideoResults;\n\n  putProfileVideoLike : (userId : UserId, videoId : VideoId, likes : Bool) -> async ?();\n  putProfileFollow : (userId : UserId, toFollow : UserId, follow : Bool) -> async ?();\n\n  createVideo : (videoInfo : VideoInfo) -> async ?VideoId;\n\n  getVideoInfo : query (videoId : VideoId) -> async ?VideoInfo;\n  getVideoPic  : query (videoId : VideoId) -> async ?VideoPic;\n\n  putVideoInfo : (videoId : VideoId, videoInfo : VideoInfo) -> async ?();\n  putVideoPic  : (videoId : VideoId, pic : ?VideoPic) -> async ?();\n\n  putVideoChunk : (videoId : VideoId, chunkNum : Nat, chunkData : ChunkData) -> async ?();\n  getVideoChunk : query (videoId : VideoId, chunkNum : Nat) -> async ?ChunkData;\n\n};\n\n}\n","cancan/service/CanCan.mo":"import Access \"../backend/Access\";\nimport Array \"mo:base/Array\";\nimport Hash \"mo:base/Hash\";\nimport Base \"../backend/Base\";\nimport Buffer \"mo:base/Buffer\";\nimport Debug \"mo:base/Debug\";\nimport Demo \"../backend/Demo\";\nimport DemoCan30 \"Demo/Can30_VideoRecommendations\";\nimport DemoCan32 \"Demo/Can32_ViralEvent\";\nimport HashMap \"mo:base/HashMap\";\nimport Int \"mo:base/Int\";\nimport Iter \"mo:base/Iter\";\nimport List \"mo:base/List\";\nimport Nat \"mo:base/Nat\";\nimport Option \"mo:base/Option\";\nimport P \"mo:base/Prelude\";\nimport Param \"../backend/Param\";\nimport Prelude \"mo:base/Prelude\";\nimport Principal \"mo:base/Principal\";\nimport Rel \"../backend/Rel\";\nimport RelObj \"../backend/RelObj\";\nimport State \"../backend/State\";\nimport Text \"mo:base/Text\";\nimport Time \"mo:base/Time\";\nimport TrieMap \"mo:base/TrieMap\";\nimport Types \"../backend/Types\";\n\nshared ({caller = initPrincipal}) actor class CanCan () /* : Types.Service */ {\n\n  public type ProfileInfo = Types.ProfileInfo;\n  public type ProfileInfoPlus = Types.ProfileInfoPlus;\n  public type ProfilePic = Types.ProfilePic;\n  public type Timestamp = Types.Timestamp;\n  public type UserId = Types.UserId;\n  public type VideoId = Types.VideoId;\n  public type ChunkId = Types.ChunkId;\n  public type ChunkData = Types.ChunkData;\n  public type VideoInfo = Types.VideoInfo;\n  public type VideoInit = Types.VideoInit;\n  public type VideoPic = Types.VideoPic;\n  public type VideoResult = Types.VideoResult;\n  public type VideoResults = Types.VideoResults;\n\n  var state = State.empty({ admin = initPrincipal });\n\n  /*public query*/ func getState() : async State.StateShared {\n    State.share(state)\n  };\n\n  /*public*/ func setState(st : State.StateShared) : async () {\n    state := State.fromShared(st);\n  };\n\n  public query func checkUsernameAvailable(userName_ : Text): async Bool {\n    switch (state.profiles.get(userName_)) {\n      case (?_) { /* error -- ID already taken. */ false };\n      case null { /* ok, not taken yet. */ true };\n    }\n  };\n\n  /// null means that the principal is unrecognized,\n  /// otherwise, returns a non-empty array of usernames.\n  public shared(msg) func getUserNameByPrincipal(p:Principal) : async ?[Text] {\n    if ( msg.caller == p ) {\n      ?state.access.userPrincipal.get1(p)\n    } else {\n      // access control check fails; do not reveal username of p.\n      null\n    }\n  };\n\n  /// log the given event kind, with a unique ID and current time\n  func logEvent(ek : State.Event.EventKind) {\n    state.eventLog.add({\n                         id = state.eventCount ;\n                         time = timeNow_() ;\n                         kind = ek\n                       });\n    state.eventCount += 1;\n  };\n\n  // responsible for adding metadata from the user to the state.\n  // a null principal means that the username has no valid callers (yet), and the admin\n  // must relate one or more principals to it.\n  func createProfile_(userName_ : Text, p: ?Principal, pic_ : ?ProfilePic) : ?() {\n    switch (state.profiles.get(userName_)) {\n      case (?_) { /* error -- ID already taken. */ null };\n      case null { /* ok, not taken yet. */\n        let now = timeNow_();\n        state.profiles.put(userName_, {\n            userName = userName_ ;\n            createdAt = now ;\n        });\n        // rewards init invariant: rewards is initialized to zero (is non-null).\n        state.rewards.put(userName_, 0);\n        logEvent(#createProfile({userName=userName_; pic=pic_}));\n        state.access.userRole.put(userName_, #user);\n        switch p {\n          case null { }; // no related principals, yet.\n          case (?p) { state.access.userPrincipal.put(userName_, p); }\n        };\n        // success\n        ?()\n      };\n    }\n  };\n\n  func accessCheck(caller : Principal, action : Types.UserAction, target : Types.ActionTarget) : ?() {\n    state.access.check(timeNow_(), caller, action, target)\n  };\n\n  public shared(msg) func createProfile(userName : Text, pic : ?ProfilePic) : async ?ProfileInfoPlus {\n    do ? {\n      accessCheck(msg.caller, #create, #user userName)!;\n      createProfile_(userName, ?msg.caller, pic)!;\n      // return the full profile info\n      getProfilePlus_(?userName, userName)! // self-view\n    }\n  };\n\n  var timeMode : {#ic ; #script} =\n    switch (Param.timeMode) {\n     case (#ic) #ic;\n     case (#script _) #script\n    };\n\n  var scriptTime : Int = 0;\n\n  func timeNow_() : Int {\n    switch timeMode {\n      case (#ic) { Time.now() };\n      case (#script) { scriptTime };\n    }\n  };\n\n  public shared(msg) func scriptTimeTick() : async ?() {\n    do ? {\n      accessCheck(msg.caller, #admin, #all)!;\n      assert (timeMode == #script);\n      scriptTime := scriptTime + 1;\n    }\n  };\n\n  func reset_( mode : { #ic ; #script : Int } ) {\n    setTimeMode_(mode);\n    state := State.empty({ admin = state.access.admin });\n  };\n\n  public shared(msg) func reset( mode : { #ic ; #script : Int } ) : async ?() {\n    do ? {\n      accessCheck(msg.caller, #admin, #all)!;\n      reset_(mode)\n    }\n  };\n\n  func setTimeMode_( mode : { #ic ; #script : Int } ) {\n    switch mode {\n      case (#ic) { timeMode := #ic };\n      case (#script st) { timeMode := #script ; scriptTime := st };\n    }\n  };\n\n  public shared(msg) func setTimeMode( mode : { #ic ; #script : Int } ) : async ?() {\n    do ? {\n      accessCheck(msg.caller, #admin, #all)!;\n      setTimeMode_(mode)\n    }\n  };\n\n  func getProfileInfo_(target : UserId) : ?ProfileInfo {\n    do ? {\n      let profile = state.profiles.get(target)!;\n      let following_ = state.follows.get0(target);\n      let followers_ = state.follows.get1(target);\n      let likes_ = state.likes.get0(target);\n      let superLikes_ = state.superLikes.get0(target);\n      let uploaded_ = state.uploaded.get0(target);\n      let rewards_ = state.rewards.get(target)!;\n      let abuseFlagCount_ = state.abuseFlagVideos.get1Size(target);\n      {\n        userName = profile.userName ;\n        followers = filterOutAbuseUsers(followers_)! ;\n        following = filterOutAbuseUsers(following_)! ;\n        likedVideos = filterOutAbuseVideos(likes_)! ;\n        superLikedVideos = filterOutAbuseVideos(superLikes_)! ;\n        uploadedVideos = filterOutAbuseVideos(uploaded_)! ;\n        hasPic = false ;\n        rewards = rewards_;\n        abuseFlagCount = abuseFlagCount_ ;\n      }\n    }\n  };\n\n  public query(msg) func getProfileInfo(userId : UserId) : async ?ProfileInfo {\n    do ? {\n      accessCheck(msg.caller, #view, #user userId)!;\n      getProfileInfo_(userId)!\n    }\n  };\n\n  /// \"Deeper\" version of ProfileInfo.\n  ///\n  /// Gives Video- and ProfileInfos instead of merely Ids in the results.\n  ///\n  /// The optional \"caller\" UserId personalizes the resulting record for\n  /// various cases:\n  /// - When caller is not given, less information is non-null in result.\n  /// - When calling user is viewing their own profile,\n  ///   gives private and quasi-private info to them about their allowances.\n  /// - When calling user is viewing profile of another user,\n  ///   gives private info about super likes / abuse flags toward that use.\n  public query(msg) func getProfilePlus(caller: ?UserId, target: UserId): async ?ProfileInfoPlus {\n    do ? {\n      accessCheck(msg.caller, #view, #user target)!;\n      switch caller {\n        case null { getProfilePlus_(null, target)! };\n        case (?callerUserName) {\n               // has private access to our caller view?\n               accessCheck(msg.caller, #update, #user callerUserName)!;\n               getProfilePlus_(?callerUserName, target)!\n             };\n      }\n    }\n  };\n\n  func filterOutAbuseVideos(videos: [VideoId]) : ?[VideoId] {\n    do ? {\n      let nonAbuse = Buffer.Buffer<VideoId>(0);\n      for (v in videos.vals()) {\n        let flags = state.abuseFlagVideos.get1Size(v);\n        if (flags < Param.contentModerationThreshold) {\n          nonAbuse.add(v)\n        }\n      };\n      nonAbuse.toArray()\n    }\n  };\n\n  func filterOutAbuseUsers(users: [UserId]) : ?[UserId] {\n    do ? {\n      let nonAbuse = Buffer.Buffer<UserId>(0);\n      for (u in users.vals()) {\n        let flags = state.abuseFlagUsers.get1Size(u);\n        if (flags < Param.contentModerationThreshold) {\n          nonAbuse.add(u)\n        }\n      };\n      nonAbuse.toArray()\n    }\n  };\n\n  func getNonAbuseVideos(caller: ?UserId, videos: [VideoId]) : ?[VideoInfo] {\n    do ? {\n      let nonAbuse = Buffer.Buffer<VideoInfo>(0);\n      for (v in videos.vals()) {\n        let flags = state.abuseFlagVideos.get1Size(v);\n        if (flags < Param.contentModerationThreshold) {\n          nonAbuse.add(getVideoInfo_(caller, v)!)\n        }\n      };\n      nonAbuse.toArray()\n    }\n  };\n\n  func getNonAbuseProfiles(users: [UserId]) : ?[ProfileInfo] {\n    do ? {\n      let nonAbuse = Buffer.Buffer<ProfileInfo>(0);\n      for (u in users.vals()) {\n        let flags = state.abuseFlagUsers.get1Size(u);\n        if (flags < Param.contentModerationThreshold) {\n          nonAbuse.add(getProfileInfo_(u)!)\n        }\n      };\n      nonAbuse.toArray()\n    }\n  };\n\n  func computeAllowance_(limitPerRecentDuration : Nat,\n                         collectEvent : State.Event.Event -> Bool,\n  ) : Types.AllowanceBalance {\n    if (limitPerRecentDuration == 0) {\n      #zeroForever\n    } else {\n      let now = timeNow_();\n      let matches = collectLogMatches(collectEvent);\n      if (matches.size() < limitPerRecentDuration) {\n        #nonZero (limitPerRecentDuration - matches.size()) // total remaining.\n      } else {\n        // assert invariant: we do not exceed the limit.\n        assert matches.size() == limitPerRecentDuration;\n        let leastRecentTime = matches[matches.size() - 1].time;\n        #zeroUntil (leastRecentTime + Param.recentPastDuration) // total wait.\n      }\n    }\n  };\n\n  // targetId -- for hashing the targets of abuse flags\n  func targetText(target : Types.ActionTarget) : Text {\n    switch target {\n    case (#video(i)) \"#video=\" # i;\n    case (#user(i)) \"#user=\" # i;\n    case _ { loop { assert false } };\n    }\n  };\n\n  // targetHash -- for collecting sets of targets, and doing set operations.\n  func targetHash(target : Types.ActionTarget) : Hash.Hash {\n    Text.hash(targetText(target))\n  };\n\n  func targetEqual(targ1 : Types.ActionTarget, targ2 : Types.ActionTarget) : Bool {\n    targ1 == targ2\n  };\n\n  func getUserAllowances_(user: UserId) : Types.UserAllowances {\n    {\n      abuseFlags = do {\n        let targets = TrieMap.TrieMap<Types.ActionTarget, Bool>(targetEqual, targetHash);\n        computeAllowance_(\n          Param.maxRecentAbuseFlags,\n          // true when we INCLUDE an event in the total\n          func (ev: State.Event.Event) : Bool {\n            switch (ev.kind) {\n            case (#abuseFlag(af)) {\n                   if (af.reporter != user) { return false };\n                   switch (targets.get(af.target)) {\n                     case null {\n                            targets.put(af.target, af.flag);\n                            af.flag\n                          };\n                     case (?b) { b }\n                   }};\n            case _ { false };\n            }\n          },\n        )};\n\n      superLikes = do {\n        let targets = TrieMap.TrieMap<Types.ActionTarget, Bool>(targetEqual, targetHash);\n        computeAllowance_(\n          Param.maxRecentSuperLikes,\n          func (ev: State.Event.Event) : Bool {\n            switch (ev.kind) {\n            case (#superLikeVideo(slv)) {\n                   if (slv.source != user) { return false };\n                   switch (targets.get(#video(slv.target))) {\n                     case null {\n                            targets.put(#video(slv.target), slv.superLikes);\n                            slv.superLikes\n                          };\n                     case (?b) { b }\n                   }};\n            case _ { false };\n            }\n            }\n        )};\n    }\n  };\n\n  func getProfilePlus_(caller: ?UserId, userId: UserId): ?ProfileInfoPlus {\n    do ? {\n      let profile = state.profiles.get(userId)!;\n      {\n        userName = profile.userName;\n        following = getNonAbuseProfiles(state.follows.get0(userId))!;\n        followers = getNonAbuseProfiles(state.follows.get1(userId))!;\n        likedVideos = getNonAbuseVideos(caller, state.likes.get0(userId))!;\n        uploadedVideos = getNonAbuseVideos(caller, state.uploaded.get0(userId))!;\n        hasPic = false;\n        rewards = state.rewards.get(userId)!;\n        abuseFlagCount = state.abuseFlagUsers.get1Size(userId) ; // count total for userId.\n        viewerHasFlagged = do ? { // if caller is non-null,\n          state.abuseFlagUsers.isMember(caller!, userId) ; // check if we are there.\n        };\n        allowances = do ? { if (caller! == userId) {\n          getUserAllowances_(caller!)\n        } else { null! } };\n      }\n    }\n  };\n\n  public query(msg) func getProfiles() : async ?[ProfileInfo] {\n    do ? {\n      accessCheck(msg.caller, #admin, #all)!;\n      let b = Buffer.Buffer<ProfileInfo>(0);\n      for ((p, _) in state.profiles.entries()) {\n        b.add(getProfileInfo_(p)!)\n      };\n      b.toArray()\n    }\n  };\n\n  public query(msg) func getVideos() : async ?[VideoInfo] {\n    do ? {\n      accessCheck(msg.caller, #admin, #all)!;\n      let b = Buffer.Buffer<VideoInfo>(0);\n      for ((v, _) in state.videos.entries()) {\n        b.add(getVideoInfo_(null, v)!)\n      };\n      b.toArray()\n    }\n  };\n\n  public query(msg) func getProfilePic(userId : UserId) : async ?ProfilePic {\n    do ? {\n      accessCheck(msg.caller, #view, #user userId)!;\n      state.profilePics.get(userId)!\n    }\n  };\n\n  public shared(msg) func putRewards(\n    receiver : UserId,\n    amount : Nat\n  ) : async ?() {\n    do ? {\n      accessCheck(msg.caller, #admin, #user receiver)!;\n      let bal = state.rewards.get(receiver)!;\n      state.rewards.put(receiver, bal + amount);\n    }\n  };\n\n  public shared(msg) func putRewardTransfer(\n    sender : UserId,\n    receiver : UserId,\n    amount : Nat\n  ) : async ?() {\n    do ? {\n      accessCheck(msg.caller, #update, #user sender)!;\n      putRewardTransfer_(sender, receiver, amount)!\n    }\n  };\n\n  func putRewardTransfer_(sender : UserId,\n                          receiver : UserId, amount : Nat) : ?() {\n    do ? {\n      let balSrc = state.rewards.get(sender)!;\n      let balTgt = state.rewards.get(receiver)!;\n      if (balSrc >= amount) {\n        state.rewards.put(sender, balSrc - amount);\n        state.rewards.put(receiver, balTgt + amount);\n\n        logEvent(#rewardPointTransfer({sender = sender; receiver = receiver; amount = amount}));\n        state.messages.put(receiver,\n           { id = state.eventCount;\n             time = timeNow_();\n             event = #transferReward {\n               rewards = amount;\n             }\n           });\n\n      } else { return null }\n    }\n  };\n\n  public shared(msg) func putProfilePic(userId : UserId, pic : ?ProfilePic) : async ?() {\n    do ? {\n      accessCheck(msg.caller, #update, #user userId)!;\n      switch pic {\n      case (?pic) { state.profilePics.put(userId, pic) };\n      case null { ignore state.profilePics.remove(userId) };\n      }\n    }\n  };\n\n  func getVideoResult(i : VideoId) : ?VideoResult {\n    do ? {\n      (getVideoInfo_(null, i)!, state.videoPics.get(i))\n    }\n  };\n\n  func getUserUploaded(userId : UserId, limit : ?Nat) : ?VideoResults {\n    do ? {\n      let buf = Buffer.Buffer<VideoResult>(0);\n      for (vid in state.uploaded.get0(userId).vals()) {\n        buf.add((getVideoResult vid)!)\n      };\n      buf.toArray()\n    }\n  };\n\n  func getFeedVideos_(userId : UserId, limit : ?Nat) : ?VideoResults {\n    do ? {\n      let vids = HashMap.HashMap<Text, ()>(0, Text.equal, Text.hash);\n      let _ = state.profiles.get(userId)!; // assert userId exists\n      let buf = Buffer.Buffer<VideoResult>(0);\n      let followIds = state.follows.get0(userId);\n      label loopFollows\n      for (i in followIds.vals()) {\n        switch limit { case null { }; case (?l) { if (buf.size() == l) { break loopFollows } } };\n        let vs = getUserUploaded(i, limit)!;\n        for ((vi, vp) in vs.vals()) {\n          if (vids.get(vi.videoId) == null) {\n            vids.put(vi.videoId, ());\n            buf.add((vi, vp));\n          }\n        }\n      };\n      label loopAll\n      for ((vid, v) in state.videos.entries()) {\n        switch limit { case null { }; case (?l) { if (buf.size() == l) { break loopAll } } };\n        if (vids.get(vid) == null) {\n            vids.put(vid, ());\n            let vPic = state.videoPics.get(vid);\n            let vi = getVideoInfo_(?userId, vid)!;\n            buf.add((vi, vPic));\n        }\n      };\n      buf.toArray()\n    }\n  };\n\n  public query(msg) func getFeedVideos(userId : UserId, limit : ?Nat) : async ?VideoResults {\n    do ? {\n      // privacy check: because we personalize the feed (example is abuse flag information).\n      accessCheck(msg.caller, #update, #user userId)!;\n      getFeedVideos_(userId, limit)!\n    }\n  };\n\n  public query(msg) func getProfileVideos(i : UserId, limit : ?Nat) : async ?VideoResults {\n    do ? {\n      accessCheck(msg.caller, #view, #user i)!;\n      let buf = Buffer.Buffer<VideoResult>(0);\n      let vs = getUserUploaded(i, limit)!;\n      for (v in vs.vals()) {\n        buf.add(v)\n      };\n      buf.toArray()\n    }\n  };\n\n  public query(msg) func getSearchVideos(userId : UserId, terms : [Text], limit : ?Nat) : async ?VideoResults {\n    do ? {\n      accessCheck(msg.caller, #view, #user userId)!;\n      getFeedVideos_(userId, limit)!;\n    }\n  };\n\n  // check if adding the source-target pair \"now\" in the log is valid.\n  // needed here (backend logic) and by front-end logic, when rendering enabled/disabled button status for superLike controls.\n  func getSuperLikeValidNow_(source : UserId, target : VideoId) : Bool {\n    let notRecent = timeNow_() - Param.recentPastDuration;\n    let superLiked = HashMap.HashMap<Text, Bool>(0, Text.equal, Text.hash);\n    superLiked.put(target, true);\n    var count = 1;\n\n    label hugeLog\n    for (ev in state.eventLog.revVals()) {\n      if(ev.time <= notRecent){ break hugeLog };\n      switch (ev.kind) {\n        case (#superLikeVideo(sl)) {\n               if(sl.source == source and superLiked.get(sl.target) == null){\n                   superLiked.put(sl.target, sl.superLikes);\n                   if (sl.superLikes) {\n                       count += 1;\n                   };\n               }\n             };\n        case _ { };\n      };\n    };\n\n    count <= Param.maxRecentSuperLikes;\n  };\n\n  func videoIsViral(videoId : VideoId) : Bool {\n    Option.isSome(do ? {\n          let v = state.videos.get(videoId)!;\n          v.viralAt!\n    })\n  };\n\n  /// Collect \"recent events\" that match from the log.\n  ///\n  /// Visits events and orders array as most-to-least recent matching events.\n  /// (Most recent match is first visited and first in output, if any.\n  /// Least recent match is last visited and last in output, if any.)\n  ///\n  /// Generalizes checkEmitVideoViral_.\n  ///\n  /// This is \"efficient enough\" because we never check the full log,\n  /// and we intend to accelerate this operation further with\n  /// more pre-emptive caching of what we learn from doing this linear scan.\n  /// (Util this linear scan is too slow, let's avoid the complexity of more caching.)\n  func collectLogMatches(\n    collectEvent : State.Event.Event -> Bool,\n  ) : [State.Event.Event] {\n    let now = timeNow_();\n    let notRecent = now - Param.recentPastDuration;\n    let matches = Buffer.Buffer<State.Event.Event>(0);\n    label hugeLog\n    for (ev in state.eventLog.revVals()) {\n      if(ev.time <= notRecent){ break hugeLog };\n      if (collectEvent(ev)) {\n        matches.add(ev)\n      }\n    };\n    matches.toArray()\n  };\n\n  // check if we need to emit viral video signal to CanCan logic.\n  func checkEmitVideoViral_(video : VideoId) {\n    let vinfo = Option.unwrap(state.videos.get(video));\n    if (Option.isSome(vinfo.viralAt)) {\n        return;\n    };\n\n    let now = timeNow_();\n    let notRecent = now - Param.recentPastDuration;\n    let superLiked = HashMap.HashMap<Text, Bool>(0, Text.equal, Text.hash);\n    let superLikers = Buffer.Buffer<State.Event.ViralVideoSuperLiker>(0);\n\n    label hugeLog\n    for (ev in state.eventLog.revVals()) {\n      if(ev.time <= notRecent){ break hugeLog };\n      switch (ev.kind) {\n        case (#superLikeVideo(sl)) {\n               if(sl.target == video and superLiked.get(sl.source) == null) {\n                   superLiked.put(sl.source, sl.superLikes);\n                   // The last sl.superLikes decide whether the user eventually liked the video or not\n                   if (sl.superLikes) {\n                       superLikers.add({ user = sl.source ; time = ev.time });\n                   };\n               }\n             };\n        case _ { };\n      };\n    };\n\n    if(superLikers.size() >= Param.superLikeViralThreshold) {\n        state.videos.put(video,\n                         {\n                             userId = vinfo.userId ;\n                             uploadedAt = vinfo.uploadedAt ;\n                             viewCount = vinfo.viewCount ;\n                             createdAt = vinfo.createdAt ;\n                             viralAt = ?now;\n                             caption = vinfo.caption ;\n                             tags = vinfo.tags ;\n                             name = vinfo.name ;\n                             chunkCount = vinfo.chunkCount ;\n                         });\n        /*\n        state.eventLog.add({time=now;\n                            kind=#emitSignal(\n                              #viralVideo{\n                                  video=video;\n                                  uploader=vinfo.userId;\n                                  superLikers=superLikers.toArray()}\n                            )});*/\n        let score = Option.get(state.rewards.get(vinfo.userId), 0);\n        state.rewards.put(vinfo.userId, score + Param.rewardsForUploader);\n        state.eventCount += 1;\n        state.messages.put(vinfo.userId,\n                           { id = state.eventCount;\n                             time = now;\n                             event = #uploadReward {\n                                 rewards = Param.rewardsForUploader;\n                                 videoId = video;\n                             }\n                           });\n        for (id in superLikers.vals()) {\n            let score = Option.get(state.rewards.get(id.user), 0);\n            state.rewards.put(id.user, score + Param.rewardsForSuperliker);\n            state.eventCount += 1;\n            state.messages.put(id.user,\n                               { id = state.eventCount;\n                                 time = now;\n                                 event = #superlikerReward {\n                                     rewards = Param.rewardsForSuperliker;\n                                     videoId = video;\n                                 }\n                               });\n        };\n    }\n  };\n\n  public query(msg) func getMessages(user: UserId) : async ?[Types.Message] {\n    do ? {\n      accessCheck(msg.caller, #view, #user user)!;\n      state.messages.get0(user)\n    }\n  };\n\n  public query(msg) func isDropDay() : async ?Bool {\n    do ? {\n      accessCheck(msg.caller, #view, #pubView)!;\n      let now = timeNow_();\n      now % (Param.dropDayDuration + Param.dropDayNextDuration) < Param.dropDayDuration\n    }\n  };\n\n  public query(msg) func getSuperLikeValidNow(source : UserId, target : VideoId) : async ?Bool {\n    do ? {\n      accessCheck(msg.caller, #view, #user target)!;\n      getSuperLikeValidNow_(source, target)\n    }\n  };\n\n  public query(msg) func getIsSuperLiker(source : UserId, target : VideoId) : async ?Bool {\n    do ? {\n      accessCheck(msg.caller, #view, #user target)!;\n      state.superLikes.isMember(source, target)\n    }\n  };\n\n  func putSuperLike_(userId : UserId, videoId : VideoId, superLikes_ : Bool) : ?() {\n    do ? {\n      let _ = state.videos.get(videoId)!; // assert that the videoId is valid\n      if superLikes_ {\n        if (getSuperLikeValidNow_(userId, videoId)) {\n          state.superLikes.put(userId, videoId);\n          logEvent(#superLikeVideo({ source = userId ;\n                                     target = videoId ;\n                                     superLikes = true }\n                   ));\n          checkEmitVideoViral_(videoId);\n        } else {\n          logEvent(#superLikeVideoFail({ source = userId ;\n                                         target = videoId }));\n          return null // fail\n        }\n      } else {\n        state.superLikes.delete(userId, videoId);\n        logEvent(#superLikeVideo({ source = userId ;\n                                   target = videoId ;\n                                   superLikes = false }));\n      }\n    }\n  };\n\n  public shared(msg) func putSuperLike\n    (userId : UserId, videoId : VideoId, willSuperLike : Bool) : async ?() {\n    do ? {\n      accessCheck(msg.caller, #update, #user userId)!;\n      putSuperLike_(userId, videoId, willSuperLike)!\n    }\n  };\n\n  public shared(msg) func putProfileVideoLike\n    (userId : UserId, videoId : VideoId, willLike_ : Bool) : async ?() {\n    do ? {\n      accessCheck(msg.caller, #update, #user userId)!;\n      if willLike_ {\n        state.likes.put(userId, videoId);\n      } else {\n        state.likes.delete(userId, videoId)\n      };\n      logEvent(#likeVideo({ source = userId ;\n                            target = videoId ;\n                            likes = willLike_ }));\n    }\n  };\n\n  func putProfileFollow_\n    (userId : UserId, followedBy : UserId, follows : Bool) : ?() {\n    if (userId == followedBy) { return null };\n    if follows {\n      state.follows.put(userId, followedBy)\n    } else {\n      state.follows.delete(userId, followedBy)\n    };\n    ?()\n  };\n\n  public shared(msg) func putProfileFollow\n    (userId : UserId, toFollow : UserId, follows : Bool) : async ?() {\n    do ? {\n      accessCheck(msg.caller, #update, #user userId)!;\n      putProfileFollow_(userId, toFollow, follows)!\n    }\n  };\n\n  // internal function for adding metadata\n  func createVideo_(i : VideoInit) : ?VideoId {\n    let now = timeNow_();\n    let videoId = i.userId # \"-\" # i.name # \"-\" # (Int.toText(now));\n    switch (state.videos.get(videoId)) {\n    case (?_) { /* error -- ID already taken. */ null };\n    case null { /* ok, not taken yet. */\n           state.videos.put(videoId,\n                            {\n                              videoId = videoId;\n                              userId = i.userId ;\n                              name = i.name ;\n                              createdAt = i.createdAt ;\n                              uploadedAt = now ;\n                              viralAt = null ;\n                              caption =  i.caption ;\n                              chunkCount = i.chunkCount ;\n                              tags = i.tags ;\n                              viewCount = 0 ;\n                            });\n           state.uploaded.put(i.userId, videoId);\n           logEvent(#createVideo({info = i}));\n           ?videoId\n         };\n    }\n  };\n\n  public shared(msg) func createVideo(i : VideoInit) : async ?VideoId {\n    do ? {\n      accessCheck(msg.caller, #update, #user(i.userId))!;\n      createVideo_(i)!\n    }\n  };\n\n  func getVideoInfo_ (caller : ?UserId, videoId : VideoId) : ?VideoInfo {\n    do ? {\n      let v = state.videos.get(videoId)!;\n      {\n        videoId = videoId;\n        pic = state.videoPics.get(videoId);\n        userId = v.userId ;\n        createdAt = v.createdAt ;\n        uploadedAt = v.uploadedAt ;\n        viralAt = v.viralAt ;\n        caption = v.caption ;\n        tags = v.tags ;\n        likes = state.likes.get1(videoId);\n        superLikes = state.superLikes.get1(videoId);\n        viewCount = v.viewCount ;\n        name = v.name ;\n        chunkCount = v.chunkCount ;\n        // This implementation makes public all users who flagged every video,\n        // but if that information should be kept private, get video info\n        // could return just whether the calling user flagged it.\n        viewerHasFlagged = do ? {\n          state.abuseFlagVideos.isMember(caller!, videoId) ;\n        };\n        abuseFlagCount = state.abuseFlagVideos.get1Size(videoId);\n      }\n    }\n  };\n\n  public query(msg) func getVideoInfo (caller : ?UserId, target : VideoId) : async ?VideoInfo {\n    do ? {\n      accessCheck(msg.caller, #view, #video target)!;\n      switch caller {\n        case null { getVideoInfo_(null, target)! };\n        case (?callerUserName) {\n               // has private access to our caller view?\n               accessCheck(msg.caller, #update, #user callerUserName)!;\n               getVideoInfo_(?callerUserName, target)!\n             };\n      }\n    }\n  };\n\n  public query(msg) func getVideoPic(videoId : VideoId) : async ?VideoPic {\n    do ? {\n      accessCheck(msg.caller, #view, #video videoId)!;\n      state.videoPics.get(videoId)!\n    }\n  };\n\n  public shared(msg) func putVideoInfo(videoId : VideoId, videoInit : VideoInit) : async ?() {\n    do ? {\n      accessCheck(msg.caller, #update, #video videoId)!;\n      let i = videoInit ;\n      let v = state.videos.get(videoId)!;\n      state.videos.put(videoId,\n                       {\n                         // some fields are \"immutable\", regardless of caller data:\n                         userId = v.userId ;\n                         uploadedAt = v.uploadedAt ;\n                         viewCount = v.viewCount ;\n                         videoId = videoId ;\n                         // -- above uses old data ; below is from caller --\n                         createdAt = i.createdAt ;\n                         viralAt = null;\n                         caption = i.caption ;\n                         tags = i.tags ;\n                         name = i.name ;\n                         chunkCount = i.chunkCount ;\n                       })\n    }\n  };\n\n  /// An abuse flag for a video occurs when a reporting user\n  /// sets or clears the abuse toggle in their UI for the video.\n  public shared (msg) func putAbuseFlagVideo\n    (reporter : UserId, target : VideoId, abuseFlag : Bool) : async ?() {\n    do ? {\n      accessCheck(msg.caller, #update, #user reporter)!;\n      logEvent(#abuseFlag({ reporter = reporter ;\n                            target = #video(target);\n                            flag = abuseFlag }));\n      if abuseFlag {\n        state.abuseFlagVideos.put(reporter, target)\n      } else {\n        state.abuseFlagVideos.delete(reporter, target)\n      };\n    }\n  };\n\n  /// An abuse flag for a user occurs when a reporting user\n  /// sets or clears the abuse toggle in their UI for the target user.\n  public shared(msg) func putAbuseFlagUser\n    (reporter : UserId, target : UserId, abuseFlag : Bool) : async ?() {\n    do ? {\n      accessCheck(msg.caller, #update, #user reporter)!;\n      logEvent(#abuseFlag({ reporter = reporter ;\n                            target = #user(target);\n                            flag = abuseFlag }));\n      if abuseFlag {\n        state.abuseFlagUsers.put(reporter, target)\n      } else {\n        state.abuseFlagUsers.delete(reporter, target)\n      }\n    }\n  };\n\n  public shared(msg) func putVideoPic(videoId : VideoId, pic : ?VideoPic) : async ?() {\n    do ? {\n      accessCheck(msg.caller, #update, #video videoId)!;\n      switch pic {\n      case (?pic) { state.videoPics.put(videoId, pic) };\n      case null {\n             switch (state.videoPics.remove(videoId)) {\n             case null { /* not found */ return null };\n             case _ { /* found and removed. */ };\n             }\n           };\n      }\n    }\n  };\n\n  func chunkId(videoId : VideoId, chunkNum : Nat) : ChunkId {\n    videoId # (Nat.toText(chunkNum))\n  };\n\n  public shared(msg) func putVideoChunk\n    (videoId : VideoId, chunkNum : Nat, chunkData : [Nat8]) : async ?()\n  {\n    do ? {\n      accessCheck(msg.caller, #update, #video videoId)!;\n      state.chunks.put(chunkId(videoId, chunkNum), chunkData);\n    }\n  };\n\n  public query(msg) func getVideoChunk(videoId : VideoId, chunkNum : Nat) : async ?[Nat8] {\n    do ? {\n      accessCheck(msg.caller, #view, #video videoId)!;\n      state.chunks.get(chunkId(videoId, chunkNum))!\n    }\n  };\n\n  func createTestData_(users : [UserId], videos : [(UserId, VideoId)]) : ?() {\n    do ? {\n      for (u in users.vals()) {\n        createProfile_(u, null, null)!;\n      };\n      for ((u, v) in videos.vals()) {\n        let _ = createVideo_(\n          {userId = u ;\n           name = v ;\n           createdAt = timeNow_() ;\n           chunkCount = 0;\n           caption = \"\";\n           tags = [ ];})!;\n      };\n    }\n  };\n\n  public shared(msg) func createTestData(users : [UserId], videos : [(UserId, VideoId)]) : async ?() {\n    do ? {\n      accessCheck(msg.caller, #admin, #all)!;\n      createTestData_(users, videos)!\n    }\n  };\n\n  public shared(msg) func putTestFollows(follows : [(UserId, UserId)]) : async ?() {\n    do ? {\n      accessCheck(msg.caller, #admin, #all)!;\n      for ((u, v) in follows.vals()) {\n        let _ = putProfileFollow_(u, v, true)!;\n      }\n    }\n  };\n\n  public query(msg) func getEventLog() : async ?[State.Event.Event] {\n    do ? {\n      accessCheck(msg.caller, #admin, #all)!;\n      Iter.toArray(state.eventLog.vals())\n    }\n  };\n\n  public query(msg) func getAccessLog() : async ?[Access.Log.Event.Event] {\n    do ? {\n      accessCheck(msg.caller, #admin, #all)!;\n      Iter.toArray(state.access.log.vals())\n    }\n  };\n\n  func doDemo_(script : [Demo.Command]) : Demo.Trace {\n    let trace = Buffer.Buffer<Demo.TraceCommand>(0);\n    let r = do ? {\n      for (cmd in script.vals()) {\n        switch cmd {\n        case (#reset(tm)) {\n               reset_(tm); // discards trace\n               trace.add({ command = cmd ;\n                           result = #ok });\n             };\n        case (#createTestData(td)) {\n               let _ = createTestData_(td.users, td.videos)!;\n               trace.add({ command = cmd ;\n                           result = #ok });\n             };\n        case (#putSuperLike(sl)) {\n               let _ = putSuperLike_(sl.userId, sl.videoId, sl.superLikes)!;\n               trace.add({ command = cmd ;\n                           result = #ok });\n             };\n        case (#putProfileFollow(pf)) {\n               let _ = putProfileFollow_(pf.userId, pf.toFollow, pf.follows)!;\n               trace.add({ command = cmd ;\n                           result = #ok });\n             };\n        case (#assertVideoFeed(vp)) {\n               let vs : [VideoResult] = getFeedVideos_(vp.userId, vp.limit)!;\n               let ids = Array.map<VideoResult, VideoId>\n               (vs, func(vr : VideoResult) : VideoId { vr.0.videoId });\n               let b = switch (vp.videosPred) {\n                 case (#equals(expected)) {\n                        Array.equal<VideoId>(ids, expected, Text.equal)\n                      };\n                 case (#containsAll(members)) {\n                        Base.Array.containsAll<VideoId>(ids, members, Text.equal)\n                      };\n               };\n               if b {\n                 trace.add({ command = cmd ;\n                             result = #ok });\n               } else {\n                 trace.add({ command = cmd ;\n                             result = #err \"video feed assertion failed\"});\n               }\n             };\n        case (#assertVideoVirality(avv)) {\n               if (videoIsViral(avv.videoId) == avv.isViral) {\n                 trace.add({ command = cmd ;\n                             result = #ok });\n               } else {\n                 trace.add({ command = cmd ;\n                             result = #err \"viral assertion failed\"});\n               }\n             };\n        case (#putRewardTransfer(sra)) {\n              switch (putRewardTransfer_(sra.sender, sra.receiver, sra.amount)) {\n                case null {\n                   trace.add({ command = cmd ;\n                               result = #err \"insufficient rewards\"});\n                };\n                case (?()) {\n                   trace.add({ command = cmd ;\n                               result = #ok });\n                }\n              }\n           };\n        };\n      };\n    };\n    // from option monad (above) to trace monad (below)\n    let t = trace.toArray();\n    switch r {\n    case null { { status = #err ; trace = t } };\n    case _ { { status = #ok ; trace = t } };\n    }\n  };\n\n  public shared(msg) func doDemo(script : [Demo.Command]) : async ?Demo.Trace {\n    do ? {\n      accessCheck(msg.caller, #admin, #all)!;\n      doDemo_(script)\n    }\n  };\n}\n","cancan/service/Demo/Can30_VideoRecommendations.mo":"import Demo \"../../backend/Demo\";\nimport Types \"../../backend/Types\";\n\nmodule {\n  public let allVideos : [Types.VideoId] = [\n    \"alice-dog-0\",\n    \"bob-fish-0\",\n    \"cathy-bunny-0\",\n    \"dexter-hampster-0\",\n    \"esther-weasel-0\",\n  ];\n\n  public let demoScript : [Demo.Command] = [\n    #reset(#script 0), // clear CanCan state and set timeMode to #script.\n    #createTestData{\n      users  = [\"alice\", \"bob\",\n                \"cathy\", \"dex\", \"esther\"];\n      videos = [\n        (\"alice\", \"dog\"),\n        (\"bob\", \"fish\"),\n        (\"cathy\", \"bunny\"),\n        (\"dexter\", \"hampster\"),\n        (\"esther\", \"weasel\"),\n      ];\n    },\n    #putProfileFollow{\n      userId = \"alice\";\n      toFollow = \"cathy\";\n      follows = true;\n    },\n    #putProfileFollow{\n      userId = \"cathy\";\n      toFollow = \"alice\";\n      follows = true;\n    },\n    #assertVideoFeed{\n      userId = \"alice\";\n      limit = ?1;\n      videosPred =\n        #equals([\"cathy-bunny-0\"]);\n    },\n    #assertVideoFeed{\n      userId = \"cathy\";\n      limit = ?1;\n      videosPred =\n        #equals([\"alice-dog-0\"]);\n    },\n    #assertVideoFeed{\n      userId = \"alice\";\n      limit = null;\n      videosPred =\n        #containsAll allVideos;\n    },\n    #assertVideoFeed{\n      userId = \"bob\";\n      limit = null;\n      videosPred =\n        #containsAll allVideos;\n    },\n  ];\n}\n","cancan/service/Demo/Can32_ViralEvent.mo":"import Demo \"../../backend/Demo\";\n\nmodule {\n  public let demoScript : [Demo.Command] = [\n    #reset(#script 0), // clear CanCan state and set timeMode to #script.\n    #createTestData{\n      users  = [\"alice\", \"bob\",\n                \"cathy\", \"dex\", \"esther\"];\n      videos = [\n        (\"alice\", \"dog0\"),\n        (\"alice\", \"dog1\"),\n        (\"alice\", \"dog2\"),\n        (\"alice\", \"dog3\"),\n        (\"alice\", \"dog4\"),\n\n        (\"bob\", \"fish0\"),\n        (\"bob\", \"fish1\"),\n        (\"bob\", \"fish2\"),\n        (\"bob\", \"fish3\"),\n        (\"bob\", \"fish4\"),\n        \n        (\"cathy\", \"bunny0\"),\n        (\"cathy\", \"bunny1\"),\n        (\"cathy\", \"bunny2\"),\n        (\"cathy\", \"bunny3\"),\n        (\"cathy\", \"bunny4\"),\n        \n        (\"dexter\", \"hampster0\"),\n        (\"dexter\", \"hampster1\"),\n        (\"dexter\", \"hampster2\"),\n        (\"dexter\", \"hampster3\"),\n        (\"dexter\", \"hampster4\"),\n        \n        (\"esther\", \"weasel0\"),\n        (\"esther\", \"weasel1\"),\n        (\"esther\", \"weasel2\"),\n        (\"esther\", \"weasel3\"),\n        (\"esther\", \"weasel4\"),\n      ];\n    },\n    #putSuperLike{\n      userId  = \"alice\";\n      videoId = \"bob-fish0-0\";\n      superLikes = true;\n    },\n    #putSuperLike{\n      userId  = \"bob\";\n      videoId = \"bob-fish0-0\";\n      superLikes = true;\n    },\n    #putSuperLike{\n      userId  = \"cathy\";\n      videoId = \"bob-fish0-0\";\n      superLikes = true;\n    },\n    #putSuperLike{\n      userId  = \"dexter\";\n      videoId = \"bob-fish0-0\";\n      superLikes = true;\n    },\n    #assertVideoVirality{\n      videoId = \"bob-fish0-0\";\n      isViral = false;\n    },\n    #putSuperLike{\n      userId  = \"esther\";\n      videoId = \"bob-fish0-0\";\n      superLikes = true;\n    },\n    #assertVideoVirality{\n      videoId = \"bob-fish0-0\";\n      isViral = true;\n    },\n  ];\n}\n"}