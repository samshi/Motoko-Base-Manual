{"https://github.com/ninegua/ic-logger/blob/main/src/Logger.mo":"@samshi\nimport Array \"mo:base/Array\";\nimport Buffer \"mo:base/Buffer\";\nimport Deque \"mo:base/Deque\";\nimport List \"mo:base/List\";\nimport Nat \"mo:base/Nat\";\nimport Option \"mo:base/Option\";\n\nimport Matchers \"mo:matchers/Matchers\";\nimport T \"mo:matchers/Testable\";\nimport Suite \"mo:matchers/Suite\";\nimport Text \"mo:base/Text\";\nimport Iter \"mo:base/Iter\";\n\nmodule {\n  \n  public type Buckets<A> = Deque.Deque<[A]>;\n  public type Bucket<A> = List.List<A>;\n\n  public type State<A> = {\n    var buckets: Buckets<A>;     // Past buckets (left to right = newest to oldest)\n    var num_of_buckets: Nat;     // Number of past buckets\n    var bucket: Bucket<A>;       // Current bucket (tail to head = newest to oldest)\n    var num_of_lines: Nat;       // Number of lines in current bucket\n    var start_index: Nat;        // Start index of the first message in past buckets\n    bucket_size: Nat;\n  };\n\n  public type Stats = {\n    start_index: Nat;\n    bucket_sizes: [Nat];\n  };\n\n  public type View<A> = {\n    start_index: Nat;\n    messages: [A];\n  };\n  \n  let BUCKET_SIZE = 5000;        // Default bucket size\n\n  // Initialize an empty logger state with the given start_index and bucket_size.\n  public func new<A>(start_index: Nat, bucket_size: ?Nat) : State<A> {\n    {\n      var buckets : Buckets<A> = Deque.empty();\n      var num_of_buckets = 0;\n      var bucket : Bucket<A> = List.nil();\n      var num_of_lines = 0;\n      var start_index = start_index;\n      bucket_size = Option.get(bucket_size, BUCKET_SIZE);\n    }\n  };\n\n  // Convert a list to array (ordered from head to tail).\n  public func to_array<T>(list: List.List<T>, n: Nat) : [T] {\n    let buf = Buffer.Buffer<T>(n);\n    var l = list;\n    label LOOP loop {\n      switch (List.pop(l)) {\n        case (null, _) { break LOOP; };\n        case (?v, l_) { buf.add(v); l := l_; }\n      }\n    };\n    Array.tabulate<T>(n, func(i: Nat): T { buf.get(n - i - 1) })\n  };\n\n  public class Logger<A>(s : State<A>) {\n\n    // Move bucket into buckets\n    public func roll_over() {\n      s.buckets := Deque.pushBack(s.buckets, to_array(s.bucket, s.num_of_lines));\n      s.num_of_buckets := s.num_of_buckets + 1;\n      s.bucket := List.nil();\n      s.num_of_lines := 0;\n    };\n \n    // Add a set of messages to the log.\n    public func append(msgs: [A]) {\n       for (msg in msgs.vals()) {\n         s.bucket := List.push(msg, s.bucket);\n         s.num_of_lines := s.num_of_lines + 1;\n         if (s.num_of_lines >= s.bucket_size) {\n            roll_over()\n         }\n       }\n    };\n \n    // Return log stats, where:\n    //   start_index is the first index of log message.\n    //   bucket_sizes is the size of all buckets, from oldest to newest.\n    public func stats() : Stats {\n      var bucket_sizes = Array.init<Nat>(s.num_of_buckets + 1, 0);\n      var i = s.num_of_buckets;\n      bucket_sizes[i] := s.num_of_lines;\n      var bs = s.buckets;\n      label LOOP loop {\n        switch (Deque.popBack(bs)) {\n          case null { break LOOP; };\n          case (?(bs_, b)) {\n            i := i - 1;\n            bucket_sizes[i] := b.size();\n            bs := bs_;\n          }\n        }\n      };\n      { start_index = s.start_index; bucket_sizes = Array.freeze(bucket_sizes) }\n    };\n \n    // Return the messages between from and to indice (inclusive).\n    public func view(from: Nat, to: Nat) : View<A> {\n      assert(to >= from);\n      let buf = Buffer.Buffer<A>(to - from + 1);\n      var i = s.start_index;\n      var b = s.buckets;\n      label LOOP loop {\n        switch (Deque.popFront(b)) {\n          case null { break LOOP; };\n          case (?(lines, d)) {\n            let n = lines.size();\n            // is there intersection between [i, i + n] and [from, to]\n            if (i > to) { break LOOP; };\n            if (i + n > from) {\n              var k = if (i < from) { Nat.sub(from, i) } else { 0 };\n              let m = if (i + n > to) { Nat.sub(to + 1, i) } else { n };\n              while (k < m) {\n                buf.add(lines[k]);\n                k := k + 1;\n              }\n            };\n            i := i + n;\n            b := d;\n          }\n        }\n      };\n      if (i + s.num_of_lines > from and i <= to) {\n        let arr : [A] = to_array(s.bucket, s.num_of_lines); \n        var k = if (i < from) { Nat.sub(from, i) } else { 0 };\n        let m = if (i + s.num_of_lines > to) { Nat.sub(to + 1, i) } else { s.num_of_lines };\n        while (k < m) {\n          buf.add(arr[k]);\n          k := k + 1;\n        }\n      };\n      {\n        start_index = if (s.start_index > from) { s.start_index } else { from };\n        messages = buf.toArray();\n      }\n    };\n  \n    // Drop past buckets (oldest first).\n    public func pop_buckets(num: Nat) {\n      var i = 0;\n      label LOOP while (i < num) {\n        switch (Deque.popFront(s.buckets)) {\n          case null { break LOOP };\n          case (?(b, bs)) {\n            s.num_of_buckets := s.num_of_buckets - 1;\n            s.buckets := bs;\n            s.start_index := s.start_index + b.size();\n          };\n        };\n        i := i + 1;\n      }\n    }\n  };\n\n  type Suite = Suite.Suite;\n  public func test() : Suite {\n    let to_array_test =\n      Suite.suite(\"to_array\", [\n        Suite.test(\"empty\",\n          to_array<Nat>(List.nil(), 0), \n          Matchers.equals(T.array<Nat>(T.natTestable, []))),\n        Suite.test(\"singleton\",\n          to_array<Nat>(List.push(1, List.nil()), 1), \n          Matchers.equals(T.array<Nat>(T.natTestable, [1]))),\n        Suite.test(\"multiple\",\n          to_array<Nat>(List.push(2, List.push(1, List.nil())), 2), \n          Matchers.equals(T.array<Nat>(T.natTestable, [1, 2]))),\n        Suite.test(\"truncated to size\",\n          to_array<Nat>(List.push(3, List.push(2, List.push(1, List.nil()))), 2), \n          Matchers.equals(T.array<Nat>(T.natTestable, [2, 3]))),\n      ]);\n\n    let N = 10;\n    let S = 3;\n    let logger = Logger<Nat>(new(0, ?S));\n    let append_test = Suite.suite(\"append\", \n      Array.tabulate<Suite>(N, func(n: Nat): Suite {\n        logger.append([n]);\n        Suite.test(Text.concat(\"append/\", Nat.toText(n)),\n          logger.view(0, n).messages,\n          Matchers.equals(T.array<Nat>(T.natTestable, \n            Array.tabulate<Nat>(n + 1, func(x: Nat): Nat { x }))))\n      }));\n\n    let view_tests = Buffer.Buffer<Suite>(0);\n    for (i in Iter.range(0, N - 2)) {\n      for (j in Iter.range(i, N - 1)) {\n        view_tests.add(\n          Suite.test(Text.join(\"/\", Iter.fromArray([\"view\", Nat.toText(i), Nat.toText(j)])),\n            logger.view(i, j).messages,\n            Matchers.equals(T.array<Nat>(T.natTestable, \n              Array.tabulate(Nat.sub(j+1, i), func(x: Nat): Nat { x + i })))));\n      };\n    };\n    let view_test = Suite.suite(\"view\", view_tests.toArray());\n\n    let view_tests_after_pop = Buffer.Buffer<Suite>(0);\n    for (k in Iter.range(1,2)) {\n      logger.pop_buckets(1);\n      for (i in Iter.range(0, N - 2)) {\n        for (j in Iter.range(i, N - 1)) {\n          view_tests.add(\n            Suite.test(Text.join(\"/\", Iter.fromArray([\"view\", Nat.toText(i), Nat.toText(j)])),\n              logger.view(i, j).messages,\n              Matchers.equals(T.array<Nat>(T.natTestable, \n                if (j + 1 > k * S) {\n                  Array.tabulate(Nat.sub(j+1, Nat.max(i, S)), func(x: Nat): Nat { x + i })\n                } else { [] }\n              ))))\n        }\n      }\n    };\n    let view_test_after_pop = Suite.suite(\"view\", view_tests_after_pop.toArray());\n\n    Suite.suite(\"Test Logger\", [ to_array_test, append_test, view_test, view_test_after_pop ])\n  }\n}\n","https://github.com/aviate-labs/json.mo/blob/main/src/JSON.mo":"@samshi\nimport Char \"mo:base/Char\";\nimport HashMap \"mo:base/HashMap\";\nimport Iter \"mo:base/Iter\";\nimport List \"mo:base/List\";\nimport Text \"mo:base/Text\";\nimport Int \"mo:base/Int\";\n\nimport C \"mo:parser-combinators/Combinators\";\nimport L \"mo:parser-combinators/List\";\nimport P \"mo:parser-combinators/Parser\";\n\nmodule JSON {\n    public type ObjectMap = HashMap.HashMap<Text, JSON>;\n\n    public func emptyObjectMap() : ObjectMap {\n        HashMap.HashMap(0, Text.equal, Text.hash);\n    };\n\n    public type JSON = {\n        #Number : Int; // TODO: float\n        #String : Text;\n        #Array : [JSON];\n        #Object : HashMap.HashMap<Text, JSON>;\n        #Boolean : Bool;\n        #Null;\n    };\n\n    public func show(json : JSON) : Text {\n        switch (json) {\n            case (#Number(v)) { Int.toText(v); }; // debug_show returns \"+\" symbol\n            case (#String(v)) { \"\\\"\" # v # \"\\\"\"; };\n            case (#Array(v)) {\n                var s = \"[\";\n                for (i in v.vals()) {\n                    if (s != \"[\") { s #= \", \"; };\n                    s #= show(i);\n                };\n                s # \"]\";\n            };\n            case (#Object(v)) {\n                var s = \"{\";\n                for ((k, v) in v.entries()) {\n                    if (s != \"{\") { s #= \", \"; }; // avoid the first element\n                    s #= \"\\\"\" # k # \"\\\"\" # \": \" # show(v);\n                };\n                s # \"}\";\n            };\n            case (#Boolean(v)) {\n                if (v) { return \"true\"; };\n                \"false\";\n            };\n            case (#Null) { \"null\"; };\n        };\n    };\n\n    public func character() : P.Parser<Char, Char> {\n        let DQ = Char.fromNat32(0x22);\n        C.oneOf([\n            C.sat<Char>(func (c : Char) : Bool {\n                c != DQ and c != '\\\\';\n            }),\n            C.right(\n                C.Character.char('\\\\'),\n                C.map(\n                    C.Character.oneOf([\n                        DQ, '\\\\', '/', 'b', 'f', 'n', 'r', 't',\n                        // TODO: u hex{4}\n                    ]),\n                    func (c : Char) : Char {\n                        switch (c) {\n                            case ('b') { Char.fromNat32(0x08); };\n                            case ('f') { Char.fromNat32(0x0C); };\n                            case ('n') { Char.fromNat32(0x0A); };\n                            case ('r') { Char.fromNat32(0x0D); };\n                            case ('t') { Char.fromNat32(0x09); };\n                            case (_) { c; }\n                        };\n                    },\n                ),\n            ),\n        ]);\n    };\n\n    public func ignoreSpace<A>(\n        parserA : P.Parser<Char, A>,\n    ) : P.Parser<Char, A> {\n        C.right(\n            C.many(C.Character.space()),\n            parserA,\n        );\n    };\n\n    public class Parser() {\n        public func parse(t : Text) : ?JSON {\n            switch (valueParser()(L.fromIter(t.chars()))) {\n                case (null) { null; };\n                case (? (x, xs)) {\n                    switch (xs) {\n                        case (null) { ?x; };\n                        case (_) { null;  };\n                    };\n                };\n            }\n        };\n\n        func valueParser() : P.Parser<Char, JSON> {\n            C.bracket(\n                C.many(C.Character.space()),\n                C.oneOf([\n                    objectParser(),\n                    arrayParser(),\n                    stringParser,\n                    numberParser,\n                    boolParser,\n                    nullParser,\n                ]),\n                C.many(C.Character.space()),\n            );\n        };\n\n        func objectParser() : P.Parser<Char, JSON> {\n            C.map(\n                C.bracket(\n                    C.Character.char('{'),\n                    ignoreSpace(\n                        C.sepBy(\n                            C.seq(\n                                C.left(\n                                    ignoreSpace(string),\n                                    ignoreSpace(C.Character.char(':')),\n                                ),\n                                P.delay(valueParser),\n                            ),\n                            C.Character.char(','),\n                        ),\n                    ),\n                    C.Character.char('}'),\n                ),\n                func (t : List.List<(Text, JSON)>) : JSON {\n                    #Object(HashMap.fromIter(\n                        L.toIter(t),\n                        List.size(t),\n                        Text.equal,\n                        Text.hash,\n                    ));\n                },\n            );\n        };\n\n        func arrayParser() : P.Parser<Char, JSON> {\n            C.map(\n                C.bracket(\n                    C.Character.char('['),\n                    ignoreSpace(\n                        C.sepBy(\n                            P.delay(valueParser),\n                            C.Character.char(','),\n                        ),\n                    ),\n                    C.Character.char(']'),\n                ),\n                func (t : List.List<JSON>) : JSON {\n                    #Array(List.toArray(t));\n                },\n            );\n        };\n\n        let DQ = C.Character.char(Char.fromNat32(0x22));\n        let string : P.Parser<Char, Text> = C.map(\n            C.bracket(DQ, C.many(character()), DQ),\n            func (t : List.List<Char>) : Text {\n                Text.fromIter(L.toIter(t));\n            },\n        );\n        let stringParser : P.Parser<Char, JSON> = C.map(\n            string,\n            func (t : Text) : JSON {\n                #String(t);\n            },\n        );\n\n        let numberParser : P.Parser<Char, JSON> = C.map(\n            C.Int.int(),\n            func (i : Int) : JSON {\n                #Number(i);\n            },\n        );\n\n        let boolParser : P.Parser<Char, JSON> = C.map(\n            C.choose(\n                C.String.string(\"true\"),\n                C.String.string(\"false\"),\n            ),\n            func (t : Text) : JSON {\n                if (t == \"true\") return #Boolean(true);\n                #Boolean(false);\n            },\n        );\n\n        let nullParser : P.Parser<Char, JSON> = C.map(\n            C.String.string(\"null\"),\n            func (_ : Text) : JSON {\n                #Null;\n            },\n        );\n    };\n};\n","https://github.com/aviate-labs/uuid.mo/blob/main/src/Source.mo":"@samshi\nimport Array \"mo:base/Array\";\nimport Binary \"mo:encoding/Binary\";\nimport Int \"mo:base/Int\";\nimport IO \"mo:io/IO\";\nimport Nat8 \"mo:base/Nat8\";\nimport Nat16 \"mo:base/Nat16\";\nimport Nat32 \"mo:base/Nat32\";\nimport Nat64 \"mo:base/Nat64\";\nimport Time \"mo:base/Time\";\n\nimport UUID \"UUID\";\n\nmodule {\n\tpublic class Source(\n\t    rand : IO.Reader<Nat8>,\n\t    node : [Nat8],\n\t) {\n\t    if (node.size() != 6) assert(false);\n\n\t    private let lillian    : Nat64 = 2299160;          // Julian day of 15 Oct 1582.\n\t    private let unix       : Nat64 = 2440587;          // Julian day of 1 Jan 1970.\n\t    private let epoch      : Nat64 = unix - lillian;   // Days between epochs.\n\t    private let g1582      : Nat64 = epoch * 86400;    // Seconds between epochs.\n\t    private let g1582ns100 : Nat64 = g1582 * 10000000; // 100s of a nanoseconds between epochs.\n\t    \n\t    private var lastTime      : Nat64 = 0;\n\t    private var clockSequence : Nat16 = 0;\n\n\t    // Generates a new UUID.\n\t    public func new() : UUID.UUID {\n\t        let (now, clock) = time();\n\t        let low  = Nat32.fromNat(Nat64.toNat(now & 0xFFFFFFFF));\n\t        let mid  = Nat16.fromNat(Nat64.toNat((now >> 32) & 0xFFFF));\n\t        let high = Nat16.fromNat(Nat64.toNat((now >> 48) & 0x0FFF)) | 0x1000;\n\t        Array.flatten<Nat8>([\n\t            Binary.BigEndian.fromNat32(low),\n\t            Binary.BigEndian.fromNat16(mid),\n\t            Binary.BigEndian.fromNat16(high),\n\t            Binary.BigEndian.fromNat16(clock),\n\t            node,\n\t        ]);\n\t    };\n\n\t    private func time() : (Nat64, Nat16) {\n\t        let t = Nat64.fromNat(Int.abs(Time.now()));\n\t        if (clockSequence == 0) {\n\t            setClockSequence(null);\n\t        };\n\t        let now = t/100 + g1582ns100;\n\t        if (now <= lastTime) {\n\t            clockSequence := ((clockSequence + 1) & 0x3fff) | 0x8000;\n\t        };\n\t        lastTime := now;\n\t        (t, clockSequence);\n\t    };\n\n\t    // Sets the clock sequence to the lower 14 bits of seq, null generates a new clock sequence.\n\t    public func setClockSequence(seq : ?Nat16) {\n\t        var s : Nat16 = switch (seq) {\n\t            case (null) {\n\t                let bs = switch (rand.read(2)) {\n\t                    case (#ok(bs))  bs;\n\t                    case (#eof(bs)) bs;\n\t                    case (#err(_)) {\n\t                        assert(false); [];\n\t                    };\n\t                };\n\t                nat8to16(bs[0]) << 8 | nat8to16(bs[1]);\n\t            };\n\t            case (? s) { s; };\n\t        };\n\t        let oldSequence = clockSequence;\n\t        clockSequence := s & 0x3FFF | 0x8000;\n\t        if (oldSequence != clockSequence) {\n\t            lastTime := 0;\n\t        };\n\t    };\n\n\t    private func nat8to16(n : Nat8) : Nat16 {\n\t        Nat16.fromNat(Nat8.toNat(n));\n\t    };\n\t};\n};\n","https://github.com/AstroxNetwork/buy_me_coffee/blob/main/backend/main.mo":"@samshi\nimport Map \"mo:base/HashMap\";\nimport Text \"mo:base/Text\";\nimport Principal \"mo:base/Principal\";\nimport Nat64 \"mo:base/Nat64\";\nimport Nat8 \"mo:base/Nat8\";\nimport Nat32 \"mo:base/Nat32\";\nimport Error \"mo:base/Error\";\nimport List \"mo:base/List\";\nimport Option \"mo:base/Option\";\nimport Trie \"mo:base/Trie\";\nimport Result \"mo:base/Result\";\nimport Array \"mo:base/Array\";\n\n\nactor class BuyMeCoffee() =\n  this {\n\n  /**\n   * Types\n   */\n\n   type Error = {\n        #NotFound;\n        #AlreadyExists;\n        #NotAuthorized;\n        #WrongCaller;\n    };\n\n  // The type of a people identifier.\n  public type PeopleId = Nat32;\n  public type ID = Principal;\n  public type Wallet = Text;\n\n  // The type of a people.\n  public type People = {\n    name : Text;\n    id : ID;\n    wallet: Wallet;\n  };\n\n  public type PeopleUpdate = {\n    name : Text;\n    wallet: Wallet;\n  };\n\n  public type PeopleItem = {\n     people: People;\n     principal: ID;\n  };\n  /**\n   * Application State\n   */\n\n  // The people data store.\n  private stable var peoples : Trie.Trie<Principal, People> = Trie.empty();\n\n  /**\n   * High-Level API\n   */\n\n  // Create a people.\n  public shared(msg) func create(people : PeopleUpdate) : async Result.Result<People, Error> {\n\n    let callerId = msg.caller;\n\n    // if(Principal.isAnonymous(who)) {\n    //     return #err(#NotAuthorized);\n    // };\n    if(Principal.toText(callerId) == \"2vxsx-fae\") {\n        return #err(#NotAuthorized);\n    };\n\n\n    // Associate user profile with their principal\n    let thisGuy: People = {\n        name = people.name;\n        wallet = people.wallet;\n        id = callerId;\n    };\n\n    let (newPeoples, existing) = Trie.put(\n        peoples,           // Target trie\n        key(callerId),      // Key\n        Principal.equal,    // Equality checker\n        thisGuy\n    );\n\n    // If there is an original value, do not update\n    switch(existing) {\n        // If there are no matches, update profiles\n        case null {\n            peoples := newPeoples;\n            #ok(thisGuy);\n        };\n        // Matches pattern of type - opt Profile\n        case (? v) {\n            #err(#AlreadyExists);\n        };\n    };\n  };\n\n  // Read people\n  public query (msg) func read () : async Result.Result<People, Error> {\n      // Get caller principal\n      let callerId = msg.caller;\n\n      // Reject AnonymousIdentity\n      if(Principal.toText(callerId) == \"2vxsx-fae\") {\n          return #err(#NotAuthorized);\n      };\n\n      let result = Trie.find(\n          peoples,           //Target Trie\n          key(callerId),      // Key\n          Principal.equal     // Equality Checker\n      );\n      return Result.fromOption(result, #NotFound);\n  };\n\n  // Update profile\n  public shared(msg) func update (people : PeopleUpdate) : async Result.Result<People, Error> {\n      // Get caller principal\n      let callerId = msg.caller;\n\n      // Reject AnonymousIdentity\n      if(Principal.toText(callerId) == \"2vxsx-fae\") {\n          return #err(#NotAuthorized);\n      };\n\n      // Associate user profile with their principal\n      let thisGuy: People = {\n          name = people.name;\n          wallet = people.wallet;\n          id = callerId;\n      };\n\n      let result = Trie.find(\n          peoples,           //Target Trie\n          key(callerId),     // Key\n          Principal.equal           // Equality Checker\n      );\n\n      switch (result){\n          // Do not allow updates to profiles that haven't been created yet\n          case null {\n              #err(#NotFound)\n          };\n          case (? v) {\n              peoples := Trie.replace(\n                  peoples,           // Target trie\n                  key(callerId),      // Key\n                  Principal.equal,    // Equality checker\n                  ?thisGuy\n              ).0;\n              #ok(thisGuy);\n          };\n      };\n  };\n\n  // Delete profile\n  public shared(msg) func delete () : async Result.Result<Bool, Error> {\n      // Get caller principal\n      let callerId = msg.caller;\n\n      // Reject AnonymousIdentity\n      if(Principal.toText(callerId) == \"2vxsx-fae\") {\n          return #err(#NotAuthorized);\n      };\n\n      let result = Trie.find(\n          peoples,           //Target Trie\n          key(callerId),      // Key\n          Principal.equal     // Equality Checker\n      );\n\n      switch (result){\n          // Do not try to delete a profile that hasn't been created yet\n          case null {\n              #err(#NotFound);\n          };\n          case (? v) {\n              peoples := Trie.replace(\n                  peoples,           // Target trie\n                  key(callerId),     // Key\n                  Principal.equal,          // Equality checker\n                  null\n              ).0;\n              #ok(true);\n          };\n      };\n  };\n\n    public query func allPeople() : async [PeopleItem]{\n       Trie.toArray(\n                    peoples,\n                    func(k:Principal, v:People) : PeopleItem {\n                        {\n                            principal=k;\n                            people=v;\n                        }\n                    });\n    };\n\n  private func key(x : Principal) : Trie.Key<Principal> {\n      return { key = x; hash = Principal.hash(x) };\n  };\n\n\n\n};\n","https://github.com/aviate-labs/http.mo/blob/main/src/Query.mo":"@samshi\nimport Array \"mo:base/Array\";\nimport Iter \"mo:base/Iter\";\nimport Text \"mo:base/Text\";\n\nmodule {\n    public type Field = (\n        Text, // Field (e.g. name)\n        Text, // Value (e.g. quint)\n    );\n\n    /// Parses the given URL (and query strings).\n    public func parse(url : Text) : (Text, [Field]) {\n        let ps : [Text] = Iter.toArray(Text.split(url, #char('?')));\n        if (ps.size() != 2) return (url, []);\n\n        let qStr : [Text] = Iter.toArray(Text.split(ps[1], #char('&')));\n        let params = Array.init<Field>(qStr.size(), (\"\", \"\"));\n        for (i in qStr.keys()) {\n            let p : [Text] = Iter.toArray(Text.split(qStr[i], #char '='));\n            params[i] := switch(ps.size()) {\n                case (2) (p[0], p[1]);\n                case (_) (qStr[i], \"\");\n            };\n        };\n        return (ps[0], Array.freeze(params));\n    };\n}"}