modules.AssocList={"imports":{"List":"List"},"functions":{"AssocList":{"desc":"polymorphic association linked lists between keys and values","body":"public type AssocList<K, V> = List.List<(K, V)>;"},"find":{"desc":"// Find the value associated with a given key, or null if absent.","body":"public func find<K, V>(\n  al : AssocList<K, V>,\n  k : K,\n  k_eq : (K, K) -> Bool\n) : ?V {\n  func rec(al : AssocList<K, V>) : ?V {\n    label profile_assocList_find_rec : (?V)\n      switch (al) {\n        case (null) { label profile_assocList_find_end_fail : (?V)  { null } };\n        case (?((hd_k, hd_v), tl)) {\n          if (k_eq(k, hd_k)) {\n            label profile_assocList_find_end_success : (?V) {\n               ?hd_v\n            }\n          } else {\n            rec(tl)\n          }\n        };\n      }\n  };\n  label profile_assocList_find_begin : (?V) {\n    rec(al)\n  }\n}"},"replace":{"desc":"replace the value associated with a given key, or add it, if missing.\nreturns old value, or null, if no prior value existed.","body":"public func replace<K, V>(\n  al : AssocList<K, V>,\n  k : K,\n  k_eq : (K, K) -> Bool,\n  ov : ?V\n)\n: (AssocList<K, V>, ?V) {\n  func rec(al : AssocList<K, V>) : (AssocList<K, V>, ?V) {\n    switch (al) {\n      case (null) {\n        switch ov {\n          case (null) { (null, null) };\n          case (?v) { (?((k, v), null), null) };\n        }\n      };\n      case (?((hd_k, hd_v), tl)) {\n        if (k_eq(k, hd_k)) {\n          // if value is null, remove the key; otherwise, replace key's old value\n          // return old value\n          switch ov {\n            case (null) { (tl, ?hd_v) };\n            case (?v) { (?((hd_k, v), tl), ?hd_v) };\n          }\n        } else {\n          let (tl2, old_v) = rec(tl);\n          (?((hd_k, hd_v), tl2), old_v)\n          }\n      };\n    }\n  };\n  rec(al)\n}"},"diff":{"desc":"The entries of the final list consist of those pairs of\nthe left list whose keys are not present in the right list; the\n\"extra\" values of the right list are irrelevant.","body":"public func diff<K, V, W>(\n  al1 : AssocList<K, V>,\n  al2 : AssocList<K, W>,\n  keq : (K, K) -> Bool\n) : AssocList<K, V>  {\n  func rec(al1 : AssocList<K, V>) : AssocList<K, V> {\n    switch al1 {\n      case (null) { null };\n      case (?((k, v1), tl)) {\n        switch (find<K, W>(al2, k, keq)) {\n          case (null) { ?((k, v1), rec(tl)) };\n          case (?v2) { rec(tl)};\n        }\n      };\n    }\n  };\n  rec(al1)\n}"},"mapAppend":{"desc":"Transform and combine the entries of two association lists.","body":"public func mapAppend<K, V, W, X>(\n  al1 : AssocList<K, V>,\n  al2 : AssocList<K, W>,\n  vbin : (?V, ?W) -> X\n) : AssocList<K, X> =\n  label profile_assocList_mapAppend : AssocList<K, X> {\n    func rec(al1 : AssocList<K, V>, al2 : AssocList<K, W>) : AssocList<K, X> =\n      label profile_assocList_mapAppend_rec : AssocList<K,X> {\n        switch (al1, al2) {\n          case (null, null) { null };\n          case (?((k, v), al1_), _   ) { ?((k, vbin(?v, null)), rec(al1_, al2 )) };\n          case (null, ?((k, v), al2_)) { ?((k, vbin(null, ?v)), rec(null, al2_)) };\n        }\n      };\n    rec(al1, al2)\n  };"},"disjDisjoint":{"desc":"// Specialized version of `disj`, optimized for disjoint sub-spaces of keyspace (no matching keys).","body":"public func disjDisjoint<K, V, W, X>(\n  al1 : AssocList<K, V>,\n  al2 : AssocList<K, W>,\n  vbin : (?V, ?W) -> X)\n: AssocList<K, X> = label profile_assocList_disjDisjoint : AssocList<K,X>  {\n  mapAppend<K, V, W, X>(al1, al2, vbin)\n}"},"disj":{"desc":"This operation generalizes the notion of \"set union\" to finite maps.\nProduces a \"disjunctive image\" of the two lists, where the values of\nmatching keys are combined with the given binary operator.\n\nFor unmatched entries, the operator is still applied to\ncreate the value in the image.  To accomodate these various\nsituations, the operator accepts optional values, but is never\napplied to (null, null).","body":"public func disj<K, V, W, X>(\n  al1 : AssocList<K, V>,\n  al2 : AssocList<K, W>,\n  keq : (K, K) -> Bool,\n  vbin :(?V, ?W) -> X\n) : AssocList<K, X> {\n  func rec1(al1 : AssocList<K, V>) : AssocList<K, X> {\n    switch al1 {\n      case (null) {\n        func rec2(al2 : AssocList<K, W>) : AssocList<K, X> {\n          switch al2 {\n            case (null) { null };\n            case (?((k, v2), tl)) {\n              switch (find<K, V>(al1, k, keq)) {\n                case (null) { ?((k, vbin(null, ?v2)), rec2(tl)) };\n                case (?v1) { ?((k, vbin(?v1, ?v2)), rec2(tl)) };\n                }\n              };\n            }\n          };\n        rec2(al2)\n      };\n      case (?((k, v1), tl)) {\n        switch (find<K, W>(al2, k, keq)) {\n          case (null) { ?((k, vbin(?v1, null)), rec1(tl)) };\n          case (?v2) { /* handled above */ rec1(tl) };\n        }\n      };\n    }\n  };\n  rec1(al1)\n}"},"join":{"desc":"This operation generalizes the notion of \"set intersection\" to\nfinite maps.  Produces a \"conjuctive image\" of the two lists, where\nthe values of matching keys are combined with the given binary\noperator, and unmatched entries are not present in the output.","body":"public func join<K, V, W, X>(\n  al1 : AssocList<K, V>,\n  al2 : AssocList<K, W>,\n  keq : (K, K) -> Bool,\n  vbin : (V, W) -> X\n) : AssocList<K, X>  {\n  func rec(al1 : AssocList<K, V>) : AssocList<K, X> {\n    switch al1 {\n      case (null) { null };\n      case (?((k, v1), tl)) {\n        switch (find<K, W>(al2, k, keq)) {\n          case (null) { rec(tl) };\n          case (?v2) { ?((k, vbin(v1, v2)), rec(tl)) };\n        }\n      };\n    }\n  };\n  rec(al1)\n}"},"fold":{"desc":"Fold the entries based on the recursive list structure.","body":"public func fold<K, V, X>(\n  al : AssocList<K, V>,\n  nil : X,\n  cons : (K, V, X) -> X\n) : X {\n  func rec(al : AssocList<K, V>) : X {\n    switch al {\n      case null { nil };\n      case (?((k, v), t)) { cons(k, v, rec(t)) };\n    }\n  };\n  rec(al)\n}"}},"related":"","test":""}