modules.List={"imports":{"Array":"Array","IterType":"Iter","Option":"Option","Order":"Order","Result":"Result"},"functions":{"List":{"desc":"A singly-linked list consists of zero or more _cons cells_, wherein\neach cell contains a single list element (the cell's _head_), and a pointer to the\nremainder of the list (the cell's _tail_).","body":"public type List<T> = ?(T, List<T>);"},"nil":{"desc":"// Create an empty list.","body":"public func nil<T>() : List<T> = null;"},"isNil":{"desc":"// Check whether a list is empty and return true if the list is empty.","body":"public func isNil<T>(l : List<T>) : Bool {\n  switch l {\n    case null { true  };\n    case _ { false };\n  }\n}"},"push":{"desc":"Construct a list by pre-pending a value.\nThis function is similar to a `list.cons(item)` function.","body":"public func push<T>(x : T, l : List<T>) : List<T> = ?(x, l);"},"last":{"desc":"// Return the last element of the list, if present.","body":"public func last<T>(l : List<T>) : ?T {\n  switch l {\n    case null { null };\n    case (?(x, null)) { ?x };\n    case (?(_, t)) { last<T>(t) };\n  }\n}"},"pop":{"desc":"Treat the list as a stack.\nThis function combines the `head` and (non-failing) `tail` operations into one operation.","body":"public func pop<T>(l : List<T>) : (?T, List<T>) {\n  switch l {\n    case null { (null, null) };\n    case (?(h, t)) { (?h, t) };\n  }\n}"},"size":{"desc":"Return the length of the list.","body":"public func size<T>(l : List<T>) : Nat {\n  func rec(l : List<T>, n : Nat) : Nat {\n    switch l {\n      case null { n };\n      case (?(_, t)) { rec(t, n + 1) };\n    }\n  };\n  rec(l,0)\n}"},"get":{"desc":"Access any item in a list, zero-based.\n\nNOTE: Indexing into a list is a linear operation, and usually an\nindication that a list might not be the best data structure\nto use.","body":"public func get<T>(l : List<T>, n : Nat) : ?T {\n  switch (n, l) {\n    case (_, null) { null };\n    case (0, (?(h, t))) { ?h };\n    case (_, (?(_, t))) { get<T>(t, n - 1) };\n  }\n}"},"reverse":{"desc":"Reverses the list","body":"public func reverse<T>(l : List<T>) : List<T> {\n  func rec(l : List<T>, r : List<T>) : List<T> {\n    switch l {\n      case null { r };\n      case (?(h, t)) { rec(t, ?(h, r)) };\n    }\n  };\n  rec(l, null)\n}"},"iterate":{"desc":"Call the given function with each list element in turn.\n\nThis function is equivalent to the `app` function in Standard ML Basis,\nand the `iter` function in OCaml.","body":"public func iterate<T>(l : List<T>, f : T -> ()) {\n  switch l {\n    case null { () };\n    case (?(h, t)) { f(h); iterate<T>(t, f) };\n  }\n}"},"map":{"desc":"Call the given function on each list element and collect the results\nin a new list.","body":"public func map<T, S>(l : List<T>, f : T -> S) : List<S> {\n  switch l {\n    case null { null };\n    case (?(h, t)) { ?(f(h), map<T, S>(t, f)) };\n  }\n}"},"filter":{"desc":"Create a new list with only those elements of the original list for which\nthe given function (often called the _predicate_) returns true.","body":"public func filter<T>(l : List<T>, f : T -> Bool) : List<T> {\n  switch l {\n    case null { null };\n    case (?(h,t)) {\n      if (f(h)) {\n        ?(h,filter<T>(t, f))\n      } else {\n        filter<T>(t, f)\n      }\n    };\n  };\n}"},"partition":{"desc":"Create two new lists from the results of a given function (`f`).\nThe first list only includes the elements for which the given\nfunction `f` returns true and the second list only includes\nthe elements for which the function returns false.","body":"public func partition<T>(l : List<T>, f : T -> Bool) : (List<T>, List<T>) {\n  switch l {\n    case null { (null, null) };\n    case (?(h, t)) {\n      if (f(h)) { // call f in-order\n        let (l, r) = partition<T>(t, f);\n        (?(h, l), r)\n      } else {\n        let (l, r) = partition<T>(t, f);\n        (l, ?(h, r))\n      }\n    };\n  };\n}"},"mapFilter":{"desc":"Call the given function on each list element, and collect the non-null results\nin a new list.","body":"public func mapFilter<T,S>(l : List<T>, f : T -> ?S) : List<S> {\n  switch l {\n    case null { null };\n    case (?(h,t)) {\n      switch (f(h)) {\n        case null { mapFilter<T,S>(t, f) };\n        case (?h_){ ?(h_,mapFilter<T,S>(t, f)) };\n      }\n    };\n  };\n}"},"mapResult":{"desc":"Maps a Result-returning function over a List and returns either\nthe first error or a list of successful values.","body":"public func mapResult<A, R, E>(xs : List<A>, f : A -> Result.Result<R, E>) : Result.Result<List<R>, E> {\n  func go(xs : List<A>, acc : List<R>) : Result.Result<List<R>, E> {\n    switch xs {\n      case null { #ok(acc) };\n      case (?(head, tail)) {\n        switch (f(head)) {\n          case (#err(err)) { #err(err) };\n          case (#ok(ok)) { go(tail, ?(ok, acc)) };\n        };\n      };\n    }\n  };\n  Result.mapOk(go(xs, null), func (xs : List<R>) : List<R> = reverse(xs))\n}"},"append":{"desc":"Append the elements from one list to another list.","body":"public func append<T>(l : List<T>, m : List<T>) : List<T> {\n  revAppend(reverse(l), m);\n}"},"flatten":{"desc":"Concatenate a list of lists.\n\nIn some languages, this operation is also known as a `list join`.","body":"public func flatten<T>(l : List<List<T>>) : List<T> {\n  foldLeft<List<T>, List<T>>(l, null, func(a, b) { append<T>(a,b) });\n}"},"take":{"desc":"Returns the first `n` elements of the given list.\nIf the given list has fewer than `n` elements, this function returns\na copy of the full input list.","body":"public func take<T>(l : List<T>, n:Nat) : List<T> {\n  switch (l, n) {\n    case (_, 0) { null };\n    case (null, _) { null };\n    case (?(h, t), m) {?(h, take<T>(t, m - 1))};\n  }\n}"},"drop":{"desc":"Drop the first `n` elements from the given list.","body":"public func drop<T>(l : List<T>, n:Nat) : List<T> {\n  switch (l, n) {\n    case (l_, 0) { l_ };\n    case (null, _) { null };\n    case ((?(h, t)), m) { drop<T>(t, m - 1) };\n  }\n}"},"foldLeft":{"desc":"Fold the list left-to-right using the given function (`f`).","body":"public func foldLeft<T, S>(l : List<T>, a : S, f : (S, T) -> S) : S {\n  switch l {\n    case null { a };\n    case (?(h, t)) { foldLeft(t, f(a, h), f) };\n  };\n}"},"foldRight":{"desc":"Fold the list right-to-left using the given function (`f`).","body":"public func foldRight<T, S>(l : List<T>, a : S, f : (T, S) -> S) : S {\n  switch l {\n    case null { a };\n    case (?(h, t)) { f(h, foldRight<T,S>(t, a, f)) };\n  };\n}"},"find":{"desc":"Return the first element for which the given predicate `f` is true,\nif such an element exists.","body":"public func find<T>(l: List<T>, f:T -> Bool) : ?T {\n  switch l {\n    case null { null };\n    case (?(h, t)) { if (f(h)) { ?h } else { find<T>(t, f) } };\n  };\n}"},"some":{"desc":"Return true if there exists a list element for which\nthe given predicate `f` is true.","body":"public func some<T>(l : List<T>, f : T -> Bool) : Bool {\n  switch l {\n    case null { false };\n    case (?(h, t)) { f(h) or some<T>(t, f)};\n  };\n}"},"all":{"desc":"Return true if the given predicate `f` is true for all list\nelements.","body":"public func all<T>(l : List<T>, f : T -> Bool) : Bool {\n  switch l {\n    case null { true };\n    case (?(h, t)) { f(h) and all<T>(t, f) };\n  }\n}"},"merge":{"desc":"Merge two ordered lists into a single ordered list.\nThis function requires both list to be ordered as specified\nby the given relation `lte`.","body":"public func merge<T>(l1 : List<T>, l2 : List<T>, lte : (T, T) -> Bool) : List<T> {\n  switch (l1, l2) {\n    case (null, _) { l2 };\n    case (_, null) { l1 };\n    case (?(h1, t1), ?(h2, t2)) {\n      if (lte(h1, h2)) {\n        ?(h1, merge<T>(t1, l2, lte))\n      } else {\n        ?(h2, merge<T>(l1, t2, lte))\n      }\n    };\n  }\n}"},"compare":{"desc":"Compare two lists using lexicographic ordering specified by the given relation `lte`.","body":"public func compare<T>(l1 : List<T>, l2 : List<T>, compElm: (T, T) -> Order.Order) : Order.Order {\n  switch (l1, l2) {\n    case (null, null) { #equal };\n    case (null, _) { #less };\n    case (_, null) { #greater };\n    case (?(h1, t1), ?(h2, t2)) {\n      let hOrder = compElm(h1, h2);\n      if (Order.isEqual(hOrder)) {\n        compare<T>(t1, t2, compElm)\n      } else {\n        hOrder\n      }\n    };\n  };\n}"},"equal":{"desc":"Compare two lists for equality as specified by the given relation `eq` on the elements.\n\nThe function `isEq(l1, l2)` is equivalent to `lessThanEq(l1, l2) && lessThanEq(l2, l1)`,\nbut the former is more efficient.","body":"public func equal<T>(l1 : List<T>, l2 : List<T>, eq :(T, T) -> Bool) : Bool {\n  switch (l1, l2) {\n    case (null, null) { true };\n    case (null, _) { false };\n    case (_, null) { false };\n    case (?(h1, t1), ?(h2, t2)) { eq(h1, h2) and equal<T>(t1, t2, eq) };\n  }\n}"},"tabulate":{"desc":"Generate a list based on a length and a function that maps from\na list index to a list element.","body":"public func tabulate<T>(n : Nat, f : Nat -> T) : List<T> {\n  var i = 0;\n  var l : List<T> = null;\n  while (i < n) {\n    l := ?(f(i), l);\n    i += 1;\n  };\n  reverse(l);\n}"},"make":{"desc":"Create a list with exactly one element.","body":"public func make<X>(x : X) : List<X> = ?(x, null);"},"replicate":{"desc":"// Create a list of the given length with the same value in each position.","body":"public func replicate<X>(n : Nat, x : X) : List<X> {\n  var i = 0;\n  var l : List<X> = null;\n  while (i < n) {\n    l := ?(x, l);\n    i += 1;\n  };\n  l;\n}"},"zip":{"desc":"Create a list of pairs from a pair of lists.\n\nIf the given lists have different lengths, then the created list will have a\nlength equal to the length of the smaller list.","body":"public func zip<X, Y>(xs : List<X>, ys : List<Y>) : List<(X, Y)> =\n  zipWith<X, Y, (X, Y)>(xs, ys, func (x, y) { (x, y) });"},"zipWith":{"desc":"// Create a list in which elements are calculated from the function `f` and\ninclude elements occuring at the same position in the given lists.\n\nIf the given lists have different lengths, then the created list will have a\nlength equal to the length of the smaller list.","body":"public func zipWith<X, Y, Z>(\n  xs : List<X>,\n  ys : List<Y>,\n  f : (X, Y) -> Z\n) : List<Z> {\n  switch (pop<X>(xs)) {\n    case (null, _) { null };\n    case (?x, xt) {\n      switch (pop<Y>(ys)) {\n        case (null, _) { null };\n        case (?y, yt) {\n          push<Z>(f(x, y), zipWith<X, Y, Z>(xt, yt, f))\n        }\n      }\n    }\n  }\n}"},"split":{"desc":"Split the given list at the given zero-based index.","body":"public func split<X>(n : Nat, xs : List<X>) : (List<X>, List<X>) {\n  if (n == 0) {\n    (null, xs)\n  } else {\n    func rec(n : Nat, xs : List<X>) : (List<X>, List<X>) {\n      switch (pop<X>(xs)) {\n        case (null, _) {\n          (null, null)\n        };\n        case (?h, t) {\n          if (n == 1) {\n            (make<X>(h), t)\n          } else {\n            let (l, r) = rec(n - 1, t);\n            (push<X>(h, l), r)\n          }\n        }\n      }\n    };\n    rec(n, xs)\n  }\n}"},"chunks":{"desc":"Split the given list into chunks of length `n`.\nThe last chunk will be shorter if the length of the given list\ndoes not divide by `n` evenly.","body":"public func chunks<X>(n : Nat, xs : List<X>) : List<List<X>> {\n  let (l, r) = split<X>(n, xs);\n  if (isNil<X>(l)) {\n    null\n  } else {\n    push<List<X>>(l, chunks<X>(n, r))\n  }\n}"},"fromArray":{"desc":"Convert an array into a list.","body":"public func fromArray<A>(xs : [A]) : List<A> {\n  Array.foldRight<A, List<A>>(\n    xs, nil<A>(),\n    func (x : A, ys : List<A>) : List<A> {\n      push<A>(x, ys);\n    });\n}"},"fromVarArray":{"desc":"Convert a mutable array into a list.","body":"public func fromVarArray<A>(xs : [var A]) : List<A> =\n  fromArray<A>(Array.freeze<A>(xs));"},"toArray":{"desc":"// Create an array from a list.","body":"public func toArray<A>(xs : List<A>) : [A] {\n  let length = size<A>(xs);\n  var list = xs;\n  Array.tabulate<A>(length, func (i) {\n    let popped = pop<A>(list);\n    list := popped.1;\n    switch (popped.0) {\n      case null { loop { assert false } };\n      case (?x) x;\n    }\n  });\n}"},"toVarArray":{"desc":"Create a mutable array from a list.","body":"public func toVarArray<A>(xs : List<A>) : [var A] =\n  Array.thaw<A>(toArray<A>(xs));"},"toIter":{"desc":"// Create an iterator from a list.","body":"public func toIter<A>(xs : List<A>) : Iter.Iter<A> {\n  var state = xs;\n  object {\n    public func next() : ?A =\n      switch state {\n        case (?(hd, tl)) { state := tl; ?hd };\n        case _ null\n      }\n  }\n}"}},"other":";\n/// Append the elements from the reverse of one list to another list.\nfunc revAppend<T>(l : List<T>, m : List<T>) : List<T> {\n  switch l {\n    case null { m };\n    case (?(h, t)) { revAppend(t, ?(h, m)) };\n  }\n};","test":"import List \"mo:base/List\";\nimport Debug \"mo:base/Debug\";\nimport Int \"mo:base/Int\";\nimport Iter \"mo:base/Iter\";\nimport Result \"mo:base/Result\";\nimport Suite \"mo:matchers/Suite\";\nimport M \"mo:matchers/Matchers\";\nimport T \"mo:matchers/Testable\";\n\n\ntype X = Nat;\n\n  func opnatEq(a : ?Nat, b : ?Nat) : Bool {\n    switch (a, b) {\n    case (null, null) { true };\n    case (?aaa, ?bbb) { aaa == bbb };\n    case (_,    _   ) { false };\n    }\n  };\n  func opnat_isnull(a : ?Nat) : Bool {\n    switch a {\n    case (null) { true };\n    case (?aaa) { false };\n    }\n  };\n\n  // ## Construction\n  let l1 = List.nil<X>();\n  let l2 = List.push<X>(2, l1);\n  let l3 = List.push<X>(3, l2);\n\n  // ## Projection -- use nth\n  assert (opnatEq(List.get<X>(l3, 0), ?3));\n  assert (opnatEq(List.get<X>(l3, 1), ?2));\n  assert (opnatEq(List.get<X>(l3, 2), null));\n  //assert (opnatEq (hd<X>(l3), ?3));\n  //assert (opnatEq (hd<X>(l2), ?2));\n  //assert (opnat_isnull(hd<X>(l1)));\n\n  /*\n   // ## Projection -- use nth\n   assert (opnatEq(nth<X>(l3, 0), ?3));\n   assert (opnatEq(nth<X>(l3, 1), ?2));\n   assert (opnatEq(nth<X>(l3, 2), null));\n   assert (opnatEq (hd<X>(l3), ?3));\n   assert (opnatEq (hd<X>(l2), ?2));\n   assert (opnat_isnull(hd<X>(l1)));\n   */\n\n  // ## Deconstruction\n  let (a1, t1) = List.pop<X>(l3);\n  assert (opnatEq(a1, ?3));\n  let (a2, t2) = List.pop<X>(l2);\n  assert (opnatEq(a2, ?2));\n  let (a3, t3) = List.pop<X>(l1);\n  assert (opnatEq(a3, null));\n  assert (List.isNil<X>(t3));\n\n  // ## List functions\n  assert (List.size<X>(l1) == 0);\n  assert (List.size<X>(l2) == 1);\n  assert (List.size<X>(l3) == 2);\n\n  // ## List functions\n  assert (List.size<X>(l1) == 0);\n  assert (List.size<X>(l2) == 1);\n  assert (List.size<X>(l3) == 2);\n\n  do {\n    Debug.print(\"  flatten\");\n\n    let expected : List.List<Nat> = ?(1, ?(2, ?(3, null)));\n    // [[1, 2], [3]]\n    let nested : List.List<List.List<Nat>> =\n      ?(?(1, ?(2, null)), ?(?(3, null), null));\n    let actual = List.flatten<Nat>(nested);\n\n    assert List.equal<Nat>(expected, actual, func (x1, x2) { x1 == x2 });\n\n  };\n\n  do {\n    Debug.print(\"  fromArray\");\n\n    let expected : List.List<Nat> = ?(1, ?(2, ?(3, List.nil<Nat>())));\n    let array = [1, 2, 3];\n    let actual = List.fromArray<Nat>(array);\n\n    assert List.equal<Nat>(expected, actual, func (x1, x2) { x1 == x2 });\n  };\n\n  do {\n    Debug.print(\"  fromVarArray\");\n\n    let expected : List.List<Nat> = ?(1, ?(2, ?(3, List.nil<Nat>())));\n    let array = [var 1, 2, 3];\n    let actual = List.fromVarArray<Nat>(array);\n\n    assert List.equal<Nat>(expected, actual, func (x1, x2) { x1 == x2 });\n  };\n\n  do {\n    Debug.print(\"  toArray\");\n\n    let expected = [1, 2, 3];\n    let list : List.List<Nat> = ?(1, ?(2, ?(3, List.nil<Nat>())));\n    let actual = List.toArray<Nat>(list);\n\n    assert (actual.size() == expected.size());\n\n    for (i in actual.keys()) {\n      assert(actual[i] == expected[i]);\n    };\n  };\n\n  do {\n    Debug.print(\"  toVarArray\");\n\n    let expected = [var 1, 2, 3];\n    let list : List.List<Nat> = ?(1, ?(2, ?(3, List.nil<Nat>())));\n    let actual = List.toVarArray<Nat>(list);\n\n    assert (actual.size() == expected.size());\n\n    for (i in actual.keys()) {\n      assert(actual[i] == expected[i]);\n    };\n  };\n\n  do {\n    Debug.print(\"  toIter\");\n\n    let list : List.List<Nat> = ?(1, ?(2, ?(3, List.nil<Nat>())));\n    let _actual = List.toIter<Nat>(list);\n    let actual = [var 0, 0, 0];\n    let expected = [1, 2, 3];\n\n    Iter.iterate<Nat>(_actual, func (x, i) { actual[i] := x; });\n\n    for (i in actual.keys()) {\n      assert(actual[i] == expected[i]);\n    };\n  };\n\nfunc makeNatural(x : Int) : Result.Result<Nat, Text> =\n  if (x >= 0) { #ok(Int.abs(x)) } else { #err(Int.toText(x) # \" is not a natural number.\") };\n\nfunc listRes(itm : Result.Result<List.List<Nat>, Text>) : T.TestableItem<Result.Result<List.List<Nat>, Text>> {\n  let resT = T.resultTestable(T.listTestable<Nat>(T.intTestable), T.textTestable);\n  { display = resT.display; equals = resT.equals; item = itm }\n};\n\nlet mapResult = Suite.suite(\"mapResult\", [\n  Suite.test(\"empty list\",\n    List.mapResult<Int, Nat, Text>(List.nil(), makeNatural),\n    M.equals(listRes(#ok(List.nil())))\n  ),\n  Suite.test(\"success\",\n    List.mapResult<Int, Nat, Text>(?(1, ?(2, ?(3, null))), makeNatural),\n    M.equals(listRes(#ok(?(1, ?(2, ?(3, null))))))\n  ),\n  Suite.test(\"fail fast\",\n    List.mapResult<Int, Nat, Text>(?(-1, ?(2, ?(3, null))), makeNatural),\n    M.equals(listRes(#err(\"-1 is not a natural number.\")))\n  ),\n  Suite.test(\"fail last\",\n    List.mapResult<Int, Nat, Text>(?(1, ?(2, ?(-3, null))), makeNatural),\n    M.equals(listRes(#err(\"-3 is not a natural number.\")))\n  ),\n]);\n\nSuite.run(Suite.suite(\"List\", [ mapResult ]));\n\nlet replicate = Suite.suite(\"replicate\", [\n  Suite.test(\"empty-list\",\n    List.replicate<Nat>(0, 0),\n    M.equals(\n      T.list(T.natTestable, List.nil<Nat>()))\n  ),\n  Suite.test(\"small-list\",\n    List.replicate(3, 0),\n    M.equals(\n      T.list<Nat>(T.natTestable, ?(0, ?(0, ?(0, null)))))\n  )\n]);\n\nlet tabulate = Suite.suite(\"tabulate\", [\n  Suite.test(\"empty-list\",\n    List.tabulate<Nat>(0, func i { i }),\n    M.equals(\n      T.list(T.natTestable, List.nil<Nat>()))\n  ),\n  Suite.test(\"small-list\",\n    List.tabulate<Nat>(3, func i { i * 2 }),\n    M.equals(\n      T.list<Nat>(T.natTestable, ?(0, ?(2, ?(4, null)))))\n  ),\n  Suite.test(\"large-list\",\n    List.tabulate<Nat>(10000, func i { 0 }),\n    M.equals(\n      T.list<Nat>(T.natTestable, List.replicate(10000, 0)))\n  )\n]);\n\nlet append = Suite.suite(\"append\", [\n  Suite.test(\"small-list\",\n    List.append(\n      List.tabulate<Nat>(10, func i { i }),\n      List.tabulate<Nat>(10, func i { i + 10 })),\n    M.equals(\n      T.list(T.natTestable, List.tabulate<Nat>(20, func i { i })))\n  ),\n  Suite.test(\"large-list\",\n    List.append(\n      List.tabulate<Nat>(10000, func i { i }),\n      List.tabulate<Nat>(10000, func i { i + 10000 })),\n    M.equals(\n      T.list(T.natTestable,List.tabulate<Nat>(20000, func i { i })))\n  ),\n]);\n\nSuite.run(Suite.suite(\"List\", [ mapResult, replicate, tabulate, append ]));\n"}