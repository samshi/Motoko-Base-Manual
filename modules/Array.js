modules.Array={"imports":{"IterType":"I","Option":"Option","Order":"Order","mo:â›”":"Prim","Result":"Result"},"functions":{"init":{"desc":"Create a mutable array with `size` copies of the initial value.\n\n```motoko include=import\nlet array = Array.init<Nat>(4, 2);\n```\n\nRuntime: O(size)\nSpace: O(size)","body":"public func init<X>(size : Nat,  initValue : X) : [var X] =\n  Prim.Array_init<X>(size, initValue);"},"tabulate":{"desc":"// Create an immutable array of size `size`. Each element at index i\nis created by applying `generator` to i.\n\n```motoko include=import\nlet array : [Nat] = Array.tabulate<Nat>(4, func i = i * 2);\n```\n\nRuntime: O(size)\nSpace: O(size)\n\n*Runtime and space assumes that `generator` runs in O(1) time and space.","body":"public func tabulate<X>(size : Nat,  generator : Nat -> X) : [X] =\n  Prim.Array_tabulate<X>(size, generator);"},"tabulateVar":{"desc":"// Create a mutable array of size `size`. Each element at index i\nis created by applying `generator` to i.\n\n```motoko include=import\nlet array : [var Nat] = Array.tabulateVar<Nat>(4, func i = i * 2);\narray[2] := 0;\narray\n```\n\nRuntime: O(size)\nSpace: O(size)\n\n*Runtime and space assumes that `generator` runs in O(1) time and space.","body":"public func tabulateVar<X>(size : Nat,  generator : Nat -> X) : [var X] {\n  // FIXME add this as a primitive in the RTS\n  if (size == 0) { return [var] };\n  let array = Prim.Array_init<X>(size, generator 0);\n  var i = 0;\n  while (i < size) {\n    array[i] := generator i;\n    i += 1;\n  };\n  array\n}"},"freeze":{"desc":"Transforms a mutable array into an immutable array.\n\n```motoko include=import\n\nlet varArray = [var 0, 1, 2];\nvarArray[2] := 3;\nlet array = Array.freeze<Nat>(varArray);\n```\n\nRuntime: O(size)\n\nSpace: O(1)","body":"public func freeze<X>(varArray : [var X]) : [X] =\n  Prim.Array_tabulate<X>(varArray.size(), func i = varArray[i]);"},"thaw":{"desc":"// Transforms an immutable array into a mutable array.\n\n```motoko include=import\n\nlet array = [0, 1, 2];\nlet varArray = Array.thaw<Nat>(array);\nvarArray[2] := 3;\nvarArray\n```\n\nRuntime: O(size)\n\nSpace: O(1)","body":"public func thaw<A>(array : [A]) : [var A] {\n  let size = array.size();\n  if (size == 0) {\n    return [var];\n  };\n  let newArray = Prim.Array_init<A>(size, array[0]);\n  var i = 0;\n  while (i < size) {\n    newArray[i] := array[i];\n    i += 1;\n  };\n  newArray\n}"},"equal":{"desc":"Tests if two arrays contain equal values (i.e. they represent the same\nlist of elements). Uses `equal` to compare elements in the arrays.\n\n```motoko include=import\n// Use the equal function from the Nat module to compare Nats\nimport {equal} \"mo:base/Nat\";\n\nlet array1 = [0, 1, 2, 3];\nlet array2 = [0, 1, 2, 3];\nArray.equal(array1, array2, equal)\n```\n\nRuntime: O(size1 + size2)\n\nSpace: O(1)\n\n*Runtime and space assumes that `equal` runs in O(1) time and space.","body":"public func equal<X>(array1 : [X], array2 : [X], equal : (X, X) -> Bool) : Bool {\n  let size1 = array1.size();\n  let size2 = array2.size();\n  if (size1 != size2) {\n    return false;\n  };\n  var i = 0;\n  while (i < size1) {\n    if (not equal(array1[i], array2[i])) {\n      return false;\n    };\n    i += 1;\n  };\n  return true;\n}"},"find":{"desc":"Returns the first value in `array` for which `predicate` returns true.\nIf no element satisfies the predicate, returns null.\n\n```motoko include=import\nlet array = [1, 9, 4, 8];\nArray.find<Nat>(array, func x = x > 8)\n```\nRuntime: O(size)\n\nSpace: O(1)\n\n*Runtime and space assumes that `predicate` runs in O(1) time and space.","body":"public func find<X>(array : [X], predicate : X -> Bool) : ?X {\n  for (element in array.vals()) {\n    if (predicate element) {\n      return ?element;\n    }\n  };\n  return null;\n}"},"append":{"desc":"Create a new array by appending the values of `array1` and `array2`.\n@deprecated `Array.append` copies its arguments and has linear complexity;\nwhen used in a loop, consider using a `Buffer`, and `Buffer.append`, instead.\n\n```motoko include=import\nlet array1 = [1, 2, 3];\nlet array2 = [4, 5, 6];\nArray.append<Nat>(array1, array2)\n```\nRuntime: O(size1 + size2)\n\nSpace: O(size1 + size2)","body":"public func append<X>(array1 : [X], array2 : [X]) : [X] {\n  let size1 = array1.size();\n  let size2 = array2.size();\n  Prim.Array_tabulate<X>(size1 + size2, func i {\n    if (i < size1) {\n      array1[i];\n    } else {\n      array2[i - size1];\n    };\n  });\n}"},"sort":{"desc":"FIXME this example stack overflows. Should test with new implementation of sortInPlace\nSorts the elements in the array according to `compare`.\nSort is deterministic and stable.\n\n```motoko include=import\nimport Nat \"mo:base/Nat\";\n\nlet array = [4, 2, 6];\nArray.sort(array, Nat.compare)\n```\nRuntime: O(size * log(size))\n\nSpace: O(size)\n*Runtime and space assumes that `compare` runs in O(1) time and space.","body":"public func sort<X>(array : [X], compare : (X, X) -> Order.Order) : [X] {\n  let temp : [var X] = thaw(array);\n  sortInPlace(temp, compare);\n  freeze(temp)\n}"},"sortInPlace":{"desc":"Sorts the elements in the array, __in place__, according to `compare`.\nSort is deterministic, stable, and in-place.\n\n```motoko include=import\n\nimport {compare} \"mo:base/Nat\";\n\nlet array = [var 4, 2, 6];\nArray.sortInPlace(array, compare);\narray\n```\nRuntime: O(size * log(size))\n\nSpace: O(size)\n*Runtime and space assumes that `compare` runs in O(1) time and space.","body":"public func sortInPlace<X>(array : [var X], compare : (X, X) -> Order.Order) {\n  // Stable merge sort in a bottom-up iterative style. Same algorithm as the sort in Buffer.\n  let size = array.size();\n  if (size == 0) {\n    return;\n  };\n  let scratchSpace = Prim.Array_init<X>(size, array[0]);\n\n  let sizeDec = size - 1 : Nat;\n  var currSize = 1; // current size of the subarrays being merged\n  // when the current size == size, the array has been merged into a single sorted array\n  while (currSize < size) {\n    var leftStart = 0; // selects the current left subarray being merged\n    while (leftStart < sizeDec) {\n      let mid : Nat = if (leftStart + currSize - 1 : Nat < sizeDec) {\n        leftStart + currSize - 1;\n      } else { sizeDec };\n      let rightEnd : Nat = if (leftStart + (2 * currSize) - 1 : Nat < sizeDec) {\n        leftStart + (2 * currSize) - 1;\n      } else { sizeDec };\n\n      // Merge subarrays elements[leftStart...mid] and elements[mid+1...rightEnd]\n      var left = leftStart;\n      var right = mid + 1;\n      var nextSorted = leftStart;\n      while (left < mid + 1 and right < rightEnd + 1) {\n        let leftElement = array[left];\n        let rightElement = array[right];\n        switch (compare(leftElement, rightElement)) {\n          case (#less or #equal) {\n            scratchSpace[nextSorted] := leftElement;\n            left += 1;\n          };\n          case (#greater) {\n            scratchSpace[nextSorted] := rightElement;\n            right += 1;\n          };\n        };\n        nextSorted += 1;\n      };\n      while (left < mid + 1) {\n        scratchSpace[nextSorted] := array[left];\n        nextSorted += 1;\n        left += 1;\n      };\n      while (right < rightEnd + 1) {\n        scratchSpace[nextSorted] := array[right];\n        nextSorted += 1;\n        right += 1;\n      };\n\n      // Copy over merged elements\n      var i = leftStart;\n      while (i < rightEnd + 1) {\n        array[i] := scratchSpace[i];\n        i += 1;\n      };\n\n      leftStart += 2 * currSize;\n    };\n    currSize *= 2;\n  };\n}"},"reverse":{"desc":"Creates a new array by reversing the order of elements in `array`.\n\n```motoko include=import\n\nlet array = [10, 11, 12];\n\nArray.reverse(array)\n```\n\nRuntime: O(size)\n\nSpace: O(1)","body":"public func reverse<X>(array : [X]) : [X] {\n  let size = array.size();\n  Prim.Array_tabulate<X>(size, func i = array[size - i - 1]);\n}"},"map":{"desc":"Creates a new array by applying `f` to each element in `array`. `f` \"maps\"\neach element it is applied to of type `X` to an element of type `Y`.\nRetains original ordering of elements.\n\n```motoko include=import\n\nlet array = [0, 1, 2, 3];\nArray.map<Nat, Nat>(array, func x = x * 3)\n```\n\nRuntime: O(size)\n\nSpace: O(size)\n\n*Runtime and space assumes that `f` runs in O(1) time and space.","body":"public func map<X, Y>(array : [X], f : X -> Y) : [Y] =\n  Prim.Array_tabulate<Y>(array.size(), func i = f(array[i]));"},"filter":{"desc":"// Creates a new array by applying `predicate` to every element\nin `array`, retaining the elements for which `predicate` returns true.\n\n```motoko include=import\nlet array = [4, 2, 6, 1, 5];\nlet evenElements = Array.filter<Nat>(array, func x = x % 2 == 0);\n```\nRuntime: O(size)\n\nSpace: O(size)\n*Runtime and space assumes that `predicate` runs in O(1) time and space.","body":"public func filter<X>(array : [X], predicate : X -> Bool) : [X] {\n  var count = 0;\n  let keep =\n    Prim.Array_tabulate<Bool>(\n      array.size(),\n      func i {\n        if (predicate(array[i])) {\n          count += 1;\n          true\n        } else {\n          false\n        }\n      }\n    );\n  var nextKeep = 0;\n  Prim.Array_tabulate<X>(\n    count,\n    func _ {\n      while (not keep[nextKeep]) {\n        nextKeep += 1;\n      };\n      nextKeep += 1;\n      array[nextKeep - 1];\n    }\n  )\n}"},"mapEntries":{"desc":"FIXME the arguments ordering to the higher order function are flipped\nbetween this and the buffer class\nprobably can't avoid breaking changes at some point\nCreates a new array by applying `f` to each element in `array` and its index.\nRetains original ordering of elements.\n\n```motoko include=import\n\nlet array = [10, 10, 10, 10];\nArray.mapEntries<Nat, Nat>(array, func (i, x) = i * x)\n```\n\nRuntime: O(size)\n\nSpace: O(size)\n\n*Runtime and space assumes that `f` runs in O(1) time and space.","body":"public func mapEntries<X, Y>(array : [X], f : (X, Nat) -> Y) : [Y] =\n  Prim.Array_tabulate<Y>(array.size(), func i = f(array[i], i));"},"mapFilter":{"desc":"// Creates a new array by applying `f` to each element in `array`,\nand keeping all non-null elements. The ordering is retained.\n\n```motoko include=import\nimport {toText} \"mo:base/Nat\";\n\nlet array = [4, 2, 0, 1];\nlet newArray =\n  Array.mapFilter<Nat, Text>( // mapping from Nat to Text values\n    array,\n    func x = if (x == 0) { null } else { ?toText(100 / x) } // can't divide by 0, so return null\n  );\n```\nRuntime: O(size)\n\nSpace: O(size)\n*Runtime and space assumes that `f` runs in O(1) time and space.","body":"public func mapFilter<X, Y>(array : [X], f : X -> ?Y) : [Y] {\n  var count = 0;\n  let options =\n    Prim.Array_tabulate<?Y>(\n      array.size(),\n      func i {\n        let result = f(array[i]);\n        switch (result) {\n          case (?element) {\n            count += 1;\n            result\n          };\n          case null {\n            null\n          }\n        }\n      }\n    );\n\n  var nextSome = 0;\n  Prim.Array_tabulate<Y>(\n    count,\n    func _ {\n      while (Option.isNull(options[nextSome])) {\n        nextSome += 1;\n      };\n      nextSome += 1;\n      switch(options[nextSome - 1]) {\n        case(?element) element;\n        case null {\n          Prim.trap \"Malformed array in mapFilter\"\n        }\n      }\n    }\n  )\n}"},"mapResult":{"desc":"Creates a new array by applying `f` to each element in `array`.\nIf any invocation of `f` produces an `#err`, returns an `#err`. Otherwise\nreturns an `#ok` containing the new array.\n\n```motoko include=import\nlet array = [4, 3, 2, 1, 0];\n// divide 100 by every element in the array\nArray.mapResult<Nat, Nat, Text>(array, func x {\n  if (x > 0) {\n    #ok(100 / x)\n  } else {\n    #err \"Cannot divide by zero\"\n  }\n})\n```\n\nRuntime: O(size)\n\nSpace: O(size)\n\n*Runtime and space assumes that `f` runs in O(1) time and space.","body":"public func mapResult<X, Y, E>(array : [X], f : X -> Result.Result<Y, E>) : Result.Result<[Y], E> {\n  let size = array.size();\n  var target : [var Y] = [var];\n  var isInit = false;\n\n  var error : ?Result.Result<[Y], E> = null;\n  let results = Prim.Array_tabulate<?Y>(size, func i {\n    switch (f(array[i])) {\n      case (#ok element) {\n        ?element\n      };\n      case (#err e) {\n        switch (error) {\n          case null { // only take the first error\n            error := ?(#err e);\n          };\n          case _ { };\n        };\n        null\n      }\n    }\n  });\n\n  switch error {\n    case null {\n      // unpack the option\n      #ok(map<?Y, Y>(results, func element {\n        switch element {\n          case (?element) {\n            element\n          };\n          case null {\n            Prim.trap \"Malformed array in mapResults\"\n          };\n        }\n      }));\n    };\n    case (?error) {\n      error\n    };\n  }\n}"},"chain":{"desc":"Creates a new array by applying `k` to each element in `array`,\nand concatenating the resulting arrays in order. This operation\nis similar to what in other functional languages is known as monadic bind.\n\n```motoko include=import\nimport Nat \"mo:base/Nat\";\n\nlet array = [1, 2, 3, 4];\nArray.chain<Nat, Int>(array, func x = [x, -x])\n\n```\nRuntime: O(size)\n\nSpace: O(size)\n*Runtime and space assumes that `k` runs in O(1) time and space.","body":"public func chain<X, Y>(array : [X], k : X -> [Y]) : [Y] {\n  var flatSize = 0;\n  let subArrays = Prim.Array_tabulate<[Y]>(array.size(), func i {\n    let subArray = k(array[i]);\n    flatSize += subArray.size();\n    subArray\n  });\n  // could replace with a call to flatten,\n  // but it would require an extra pass (to compute `flatSize`)\n  var outer = 0;\n  var inner = 0;\n  Prim.Array_tabulate<Y>(flatSize, func _ {\n    let subArray = subArrays[outer];\n    let element = subArray[inner];\n    inner += 1;\n    if (inner == subArray.size()) {\n      inner := 0;\n      outer += 1;\n    };\n    element\n  })\n}"},"foldLeft":{"desc":"Collapses the elements in `array` into a single value by starting with `base`\nand progessively combining elements into `base` with `combine`. Iteration runs\nleft to right.\n\n```motoko include=import\nimport {add} \"mo:base/Nat\";\n\nlet array = [4, 2, 0, 1];\nlet sum =\n  Array.foldLeft<Nat, Nat>(\n    array,\n    0, // start the sum at 0\n    func(sumSoFar, x) = sumSoFar + x // this entire function can be replaced with `add`!\n  );\n```\n\nRuntime: O(size)\n\nSpace: O(1)\n\n*Runtime and space assumes that `combine` runs in O(1) time and space.","body":"public func foldLeft<X, A>(array : [X], base : A, combine : (A, X) -> A) : A {\n  var accumulation = base;\n\n  for (element in array.vals()) {\n    accumulation := combine(accumulation, element);\n  };\n\n  accumulation\n}"},"foldRight":{"desc":"FIXME the type arguments are reverse order from Buffer\nCollapses the elements in `array` into a single value by starting with `base`\nand progessively combining elements into `base` with `combine`. Iteration runs\nright to left.\n\n```motoko include=import\nimport {toText} \"mo:base/Nat\";\n\nlet array = [1, 9, 4, 8];\nlet bookTitle = Array.foldRight<Nat, Text>(array, \"\", func(x, acc) = toText(x) # acc);\n```\n\nRuntime: O(size)\n\nSpace: O(1)\n\n*Runtime and space assumes that `combine` runs in O(1) time and space.","body":"public func foldRight<X, A>(array : [X], base : A, combine : (X, A) -> A) : A {\n  var accumulation = base;\n  let size = array.size();\n\n  var i = size;\n  while (i > 0) {\n    i -= 1;\n    accumulation := combine(array[i], accumulation);\n  };\n\n  accumulation;\n}"},"flatten":{"desc":"Flattens the array of arrays into a single array. Retains the original\nordering of the elements.\n\n```motoko include=import\n\nlet arrays = [[0, 1, 2], [2, 3], [], [4]];\nArray.flatten<Nat>(arrays)\n```\n\nRuntime: O(number of elements in array)\n\nSpace: O(number of elements in array)","body":"public func flatten<X>(arrays : [[X]]) : [X] {\n  var flatSize = 0;\n  for (subArray in arrays.vals()) {\n    flatSize += subArray.size()\n  };\n\n  var outer = 0;\n  var inner = 0;\n  Prim.Array_tabulate<X>(flatSize, func _ {\n    while (inner == arrays[outer].size()) {\n      inner := 0;\n      outer += 1;\n    };\n    let element = arrays[outer][inner];\n    inner += 1;\n    element\n  })\n}"},"make":{"desc":"Create an array containing a single value.\n\n```motoko include=import\nArray.make(2)\n```\n\nRuntime: O(1)\n\nSpace: O(1)","body":"public func make<X>(element : X) : [X] = [element];"},"vals":{"desc":"// Returns an Iterator (`Iter`) over the elements of `array`.\nIterator provides a single method `next()`, which returns\nelements in order, or `null` when out of elements to iterate over.\n\nNOTE: You can also use `array.vals()` instead of this function. See example\nbelow.\n\n```motoko include=import\n\nlet array = [10, 11, 12];\n\nvar sum = 0;\nfor (element in array.vals()) {\n  sum += element;\n};\nsum\n```\n\nRuntime: O(1)\n\nSpace: O(1)","body":"public func vals<X>(array : [X]) : I.Iter<X> = array.vals();"},"keys":{"desc":"// Returns an Iterator (`Iter`) over the indices of `array`.\nIterator provides a single method `next()`, which returns\nindices in order, or `null` when out of index to iterate over.\n\nNOTE: You can also use `array.keys()` instead of this function. See example\nbelow.\n\n```motoko include=import\n\nlet array = [10, 11, 12];\n\nvar sum = 0;\nfor (element in array.keys()) {\n  sum += element;\n};\nsum\n```\n\nRuntime: O(1)\n\nSpace: O(1)","body":"public func keys<X>(array : [X]) : I.Iter<Nat> = array.keys();"}},"related":"","test":"import Array \"mo:base/Array\";\nimport Int \"mo:base/Int\";\nimport Nat \"../src/Nat\";\nimport Text \"mo:base/Text\";\nimport Result \"mo:base/Result\";\nimport Suite \"mo:matchers/Suite\";\nimport T \"mo:matchers/Testable\";\nimport M \"mo:matchers/Matchers\";\n\nlet suite = Suite.suite(\"Array\", [\n  Suite.test(\n    \"init\",\n    Array.freeze(Array.init<Int>(3, 4)),\n    M.equals(T.array<Int>(T.intTestable, [4, 4, 4]))),\n  Suite.test(\n    \"init empty\",\n    Array.freeze(Array.init<Int>(0, 4)),\n    M.equals(T.array<Int>(T.intTestable, []))),\n  Suite.test(\n    \"tabulate\",\n    Array.tabulate<Int>(3, func (i : Nat)= i * 2),\n    M.equals(T.array<Int>(T.intTestable, [0, 2, 4]))),\n  Suite.test(\n    \"tabulate empty\",\n    Array.tabulate<Int>(0, func (i : Nat) = i),\n    M.equals(T.array<Int>(T.intTestable, []))),\n  Suite.test(\n    \"tabulateVar\",\n    Array.freeze(Array.tabulateVar<Int>(3, func (i : Nat)= i * 2)),\n    M.equals(T.array<Int>(T.intTestable, [0, 2, 4]))),\n  Suite.test(\n    \"tabulateVar empty\",\n    Array.freeze(Array.tabulateVar<Int>(0, func (i : Nat) = i)),\n    M.equals(T.array<Int>(T.intTestable, []))),\n  Suite.test(\n    \"freeze\",\n    Array.freeze<Int>([ var 1, 2, 3 ]),\n    M.equals(T.array<Int>(T.intTestable, [ 1, 2, 3 ]))\n  ),\n  Suite.test(\n    \"freeze empty\",\n    Array.freeze<Int>([var]),\n    M.equals(T.array<Int>(T.intTestable, []))\n  ),\n  Suite.test(\n    \"thaw round trip\",\n    Array.freeze(Array.thaw<Int>([1, 2, 3])),\n    M.equals(T.array<Int>(T.intTestable, [1, 2, 3]))\n  ),\n  Suite.test(\n    \"thaw round trip empty\",\n    Array.freeze(Array.thaw<Int>([])),\n    M.equals(T.array<Int>(T.intTestable, []))\n  ),\n  Suite.test(\n    \"equal\",\n    Array.equal<Int>([1, 2, 3], [1, 2, 3], Int.equal),\n    M.equals(T.bool(true))\n  ),\n  Suite.test(\n    \"equal empty\",\n    Array.equal<Int>([], [], Int.equal),\n    M.equals(T.bool(true))\n  ),\n  Suite.test(\n    \"not equal one empty\",\n    Array.equal<Int>([], [2, 3], Int.equal),\n    M.equals(T.bool(false))\n  ),\n  Suite.test(\n    \"not equal different lengths\",\n    Array.equal<Int>([1, 2, 3], [2, 4], Int.equal),\n    M.equals(T.bool(false))\n  ),\n  Suite.test(\n    \"not equal same lengths\",\n    Array.equal<Int>([1, 2, 3], [1, 2, 4], Int.equal),\n    M.equals(T.bool(false))\n  ),\n  Suite.test(\n    \"find\",\n    Array.find<Nat>([1, 9, 4, 8], func x = x == 9),\n    M.equals(T.optional(T.natTestable, ?9))\n  ),\n  Suite.test(\n    \"find fail\",\n    Array.find<Nat>([1, 9, 4, 8], func _ = false),\n    M.equals(T.optional(T.natTestable, null : ?Nat))\n  ),\n  Suite.test(\n    \"find empty\",\n    Array.find<Nat>([], func _ = true),\n    M.equals(T.optional(T.natTestable, null : ?Nat))\n  ),\n  Suite.test(\n    \"append\",\n    Array.append<Int>([1, 2, 3], [4, 5, 6]),\n    M.equals(T.array<Int>(T.intTestable, [ 1, 2, 3, 4, 5, 6 ]))\n  ),\n  Suite.test(\n    \"append first empty\",\n    Array.append<Int>([], [4, 5, 6]),\n    M.equals(T.array<Int>(T.intTestable, [4, 5, 6]))\n  ),\n  Suite.test(\n    \"append second empty\",\n    Array.append<Int>([1, 2, 3], []),\n    M.equals(T.array<Int>(T.intTestable, [1, 2, 3]))\n  ),\n  Suite.test(\n    \"append both empty\",\n    Array.append<Int>([], []),\n    M.equals(T.array<Int>(T.intTestable, []))\n  ),\n  Suite.test(\"sort\",\n    Array.sort([2, 3, 1], Nat.compare),\n    M.equals(T.array<Nat>(T.natTestable, [1, 2, 3]))\n  ),\n  Suite.test(\"sort empty array\",\n    Array.sort([], Nat.compare),\n    M.equals(T.array<Nat>(T.natTestable, []))\n  ),\n  Suite.test(\"sort already sorted\",\n    Array.sort([1, 2, 3, 4, 5], Nat.compare),\n    M.equals(T.array<Nat>(T.natTestable, [1, 2, 3, 4, 5]))\n  ),\n  Suite.test(\"sort repeated elements\",\n    Array.sort([2, 2, 2, 2, 2], Nat.compare),\n    M.equals(T.array<Nat>(T.natTestable, [2, 2, 2, 2, 2]))\n  ),\n  Suite.test(\"sortInPlace\",\n    do {\n      let array = [var 2, 3, 1];\n      Array.sortInPlace(array, Nat.compare);\n      Array.freeze(array)\n    },\n    M.equals(T.array<Nat>(T.natTestable, [1, 2, 3]))\n  ),\n  Suite.test(\"sortInPlace empty\",\n    do {\n      let array = [var];\n      Array.sortInPlace(array, Nat.compare);\n      Array.freeze(array)\n    },\n    M.equals(T.array<Nat>(T.natTestable, []))\n  ),\n  Suite.test(\"sortInPlace already sorted\",\n    do {\n      let array = [var 1, 2, 3, 4, 5];\n      Array.sortInPlace(array, Nat.compare);\n      Array.freeze(array)\n    },\n    M.equals(T.array<Nat>(T.natTestable, [1, 2, 3, 4, 5]))\n  ),\n  Suite.test(\"sortInPlace repeated elements\",\n    do {\n      let array = [var 2, 2, 2, 2, 2];\n      Array.sortInPlace(array, Nat.compare);\n      Array.freeze(array)\n    },\n    M.equals(T.array<Nat>(T.natTestable, [2, 2, 2, 2, 2]))\n  ),\n  Suite.test(\n    \"reverse\",\n    Array.reverse<Nat>([0, 1, 2, 2, 3]),\n    M.equals(T.array<Nat>(T.natTestable, [3, 2, 2, 1, 0]))\n  ),\n  Suite.test(\n    \"reverse empty\",\n    Array.reverse<Nat>([]),\n    M.equals(T.array<Nat>(T.natTestable, []))\n  ),\n  Suite.test(\n    \"reverse singleton\",\n    Array.reverse<Nat>([0]),\n    M.equals(T.array<Nat>(T.natTestable, [0]))\n  ),\n  Suite.test(\n    \"map\",\n    Array.map<Nat, Bool>([1, 2, 3], func x = x % 2 == 0),\n    M.equals(T.array<Bool>(T.boolTestable, [false, true, false]))\n  ),\n  Suite.test(\n    \"map empty\",\n    Array.map<Nat, Bool>([], func x = x % 2 == 0),\n    M.equals(T.array<Bool>(T.boolTestable, []))\n  ),\n  Suite.test(\n    \"filter\",\n    Array.filter<Nat>([1, 2, 3, 4, 5, 6], func x = x % 2 == 0),\n    M.equals(T.array<Nat>(T.natTestable, [2, 4, 6]))\n  ),\n  Suite.test(\n    \"filter empty\",\n    Array.filter<Nat>([], func x = x % 2 == 0),\n    M.equals(T.array<Nat>(T.natTestable, []))\n  ),\n  Suite.test(\n    \"mapEntries\",\n    Array.mapEntries<Nat, Nat>([1, 2, 3], func (x, i) = x + i),\n    M.equals(T.array<Nat>(T.natTestable, [1, 3, 5]))\n  ),\n  Suite.test(\n    \"mapEntries empty\",\n    Array.mapEntries<Nat, Nat>([], func (x, i) = x + i),\n    M.equals(T.array<Nat>(T.natTestable, []))\n  ),\n  Suite.test(\n    \"mapFilter\",\n    Array.mapFilter<Nat, Nat>([1, 2, 3, 4, 5, 6], func x { if (x % 2 == 0) ?x else null }),\n    M.equals(T.array<Nat>(T.natTestable, [2, 4, 6]))\n  ),\n  Suite.test(\n    \"mapFilter keep all\",\n    Array.mapFilter<Nat, Nat>([1, 2, 3], func x = ?x),\n    M.equals(T.array<Nat>(T.natTestable, [1, 2, 3]))\n  ),\n  Suite.test(\n    \"mapFilter keep none\",\n    Array.mapFilter<Nat, Nat>([1, 2, 3], func _ = null),\n    M.equals(T.array<Nat>(T.natTestable, []))\n  ),\n  Suite.test(\n    \"mapFilter empty\",\n    Array.mapFilter<Nat, Nat>([], func x { if (x % 2 == 0) ?x else null }),\n    M.equals(T.array<Nat>(T.natTestable, []))\n  ),\n  Suite.test(\n    \"mapResult\",\n    Array.mapResult<Int, Nat, Text>(\n      [1, 2, 3],\n      func x { if (x >= 0) { #ok(Int.abs x) } else { #err \"error message\"} }),\n    M.equals(T.result<[Nat], Text>(T.arrayTestable(T.natTestable), T.textTestable, #ok([1, 2, 3])))\n  ),\n  Suite.test(\n    \"mapResult fail first\",\n    Array.mapResult<Int, Nat, Text>(\n      [-1, 2, 3],\n      func x { if (x >= 0) { #ok(Int.abs x) } else { #err \"error message\"} }),\n    M.equals(T.result<[Nat], Text>(T.arrayTestable(T.natTestable), T.textTestable, #err \"error message\"))\n  ),\n  Suite.test(\n    \"mapResult fail last\",\n    Array.mapResult<Int, Nat, Text>(\n      [1, 2, -3],\n      func x { if (x >= 0) { #ok(Int.abs x) } else { #err \"error message\"} }),\n    M.equals(T.result<[Nat], Text>(T.arrayTestable(T.natTestable), T.textTestable, #err \"error message\"))\n  ),\n  Suite.test(\n    \"mapResult empty\",\n    Array.mapResult<Nat, Nat, Text>(\n      [],\n      func x = #ok x),\n    M.equals(T.result<[Nat], Text>(T.arrayTestable(T.natTestable), T.textTestable, #ok([])))\n  ),\n  Suite.test(\n    \"chain\",\n    Array.chain<Int, Int>([0, 1, 2], func x = [x, -x]),\n    M.equals(T.array<Int>(T.intTestable, [0, 0, 1, -1, 2, -2]))\n  ),\n  Suite.test(\n    \"chain empty\",\n    Array.chain<Int, Int>([], func x = [x, -x]),\n    M.equals(T.array<Int>(T.intTestable, []))\n  ),\n  Suite.test(\n    \"foldLeft\",\n    Array.foldLeft<Text, Text>([ \"a\", \"b\", \"c\" ], \"\", Text.concat),\n    M.equals(T.text(\"abc\"))\n  ),\n  Suite.test(\n    \"foldLeft empty\",\n    Array.foldLeft<Text, Text>([], \"base\", Text.concat),\n    M.equals(T.text(\"base\"))\n  ),\n  Suite.test(\n    \"foldRight\",\n    Array.foldRight<Text, Text>([ \"a\", \"b\", \"c\" ], \"\", func (x, acc) = acc # x),\n    M.equals(T.text(\"cba\"))\n  ),\n  Suite.test(\n    \"foldRight empty\",\n    Array.foldRight<Text, Text>([], \"base\", Text.concat),\n    M.equals(T.text(\"base\"))\n  ),\n  Suite.test(\n    \"flatten\",\n    Array.flatten<Int>([[1, 2, 3], [], [1]]),\n    M.equals(T.array<Int>(T.intTestable, [1, 2, 3, 1]))\n  ),\n  Suite.test(\n    \"flatten empty start\",\n    Array.flatten<Int>([[], [1, 2, 3], [], [1]]),\n    M.equals(T.array<Int>(T.intTestable, [1, 2, 3, 1]))\n  ),\n  Suite.test(\n    \"flatten empty end\",\n    Array.flatten<Int>([[1, 2, 3], [], [1], []]),\n    M.equals(T.array<Int>(T.intTestable, [1, 2, 3, 1]))\n  ),\n  Suite.test(\n    \"flatten singleton\",\n    Array.flatten<Int>([[1, 2, 3]]),\n    M.equals(T.array<Int>(T.intTestable, [1, 2, 3]))\n  ),\n  Suite.test(\n    \"flatten empty\",\n    Array.flatten<Int>([[]]),\n    M.equals(T.array<Int>(T.intTestable, []))\n  ),\n  Suite.test(\n    \"flatten empty\",\n    Array.flatten<Int>([]),\n    M.equals(T.array<Int>(T.intTestable, []))\n  ),\n  Suite.test(\n    \"make\",\n    Array.make<Int>(0),\n    M.equals(T.array<Int>(T.intTestable, [0]))\n  ),\n  Suite.test(\n    \"vals\",\n    do {\n      var sum = 0;\n      for (x in Array.vals([1, 2, 3])) {\n        sum += x;\n      };\n      sum\n    },\n    M.equals(T.nat(6))\n  ),\n  Suite.test(\n    \"vals empty\",\n    do {\n      var sum = 0;\n      for (x in Array.vals([])) {\n        sum += x;\n      };\n      sum\n    },\n    M.equals(T.nat(0))\n  ),\n  Suite.test(\n    \"keys\",\n    do {\n      var sum = 0;\n      for (x in Array.keys([1, 2, 3])) {\n        sum += x;\n      };\n      sum\n    },\n    M.equals(T.nat(3))\n  ),\n  Suite.test(\n    \"keys empty\",\n    do {\n      var sum = 0;\n      for (x in Array.keys([])) {\n        sum += x;\n      };\n      sum\n    },\n    M.equals(T.nat(0))\n  ),\n]);\n\nSuite.run(suite);\n"}