modules.Array={"imports":{"Buffer":"Buffer","IterType":"I","Option":"Option","Order":"Order","mo:â›”":"Prim","Result":"Result"},"functions":{"equal":{"desc":"Test if two arrays contain equal values","body":"public func equal<A>(a : [A], b : [A], eq : (A, A) -> Bool) : Bool {\n  if (a.size() != b.size()) {\n    return false;\n  };\n  var i = 0;\n  while (i < a.size()) {\n    if (not eq(a[i], b[i])) {\n      return false;\n    };\n    i += 1;\n  };\n  return true;\n}"},"append":{"desc":"Append the values of two input arrays\n@deprecated `Array.append` copies its arguments and has linear complexity; when used in a loop, consider using a `Buffer`, and `Buffer.append`, instead.","body":"public func append<A>(xs : [A], ys : [A]) : [A] {\n  switch(xs.size(), ys.size()) {\n    case (0, 0) { []; };\n    case (0, _) { ys; };\n    case (_, 0) { xs; };\n    case (xsSize, ysSize) {\n      Prim.Array_tabulate<A>(xsSize + ysSize, func (i : Nat) : A {\n        if (i < xsSize) {\n          xs[i];\n        } else {\n          ys[i - xsSize];\n        };\n      });\n    };\n  };\n}"},"sort":{"desc":"Sorts the given array according to the `cmp` function.\nThis is a _stable_ sort.\n\n```motoko\nimport Array \"mo:base/Array\";\nimport Nat \"mo:base/Nat\";\nlet xs = [4, 2, 6];\nassert(Array.sort(xs, Nat.compare) == [2, 4, 6])\n```","body":"public func sort<A>(xs : [A], cmp : (A, A) -> Order.Order) : [A] {\n  let tmp : [var A] = thaw(xs);\n  sortInPlace(tmp, cmp);\n  freeze(tmp)\n}"},"sortInPlace":{"desc":"Sorts the given array in place according to the `cmp` function.\nThis is a _stable_ sort.\n\n```motoko\nimport Array \"mo:base/Array\";\nimport Nat \"mo:base/Nat\";\nlet xs : [var Nat] = [var 4, 2, 6, 1, 5];\nArray.sortInPlace(xs, Nat.compare);\nassert(Array.freeze(xs) == [1, 2, 4, 5, 6])\n```","body":"public func sortInPlace<A>(xs : [var A], cmp : (A, A) -> Order.Order) {\n  if (xs.size() < 2) return;\n  let aux : [var A] = tabulateVar<A>(xs.size(), func i { xs[i] });\n\n  func merge(lo : Nat, mid : Nat, hi : Nat) {\n    var i = lo;\n    var j = mid + 1;\n    var k = lo;\n    while(k <= hi) {\n      aux[k] := xs[k];\n      k += 1;\n    };\n    k := lo;\n    while(k <= hi) {\n      if (i > mid) {\n        xs[k] := aux[j];\n        j += 1;\n      } else if (j > hi) {\n        xs[k] := aux[i];\n        i += 1;\n      } else if (Order.isLess(cmp(aux[j], aux[i]))) {\n        xs[k] := aux[j];\n        j += 1;\n      } else {\n        xs[k] := aux[i];\n        i += 1;\n      };\n      k += 1;\n    };\n  };\n\n  func go(lo : Nat, hi : Nat) {\n    if (hi <= lo) return;\n    let mid : Nat = lo + (hi - lo) / 2;\n    go(lo, mid);\n    go(mid + 1, hi);\n    merge(lo, mid, hi);\n  };\n\n  go(0, xs.size() - 1);\n}"},"chain":{"desc":"Transform each array value into zero or more output values, appended in order","body":"public func chain<A, B>(xs : [A], f : A -> [B]) : [B] {\n  var ys : [B] = [];\n  for (i in xs.keys()) {\n    ys := append<B>(ys, f(xs[i]));\n  };\n  ys;\n}"},"filter":{"desc":"Output array contains each array-value if and only if the predicate is true; ordering retained.","body":"public func filter<A>(xs : [A], f : A -> Bool) : [A] {\n  let ys : Buffer.Buffer<A> = Buffer.Buffer(xs.size());\n  for (x in xs.vals()) {\n    if (f(x)) {\n      ys.add(x);\n    };\n  };\n  ys.toArray();\n}"},"mapFilter":{"desc":"Output array contains each transformed optional value; ordering retained.","body":"public func mapFilter<A, B>(xs : [A], f : A -> ?B) : [B] {\n  let ys : Buffer.Buffer<B> = Buffer.Buffer(xs.size());\n  for (x in xs.vals()) {\n    switch (f(x)) {\n      case null {};\n      case (?y) { ys.add(y) };\n    }\n  };\n  ys.toArray();\n}"},"foldLeft":{"desc":"Aggregate and transform values into a single output value, by increasing indices.","body":"public func foldLeft<A, B>(xs : [A], initial : B, f : (B, A) -> B) : B {\n  var acc = initial;\n  let size = xs.size();\n  var i = 0;\n  while (i < size) {\n    acc := f(acc, xs[i]);\n    i += 1;\n  };\n  acc;\n}"},"foldRight":{"desc":"Aggregate and transform values into a single output value, by decreasing indices.","body":"public func foldRight<A, B>(xs : [A], initial : B, f : (A, B) -> B) : B {\n  var acc = initial;\n  let size = xs.size();\n  var i = size;\n  while (i > 0) {\n    i -= 1;\n    acc := f(xs[i], acc);\n  };\n  acc;\n}"},"find":{"desc":"Returns optional first value for which predicate is true","body":"public func find<A>(xs : [A], f : A -> Bool) : ?A {\n  for (x in xs.vals()) {\n    if (f(x)) {\n      return ?x;\n    }\n  };\n  return null;\n}"},"freeze":{"desc":"Transform mutable array into immutable array","body":"public func freeze<A>(xs : [var A]) : [A] {\n  Prim.Array_tabulate<A>(xs.size(), func (i : Nat) : A {\n    xs[i];\n  });\n}"},"flatten":{"desc":"Transform an array of arrays into a single array, with retained array-value order.","body":"public func flatten<A>(xs : [[A]]) : [A] {\n  chain<[A], A>(xs, func (x : [A]) : [A] {\n    x;\n  });\n}"},"map":{"desc":"Transform each value using a function, with retained array-value order.","body":"public func map<A, B>(xs : [A], f : A -> B) : [B] {\n  Prim.Array_tabulate<B>(xs.size(), func (i : Nat) : B {\n    f(xs[i]);\n  });\n}"},"mapEntries":{"desc":"Transform each entry (index-value pair) using a function.","body":"public func mapEntries<A, B>(xs : [A], f : (A, Nat) -> B) : [B] {\n  Prim.Array_tabulate<B>(xs.size(), func (i : Nat) : B {\n    f(xs[i], i);\n  });\n}"},"mapResult":{"desc":"Maps a Result-returning function over an Array and returns either\nthe first error or an array of successful values.\n\n```motoko\nimport Array \"mo:base/Array\";\nimport Result \"mo:base/Result\";\nimport Int \"mo:base/Int\";\nfunc makeNatural(x : Int) : Result.Result<Nat, Text> =\n  if (x >= 0) {\n    #ok(Int.abs(x))\n  } else {\n    #err(Int.toText(x) # \" is not a natural number.\")\n  };\n\nassert(Array.mapResult<Int, Nat, Text>([0, 1, 2], makeNatural) == #ok([0, 1, 2]));\nassert(Array.mapResult([-1, 0, 1], makeNatural) == #err(\"-1 is not a natural number.\"));\n```","body":"public func mapResult<A, R, E>(xs : [A], f : A -> Result.Result<R, E>) : Result.Result<[R], E> {\n  let len : Nat = xs.size();\n  var target : [var R] = [var];\n  var i : Nat = 0;\n  var isInit = false;\n  while (i < len) {\n    switch (f(xs[i])) {\n      case (#err(err)) return #err(err);\n      case (#ok(ok)) {\n        if (not isInit) {\n          isInit := true;\n          target := init(len, ok);\n        } else {\n          target[i] := ok\n        }\n      };\n    };\n    i += 1;\n  };\n  #ok(freeze(target))\n}"},"make":{"desc":"Make an array from a single value.","body":"public func make<A>(x: A) : [A] {\n  [x];\n}"},"vals":{"desc":"Returns `xs.vals()`.","body":"public func vals<A>(xs : [A]) : I.Iter<A> {\n  xs.vals()\n}"},"keys":{"desc":"Returns `xs.keys()`.","body":"public func keys<A>(xs : [A]) : I.Iter<Nat> {\n  xs.keys()\n}"},"thaw":{"desc":"Transform an immutable array into a mutable array.","body":"public func thaw<A>(xs : [A]) : [var A] {\n  let xsSize = xs.size();\n  if (xsSize == 0) {\n    return [var];\n  };\n  let ys = Prim.Array_init<A>(xsSize, xs[0]);\n  for (i in ys.keys()) {\n    ys[i] := xs[i];\n  };\n  ys;\n}"},"init":{"desc":"Initialize a mutable array with `size` copies of the initial value.","body":"public func init<A>(size : Nat,  initVal : A) : [var A] {\n  Prim.Array_init<A>(size, initVal);\n}"},"tabulate":{"desc":"Initialize an immutable array of the given size, and use the `gen` function to produce the initial value for every index.","body":"public func tabulate<A>(size : Nat,  gen : Nat -> A) : [A] {\n  Prim.Array_tabulate<A>(size, gen);\n}"},"tabulateVar":{"desc":"Initialize a mutable array using a generation function","body":"public func tabulateVar<A>(size : Nat,  gen : Nat -> A) : [var A] {\n  if (size == 0) { return [var] };\n  let xs = Prim.Array_init<A>(size, gen(0));\n  for (i in range(1, size - 1)) {\n    xs[i] := gen(i);\n  };\n  return xs;\n}"},"reverse":{"desc":"","body":"public func reverse<A>(xs : [A]) : [A] {\n  let size = xs.size();\n  tabulate(size, func (n : Nat) : A {\n    xs[size - 1 - n];\n  });\n}"},"buffer":{"desc":"","body":"public func buffer<A>(xs : [A]) : Buffer.Buffer<A> {\n  let buff = Buffer.Buffer<A>(xs.size());\n  for (x in xs.vals()) {\n    buff.add(x)\n  };\n  buff\n}"},"class.next":{"desc":"","body":"public func next() : ?Nat {\n  if (i > y) {\n     null\n  } else {\n    let j = i;\n    i += 1;\n    ?j\n  }\n}"}},"other":"// Copy from `Iter.mo`, but `Iter` depends on `Array`.\nclass range(x : Nat, y : Int) {\n  var i = x;\n};","test":"import Array \"mo:base/Array\";\nimport Debug \"mo:base/Debug\";\nimport Int \"mo:base/Int\";\nimport M \"mo:matchers/Matchers\";\nimport Nat \"../src/Nat\";\nimport Result \"mo:base/Result\";\nimport Suite \"mo:matchers/Suite\";\nimport T \"mo:matchers/Testable\";\nimport Text \"mo:base/Text\";\n\nlet findTest = do {\n  type Element = {\n    key : Text;\n    value : Int;\n  };\n\n  let xs = [\n    { key = \"a\"; value = 0; },\n    { key = \"b\"; value = 1; },\n    { key = \"c\"; value = 2; },\n  ];\n\n  let actual : ?Element = Array.find<Element>(xs, func (x : Element) : Bool {\n    x.key == \"b\";\n  });\n\n  let elementTestable : T.Testable<Element> = {\n    display = func (e : Element) : Text {\n      \"{ key = \" # T.textTestable.display(e.key) # \";\" #\n      \" value = \" # T.intTestable.display(e.value) #\n      \" }\"\n    };\n    equals = func (e1 : Element, e2 : Element) : Bool =\n      e1.key == e2.key and e1.value == e2.value;\n  };\n\n  Suite.test(\n    \"find\",\n    actual,\n    M.equals<?Element>(T.optional(elementTestable, ?({ key = \"b\"; value = 1 })))\n  )\n};\n\nlet mapEntriesTest = do {\n\n  let isEven = func (x : Int) : Bool {\n    x % 2 == 0;\n  };\n\n  let xs = [ 1, 2, 3, 4, 5, 6 ];\n\n  let actual = Array.mapEntries<Int, (Bool, Bool)>(\n    xs, func (value : Int, index : Nat) : (Bool, Bool) {\n      (isEven value, isEven index)\n    });\n\n  let expected = [\n    (false, true),\n    (true, false),\n    (false, true),\n    (true, false),\n    (false, true),\n    (true, false),\n  ];\n\n  Suite.test(\n    \"mapEntries\",\n    actual,\n    M.equals<[(Bool, Bool)]>(T.array(T.tuple2Testable(T.boolTestable, T.boolTestable), expected))\n  )\n};\n\nfunc makeNatural(x : Int) : Result.Result<Nat, Text> =\n  if (x >= 0) { #ok(Int.abs(x)) } else { #err(Int.toText(x) # \" is not a natural number.\") };\n\nfunc arrayRes(itm : Result.Result<[Nat], Text>) : T.TestableItem<Result.Result<[Nat], Text>> {\n  let resT = T.resultTestable(T.arrayTestable<Nat>(T.intTestable), T.textTestable);\n  { display = resT.display; equals = resT.equals; item = itm }\n};\n\nlet mapResult = Suite.suite(\"mapResult\", [\n  Suite.test(\"empty array\",\n    Array.mapResult<Int, Nat, Text>([], makeNatural),\n    M.equals(arrayRes(#ok([])))\n  ),\n  Suite.test(\"success\",\n    Array.mapResult<Int, Nat, Text>([ 1, 2, 3 ], makeNatural),\n    M.equals(arrayRes(#ok([1, 2, 3])))\n  ),\n  Suite.test(\"fail fast\",\n    Array.mapResult<Int, Nat, Text>([ -1, 2, 3 ], makeNatural),\n    M.equals(arrayRes(#err(\"-1 is not a natural number.\")))\n  ),\n  Suite.test(\"fail last\",\n    Array.mapResult<Int, Nat, Text>([ 1, 2, -3 ], makeNatural),\n    M.equals(arrayRes(#err(\"-3 is not a natural number.\")))\n  ),\n]);\n\nfunc arrayNat(xs : [Nat]) : T.TestableItem<[Nat]> {\n  T.array(T.natTestable, xs)\n};\n\nlet sort = Suite.suite(\"sort\", [\n  Suite.test(\"empty array\",\n    Array.sort([], Nat.compare),\n    M.equals(arrayNat([]))\n  ),\n  Suite.test(\"already sorted\",\n    Array.sort([1, 2, 3, 4, 5], Nat.compare),\n    M.equals(arrayNat([1, 2, 3, 4, 5]))\n  ),\n  Suite.test(\"reversed array\",\n    Array.sort([3, 2, 1], Nat.compare),\n    M.equals(arrayNat([1, 2, 3]))\n  ),\n  Suite.test(\"repeated elements\",\n    Array.sort([2, 2, 2, 2, 2], Nat.compare),\n    M.equals(arrayNat([2, 2, 2, 2, 2]))\n  )\n]);\n\nlet suite = Suite.suite(\"Array\", [\n  mapResult,\n  sort,\n  Suite.test(\n    \"append\",\n    Array.append<Int>([ 1, 2, 3 ], [ 4, 5, 6 ]),\n    M.equals(T.array<Int>(T.intTestable, [ 1, 2, 3, 4, 5, 6 ]))),\n  Suite.test(\n    \"chain\",\n    do {\n      let purePlusOne = func (x : Int) : [Int] { [ x + 1 ] };\n      Array.chain<Int, Int>([ 0, 1, 2 ], purePlusOne);\n    },\n    M.equals(T.array<Int>(T.intTestable, [ 1, 2, 3 ]))\n  ),\n  Suite.test(\n    \"filter\",\n    do {\n      let isEven = func (x : Nat) : Bool { x % 2 == 0 };\n      Array.filter([ 1, 2, 3, 4, 5, 6 ], isEven);\n    },\n    M.equals(T.array<Nat>(T.natTestable, [ 2, 4, 6 ]))\n  ),\n  Suite.test(\n    \"mapFilter\",\n    do {\n      let isEven = func (x : Nat) : ?Nat { if (x % 2 == 0) ?x else null };\n      Array.mapFilter([ 1, 2, 3, 4, 5, 6 ], isEven);\n    },\n    M.equals(T.array<Nat>(T.natTestable, [ 2, 4, 6 ]))\n  ),\n  findTest,\n  Suite.test(\n    \"foldLeft\",\n    Array.foldLeft<Text, Text>([ \"a\", \"b\", \"c\" ], \"\", Text.concat),\n    M.equals(T.text(\"abc\"))\n  ),\n  Suite.test(\n    \"foldRight\",\n    Array.foldRight<Text, Text>([ \"a\", \"b\", \"c\" ], \"\", Text.concat),\n    M.equals(T.text(\"abc\"))\n  ),\n  Suite.test(\n    \"freeze\",\n    do {\n      var xs : [var Int] = [ var 1, 2, 3 ];\n      Array.freeze<Int>(xs);\n    },\n    M.equals(T.array<Int>(T.intTestable, [ 1, 2, 3 ]))\n  ),\n  Suite.test(\n    \"flatten\",\n    Array.flatten<Int>([ [ 1, 2, 3 ] ]),\n    M.equals(T.array<Int>(T.intTestable, [ 1, 2, 3 ]))\n  ),\n  Suite.test(\n    \"map\",\n    do {\n      let isEven = func (x : Int) : Bool {\n        x % 2 == 0;\n      };\n\n      Array.map<Int, Bool>([ 1, 2, 3, 4, 5, 6 ], isEven);\n    },\n    M.equals(T.array<Bool>(T.boolTestable, [ false, true, false, true, false, true ]))\n  ),\n  mapEntriesTest,\n  Suite.test(\n    \"make\",\n    Array.make<Int>(0),\n    M.equals(T.array<Int>(T.intTestable, [0]))\n  ),\n  Suite.test(\n    \"thaw\",\n    do {\n      let xs : [Int] = [ 1, 2, 3 ];\n      Array.freeze(Array.thaw<Int>(xs))\n    },\n    M.equals(T.array<Int>(T.intTestable, [ 1, 2, 3]))\n  ),\n  Suite.test(\n    \"tabulateVar\",\n    do {\n      // regression test for (fixed) issues in base cases, where func was called too often:\n      let test0 = Array.tabulateVar<Nat>(0, func (i:Nat) { assert(false); 0 });\n      let test1 = Array.tabulateVar<Nat>(1, func (i:Nat) { assert(i < 1); 0 });\n      let test2 = Array.tabulateVar<Nat>(2, func (i:Nat) { assert(i < 2); 0 });\n      let test3 = Array.tabulateVar<Nat>(3, func (i:Nat) { assert(i < 3); 0 });\n      0\n    },\n    M.equals(T.nat(0))\n  ),\n  Suite.test(\n    \"reverse\",\n    Array.reverse<Nat>([0, 1, 2, 3]),\n    M.equals(T.array<Nat>(T.natTestable, [3, 2, 1, 0]))\n  ),\n  Suite.test(\n    \"buffer\",\n    Array.buffer<Nat>([0, 1, 2, 3]).toArray(),\n    M.equals(T.array<Nat>(T.natTestable, [0, 1, 2, 3]))\n  )\n]);\n\nSuite.run(suite);\n"}