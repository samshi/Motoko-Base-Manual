modules.Hash={"imports":{"mo:â›”":"Prim","Iter":"Iter"},"functions":{"Hash":{"desc":"Hash values represent a string of _hash bits_, packed into a `Nat32`.","body":"public type Hash= Nat32;"},"length":{"desc":"// The hash length, always 31.","body":"public let length: Nat = 31; // Why not 32?"},"bit":{"desc":"// Project a given bit from the bit vector.","body":"public func bit(h : Hash, pos : Nat) : Bool {\n  assert (pos <= length);\n  (h & (Prim.natToNat32(1) << Prim.natToNat32(pos))) != Prim.natToNat32(0)\n}"},"equal":{"desc":"Test if two hashes are equal","body":"public func equal(ha : Hash, hb : Hash) : Bool {\n  ha == hb\n}"},"hash":{"desc":"Computes a hash from the least significant 32-bits of `n`, ignoring other bits.\n@deprecated For large `Nat` values consider using a bespoke hash function that considers all of the argument's bits.","body":"public func hash(n : Nat) : Hash {\n  let j = Prim.intToNat32Wrap(n);\n  hashNat8(\n    [j & (255 << 0),\n     j & (255 << 8),\n     j & (255 << 16),\n     j & (255 << 24)\n    ]);\n}"},"debugPrintBits":{"desc":"@deprecated This function will be removed in future.","body":"public func debugPrintBits(bits : Hash) {\n  for (j in Iter.range(0, length - 1)) {\n    if (bit(bits, j)) {\n      Prim.debugPrint(\"1\")\n    } else {\n      Prim.debugPrint(\"0\")\n    }\n  }\n}"},"debugPrintBitsRev":{"desc":"@deprecated This function will be removed in future.","body":"public func debugPrintBitsRev(bits : Hash) {\n  for (j in Iter.revRange(length - 1, 0)) {\n    if (bit(bits, Prim.abs(j))) {\n      Prim.debugPrint(\"1\")\n    } else {\n      Prim.debugPrint(\"0\")\n    }\n  }\n}"},"hashNat8":{"desc":"should this really be public?\nNB: Int.mo contains a local copy of hashNat8 (redefined to suppress the deprecation warning).\n@deprecated This function may be removed or changed in future.","body":"public func hashNat8(key : [Hash]) : Hash {\n  var hash : Nat32 = 0;\n  for (natOfKey in key.vals()) {\n    hash := hash +% natOfKey;\n    hash := hash +% hash << 10;\n    hash := hash ^ (hash >> 6);\n  };\n  hash := hash +% hash << 3;\n  hash := hash ^ (hash >> 11);\n  hash := hash +% hash << 15;\n  return hash;\n}"}},"other":";\n/// Jenkin's one at a time:\n/// https://en.wikipedia.org/wiki/Jenkins_hash_function#one_at_a_time\n/// The input type should actually be `[Nat8]`.\n/// Note: Be sure to explode each `Nat8` of a `Nat32` into its own `Nat32`, and to shift into lower 8 bits.","test":""}