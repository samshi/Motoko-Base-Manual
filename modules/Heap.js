modules.Heap={"imports":{"Order":"O","Prelude":"P","List":"L","Iter":"I"},"functions":{"fromIter":{"desc":"Convert iterator into a heap in O(N) time.","body":"public func fromIter<T>(iter : I.Iter<T>, ord : (T, T) -> O.Order) : Heap<T> {\n  let heap = Heap<T>(ord);\n  func build(xs : L.List<Tree<T>>) : Tree<T> {\n    func join(xs : L.List<Tree<T>>) : L.List<Tree<T>> {\n      switch(xs) {\n        case (null) { null };\n        case (?(hd, null)) { ?(hd, null) };\n        case (?(h1, ?(h2, tl))) { ?(merge(h1, h2, ord), join(tl)) };\n      }\n    };\n    switch(xs) {\n      case null { P.unreachable() };\n      case (?(hd, null)) { hd };\n      case _ { build(join(xs)) };\n    };\n  };\n  let list = I.toList(I.map(iter, func (x : T) : Tree<T> { ?(1, x, null, null) } ));\n  if (not L.isNil(list)) {\n    let t = build(list);\n    heap.unsafeUnshare(t);\n  };\n  heap\n}"},"class.share":{"desc":"Get purely-functional representation","body":"public func share() : Tree<T> {\n  heap\n}"},"class.unsafeUnshare":{"desc":"Put purely-functional representation into class. Need to make sure the tree is constructed with the same compare function","body":"public func unsafeUnshare(t : Tree<T>) {\n  heap := t;\n}"},"class.put":{"desc":"Insert an element to the heap","body":"public func put(x : T) {\n  heap := merge(heap, ?(1, x, null, null), ord);\n}"},"class.peekMin":{"desc":"Return the minimal element","body":"public func peekMin() : ?T {\n  switch heap {\n    case (null) { null };\n    case (?(_, x, _, _)) { ?x };\n  }\n}"},"class.deleteMin":{"desc":"Delete the minimal element","body":"public func deleteMin() {\n  switch heap {\n    case null {};\n    case (?(_, _, a, b)) { heap := merge(a, b, ord) };\n  }\n}"},"class.removeMin":{"desc":"Remove the minimal element and return its value","body":"public func removeMin() : ?T {\n  switch heap {\n    case null { null };\n    case (?(_, x, a, b)) {\n      heap := merge(a, b, ord);\n      ?x\n    };\n  }\n}"}},"other":"public type Tree<T> = ?(Int, T, Tree<T>, Tree<T>);\npublic class Heap<T>(ord : (T, T) -> O.Order) {\n  var heap : Tree<T> = null;\n};\nfunc rank<T>(heap : Tree<T>) : Int {\n  switch heap {\n    case null { 0 };\n    case (?(r, _, _, _)) { r };\n  }\n};\nfunc makeT<T>(x : T, a : Tree<T>, b : Tree<T>) : Tree<T> {\n  if (rank(a) >= rank(b)) {\n      ?(rank(b) + 1, x, a, b)\n  } else {\n      ?(rank(a) + 1, x, b, a)\n  };\n};\nfunc merge<T>(h1 : Tree<T>, h2 : Tree<T>, ord : (T, T) -> O.Order) : Tree<T> {\n  switch (h1, h2) {\n    case (null, h) { h };\n    case (h, null) { h };\n    case (?(_, x, a, b), ?(_, y, c, d)) {\n      switch (ord(x,y)) {\n        case (#less) { makeT(x, a, merge(b, h2, ord)) };\n        case _ { makeT(y, c, merge(d, h1, ord)) };\n      };\n    };\n  };\n};","test":"import H \"mo:base/Heap\";\nimport I \"mo:base/Iter\";\nimport O \"mo:base/Option\";\nimport Int \"mo:base/Int\";\n\nlet order = Int.compare;\n\ndo {\n    var pq = H.Heap<Int>(order);\n    for (i in I.revRange(100, 0)) {\n        pq.put(i);\n        let x = pq.peekMin();\n        assert(O.unwrap(x) == i);\n    };\n    for (i in I.range(0, 100)) {\n        pq.put(i);\n        let x = pq.peekMin();\n        assert(O.unwrap(x) == 0);\n    };\n    for (i in I.range(0, 100)) {\n        pq.deleteMin();\n        let x = pq.peekMin();\n        pq.deleteMin();\n        assert(O.unwrap(x) == i);\n    };\n    O.assertNull(pq.peekMin());\n};\n\n// fromIter\ndo {\n    do {\n        let iter = [5,10,9,7,3,8,1,0,2,4,6].vals();\n        let pq = H.fromIter<Int>(iter, order);\n        for (i in I.range(0, 10)) {\n            let x = pq.peekMin();\n            assert(O.unwrap(x) == i);\n            pq.deleteMin();\n        };\n        O.assertNull(pq.peekMin());\n    };\n\n    do {\n        let pq = H.fromIter<Int>([].vals(), order);\n        O.assertNull(pq.peekMin());\n    };\n\n    do {\n        let pq = H.fromIter<Int>([100].vals(), order);\n        assert(O.unwrap(pq.peekMin()) == 100);\n    };\n};\n"}