modules.Deque={"imports":{"List":"List","Prelude":"P"},"functions":{"Deque":{"desc":"Double-ended queue","body":"public type Deque<T> = (List<T>, List<T>);"},"empty":{"desc":"// Empty queue","body":"public func empty<T> () : Deque<T> { (List.nil(), List.nil()); };"},"isEmpty":{"desc":"// True when the queue is empty","body":"public func isEmpty<T>(q : Deque<T>) : Bool {\n  switch q {\n    case (f, r) { List.isNil(f) and List.isNil(r) };\n  }\n}"},"pushFront":{"desc":"Insert a new element on the front end of the queue","body":"public func pushFront<T>(q : Deque<T>, x : T) : Deque<T> {\n  check (List.push(x, q.0), q.1);\n}"},"peekFront":{"desc":"Inspect the (optional) first element on the front end of the queue","body":"public func peekFront<T>(q : Deque<T>) : ?T {\n  switch q {\n    case (?(x, f), r) { ?x };\n    case (null, ?(x, r)) { ?x };\n    case _ { null };\n  };\n}"},"popFront":{"desc":"Remove the first element on the front end of the queue; Returns null when empty.","body":"public func popFront<T>(q : Deque<T>) : ?(T, Deque<T>) {\n  switch q {\n    case (?(x, f), r) { ?(x, check(f, r)) };\n    case (null, ?(x, r)) { ?(x, check(null, r)) };\n    case _ { null };\n  };\n}"},"pushBack":{"desc":"Insert a new element on the back end of the queue","body":"public func pushBack<T>(q : Deque<T>, x : T) : Deque<T> {\n  check (q.0, List.push(x, q.1));\n}"},"peekBack":{"desc":"Inspect the (optional) first element on the back end of the queue","body":"public func peekBack<T>(q : Deque<T>) : ?T {\n  switch q {\n    case (f, ?(x, r)) { ?x };\n    case (?(x, r), null) { ?x };\n    case _ { null };\n  };\n}"},"popBack":{"desc":"Remove the first element on the back end of the queue; Returns null when empty.","body":"public func popBack<T>(q : Deque<T>) : ?(Deque<T>, T) {\n  switch q {\n    case (f, ?(x, r)) { ?(check(f, r), x) };\n    case (?(x, f), null) { ?(check(f, null), x) };\n    case _ { null };\n  };\n}"}},"related":"type List<T> = List.List<T>;\nfunc check<T>(q : Deque<T>) : Deque<T> {\n  switch q {\n    case (null, r) { let (a,b) = List.split(List.size(r) / 2, r); (List.reverse(b), a) };\n    case (f, null) { let (a,b) = List.split(List.size(f) / 2, f); (a, List.reverse(b)) };\n    case q { q };\n  }\n};","test":"import Deque \"mo:base/Deque\";\nimport Iter \"mo:base/Iter\";\nimport O \"mo:base/Option\";\nimport D \"mo:base/Debug\";\n\n// test for Queue\ndo {\n    var l = Deque.empty<Nat>();\n    for (i in Iter.range(0, 100)) {\n        l := Deque.pushBack(l, i);\n    };\n    for (i in Iter.range(0, 100)) {\n        let x = Deque.peekFront(l);\n        switch (Deque.popFront(l)) {\n          case (?(y, l2)) { l := l2;\n             switch x {\n               case null assert false;\n               case (?x) assert (x == y) } };\n          case null { assert false };\n        };\n        assert(O.unwrap(x) == i);\n    };\n    O.assertNull(Deque.peekFront<Nat>(l));\n};\n\n// test for Deque\ndo {\n    var l = Deque.empty<Int>();\n    for (i in Iter.range(1, 100)) {\n        l := Deque.pushFront(l, -i);\n        l := Deque.pushBack(l, i);\n    };\n    label F for (i in Iter.revRange(100, -100)) {\n        if (i == 0) continue F;\n        let x = Deque.peekBack(l);\n        switch (Deque.popBack(l)) {\n          case (?(l2, y)) { l := l2;\n             switch x {\n               case null assert false;\n               case (?x) assert (x == y) } };\n          case null { assert false };\n        };\n        assert(O.unwrap(x) == i);\n    };\n};\n"}