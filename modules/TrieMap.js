modules.TrieMap={"imports":{"Trie":"T","Prelude":"P","Iter":"I","Hash":"Hash","List":"List"},"functions":{"TrieMap":{"desc":"","body":"public class TrieMap<K, V> (isEq : (K, K) -> Bool, hashOf :  K -> Hash.Hash) {\n\n  var map = T.empty<K, V>();\n  var _size : Nat = 0;\n\n  /// Returns the number of entries in the map.\n  public func size() : Nat { _size };\n\n  /// Associate a key and value, overwriting any prior association for the key.\n  public func put(k : K, v : V) =\n    ignore replace(k, v);\n\n  /// Put the key and value, _and_ return the (optional) prior value for the key.\n  public func replace(k : K, v : V) : ?V {\n    let keyObj = { key = k; hash = hashOf(k) };\n    let (map2, ov) =\n      T.put<K,V>(map, keyObj, isEq, v);\n    map := map2;\n    switch (ov) {\n      case null { _size += 1 };\n      case _ {}\n    };\n    ov\n  };\n\n  /// Get the (optional) value associated with the given key.\n  public func get(k : K) : ?V {\n    let keyObj = {key = k; hash = hashOf(k);};\n    T.find<K, V>(map, keyObj, isEq)\n  };\n\n  /// Delete the (optional) value associated with the given key.\n  public func delete(k : K) =\n    ignore remove(k);\n\n  /// Delete and return the (optional) value associated with the given key.\n  public func remove(k : K) : ?V {\n    let keyObj = { key = k; hash = hashOf(k) };\n    let (t, ov) = T.remove<K, V>(map, keyObj, isEq);\n    map := t;\n    switch (ov) {\n      case null {};\n      case (?_) { _size -= 1 }\n    };\n    ov\n  };\n\n  /// An `Iter` over the keys.\n  ///\n  /// Each iterator gets a _persistent view_ of the mapping, independent of concurrent updates to the iterated map.\n  public func keys() : I.Iter<K>\n  { I.map(entries(), func (kv : (K, V)) : K { kv.0 }) };\n\n  /// An `Iter` over the values.\n  ///\n  /// Each iterator gets a _persistent view_ of the mapping, independent of concurrent updates to the iterated map.\n  public func vals() : I.Iter<V>\n  { I.map(entries(), func (kv : (K, V)) : V { kv.1 }) };\n\n  /// Returns an `Iter` over the entries.\n  ///\n  /// Each iterator gets a _persistent view_ of the mapping, independent of concurrent updates to the iterated map.\n  public func entries() : I.Iter<(K, V)> {\n    object {\n      var stack = ?(map, null) : List.List<T.Trie<K, V>>;\n      public func next() : ?(K, V) {\n        switch stack {\n          case null { null };\n          case (?(trie, stack2)) {\n            switch trie {\n              case (#empty) {\n                stack := stack2;\n                next()\n              };\n              case (#leaf({keyvals = null})) {\n                stack := stack2;\n                next()\n              };\n              case (#leaf({size = c; keyvals = ?((k, v), kvs)})) {\n                stack := ?(#leaf({size=c-1; keyvals=kvs}), stack2);\n                ?(k.key, v)\n              };\n              case (#branch(br)) {\n                stack := ?(br.left, ?(br.right, stack2));\n                next()\n              };\n            }\n          }\n        }\n      }\n    }\n  }\n}"},"clone":{"desc":"Clone the map, given its key operations.","body":"public func clone<K, V>(\n  h : TrieMap<K, V>,\n  keyEq : (K,K) -> Bool,\n  keyHash : K -> Hash.Hash\n) : TrieMap<K, V> {\n  let h2 = TrieMap<K, V>(keyEq, keyHash);\n  for ((k, v) in h.entries()) {\n    h2.put(k, v);\n  };\n  h2\n}"},"fromEntries":{"desc":"Clone an iterator of key-value pairs.","body":"public func fromEntries<K, V>(\n  entries : I.Iter<(K, V)>,\n  keyEq : (K, K) -> Bool,\n  keyHash : K -> Hash.Hash\n) : TrieMap<K, V> {\n  let h = TrieMap<K, V>(keyEq, keyHash);\n  for ((k, v) in entries) {\n    h.put(k, v);\n  };\n  h\n}"},"map":{"desc":"Transform (map) the values of a map, retaining its keys.","body":"public func map<K, V1, V2> (\n  h : TrieMap<K, V1>,\n  keyEq : (K, K) -> Bool,\n  keyHash : K -> Hash.Hash,\n  mapFn : (K, V1) -> V2,\n) : TrieMap<K, V2> {\n  let h2 = TrieMap<K, V2>(keyEq, keyHash);\n  for ((k, v1) in h.entries()) {\n    let v2 = mapFn(k, v1);\n    h2.put(k, v2);\n  };\n  h2\n}"},"mapFilter":{"desc":"Transform and filter the values of a map, retaining its keys.","body":"public func mapFilter<K, V1, V2>(\n  h : TrieMap<K, V1>,\n  keyEq : (K, K) -> Bool,\n  keyHash : K -> Hash.Hash,\n  mapFn : (K, V1) -> ?V2,\n) : TrieMap<K, V2> {\n  let h2 = TrieMap<K, V2>(keyEq, keyHash);\n  for ((k, v1) in h.entries()) {\n    switch (mapFn(k, v1)) {\n      case null { };\n      case (?v2) {\n        h2.put(k, v2);\n      };\n    }\n  };\n  h2\n}"}},"related":"","test":"import Prim \"mo:â›”\";\nimport H \"mo:base/TrieMap\";\nimport Hash \"mo:base/Hash\";\nimport Text \"mo:base/Text\";\n\ndebug {\n  let a = H.TrieMap<Text, Nat>(Text.equal, Text.hash);\n\n  assert a.size() == 0;\n  ignore a.remove(\"apple\");\n  assert a.size() == 0;\n\n  a.put(\"apple\", 1);\n  assert a.size() == 1;\n  ignore a.remove(\"apple\");\n  assert a.size() == 0;\n\n  a.put(\"apple\", 1);\n  a.put(\"banana\", 2);\n  a.put(\"pear\", 3);\n  a.put(\"avocado\", 4);\n  a.put(\"Apple\", 11);\n  a.put(\"Banana\", 22);\n  a.put(\"Pear\", 33);\n  a.put(\"Avocado\", 44);\n  a.put(\"ApplE\", 111);\n  a.put(\"BananA\", 222);\n  a.put(\"PeaR\", 333);\n  a.put(\"AvocadO\", 444);\n\n  // need to resupply the constructor args; they are private to the object; but, should they be?\n  let b = H.clone<Text, Nat>(a, Text.equal, Text.hash);\n\n  // ensure clone has each key-value pair present in original\n  for ((k,v) in a.entries()) {\n    Prim.debugPrint(debug_show (k,v));\n    switch (b.get(k)) {\n    case null { assert false };\n    case (?w) { assert v == w };\n    };\n  };\n\n  // ensure clone has each key present in original\n  for (k in a.keys()) {\n    switch (b.get(k)) {\n    case null { assert false };\n    case (?_) {  };\n    };\n  };\n\n  // ensure clone has each value present in original\n  for (v in a.vals()) {\n    var foundMatch = false;\n    for (w in b.vals()) {\n      if (v == w) { foundMatch := true }\n    };\n    assert foundMatch\n  };\n\n  // ensure original has each key-value pair present in clone\n  for ((k,v) in b.entries()) {\n    Prim.debugPrint(debug_show (k,v));\n    switch (a.get(k)) {\n    case null { assert false };\n    case (?w) { assert v == w };\n    };\n  };\n\n  // do some more operations:\n  a.put(\"apple\", 1111);\n  a.put(\"banana\", 2222);\n  a.delete(\"pear\");\n  a.delete(\"avocado\");\n\n  // check them:\n  switch (a.get(\"apple\")) {\n  case (?1111) { };\n  case _ { assert false };\n  };\n  switch (a.get(\"banana\")) {\n  case (?2222) { };\n  case _ { assert false };\n  };\n  switch (a.get(\"pear\")) {\n  case null {  };\n  case (?_) { assert false };\n  };\n  switch (a.get(\"avocado\")) {\n  case null {  };\n  case (?_) { assert false };\n  };\n\n  // undo operations above:\n  a.put(\"apple\", 1);\n  a.put(\"banana\", 2);\n  a.put(\"pear\", 3);\n  a.put(\"avocado\", 4);\n\n  // ensure clone has each key-value pair present in original\n  for ((k,v) in a.entries()) {\n    Prim.debugPrint(debug_show (k,v));\n    switch (b.get(k)) {\n    case null { assert false };\n    case (?w) { assert v == w };\n    };\n  };\n\n  // ensure original has each key-value pair present in clone\n  for ((k,v) in b.entries()) {\n    Prim.debugPrint(debug_show (k,v));\n    switch (a.get(k)) {\n    case null { assert false };\n    case (?w) { assert v == w };\n    };\n  };\n\n\n  // test fromEntries method\n  let c = H.fromEntries<Text, Nat>(b.entries(), Text.equal, Text.hash);\n\n  // c agrees with each entry of b\n  for ((k,v) in b.entries()) {\n    Prim.debugPrint(debug_show (k,v));\n    switch (c.get(k)) {\n    case null { assert false };\n    case (?w) { assert v == w };\n    };\n  };\n\n  // b agrees with each entry of c\n  for ((k,v) in c.entries()) {\n    Prim.debugPrint(debug_show (k,v));\n    switch (b.get(k)) {\n    case null { assert false };\n    case (?w) { assert v == w };\n    };\n  };\n};\n"}