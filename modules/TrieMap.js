modules.TrieMap={"imports":{"Trie":"T","Prelude":"P","Iter":"I","Hash":"Hash","List":"List"},"functions":{"clone":{"desc":"Clone the map, given its key operations.","body":"public func clone<K, V>(\n  h : TrieMap<K, V>,\n  keyEq : (K,K) -> Bool,\n  keyHash : K -> Hash.Hash\n) : TrieMap<K, V> {\n  let h2 = TrieMap<K, V>(keyEq, keyHash);\n  for ((k, v) in h.entries()) {\n    h2.put(k, v);\n  };\n  h2\n}"},"fromEntries":{"desc":"Clone an iterator of key-value pairs.","body":"public func fromEntries<K, V>(\n  entries : I.Iter<(K, V)>,\n  keyEq : (K, K) -> Bool,\n  keyHash : K -> Hash.Hash\n) : TrieMap<K, V> {\n  let h = TrieMap<K, V>(keyEq, keyHash);\n  for ((k, v) in entries) {\n    h.put(k, v);\n  };\n  h\n}"},"map":{"desc":"Transform (map) the values of a map, retaining its keys.","body":"public func map<K, V1, V2> (\n  h : TrieMap<K, V1>,\n  keyEq : (K, K) -> Bool,\n  keyHash : K -> Hash.Hash,\n  mapFn : (K, V1) -> V2,\n) : TrieMap<K, V2> {\n  let h2 = TrieMap<K, V2>(keyEq, keyHash);\n  for ((k, v1) in h.entries()) {\n    let v2 = mapFn(k, v1);\n    h2.put(k, v2);\n  };\n  h2\n}"},"mapFilter":{"desc":"Transform and filter the values of a map, retaining its keys.","body":"public func mapFilter<K, V1, V2>(\n  h : TrieMap<K, V1>,\n  keyEq : (K, K) -> Bool,\n  keyHash : K -> Hash.Hash,\n  mapFn : (K, V1) -> ?V2,\n) : TrieMap<K, V2> {\n  let h2 = TrieMap<K, V2>(keyEq, keyHash);\n  for ((k, v1) in h.entries()) {\n    switch (mapFn(k, v1)) {\n      case null { };\n      case (?v2) {\n        h2.put(k, v2);\n      };\n    }\n  };\n  h2\n}"},"class.size":{"desc":"Returns the number of entries in the map","body":"public func size() : Nat { _size };"},"class.put":{"desc":"Associate a key and value, overwriting any prior association for the key","body":"public func put(k : K, v : V) =\n  ignore replace(k, v);"},"class.replace":{"desc":"Put the key and value, _and_ return the (optional) prior value for the key.","body":"public func replace(k : K, v : V) : ?V {\n  let keyObj = { key = k; hash = hashOf(k) };\n  let (map2, ov) =\n    T.put<K,V>(map, keyObj, isEq, v);\n  map := map2;\n  switch (ov) {\n    case null { _size += 1 };\n    case _ {}\n  };\n  ov\n}"},"class.get":{"desc":"Get the (optional) value associated with the given key.","body":"public func get(k : K) : ?V {\n  let keyObj = {key = k; hash = hashOf(k);};\n  T.find<K, V>(map, keyObj, isEq)\n}"},"class.delete":{"desc":"Delete the (optional) value associated with the given key","body":"public func delete(k : K) =\n  ignore remove(k);"},"class.remove":{"desc":"Delete and return the (optional) value associated with the given key.","body":"public func remove(k : K) : ?V {\n  let keyObj = { key = k; hash = hashOf(k) };\n  let (t, ov) = T.remove<K, V>(map, keyObj, isEq);\n  map := t;\n  switch (ov) {\n    case null {};\n    case (?_) { _size -= 1 }\n  };\n  ov\n}"},"class.keys":{"desc":"An `Iter` over the keys.\n\nEach iterator gets a _persistent view_ of the mapping, independent of concurrent updates to the iterated map","body":"public func keys() : I.Iter<K>\n{ I.map(entries(), func (kv : (K, V)) : K { kv.0 }) };"},"class.vals":{"desc":"An `Iter` over the values.\n\nEach iterator gets a _persistent view_ of the mapping, independent of concurrent updates to the iterated map","body":"public func vals() : I.Iter<V>\n{ I.map(entries(), func (kv : (K, V)) : V { kv.1 }) };"},"class.entries":{"desc":"Returns an `Iter` over the entries.\n\nEach iterator gets a _persistent view_ of the mapping, independent of concurrent updates to the iterated map.","body":"public func entries() : I.Iter<(K, V)> {\n  object {\n    var stack = ?(map, null) : List.List<T.Trie<K, V>>;"}},"other":"public class TrieMap<K, V> (isEq : (K, K) -> Bool, hashOf :  K -> Hash.Hash) {\n  var map = T.empty<K, V>();\n  var _size : Nat = 0;\n};","test":"import Prim \"mo:â›”\";\nimport H \"mo:base/TrieMap\";\nimport Hash \"mo:base/Hash\";\nimport Text \"mo:base/Text\";\n\ndebug {\n  let a = H.TrieMap<Text, Nat>(Text.equal, Text.hash);\n\n  assert a.size() == 0;\n  ignore a.remove(\"apple\");\n  assert a.size() == 0;\n\n  a.put(\"apple\", 1);\n  assert a.size() == 1;\n  ignore a.remove(\"apple\");\n  assert a.size() == 0;\n\n  a.put(\"apple\", 1);\n  a.put(\"banana\", 2);\n  a.put(\"pear\", 3);\n  a.put(\"avocado\", 4);\n  a.put(\"Apple\", 11);\n  a.put(\"Banana\", 22);\n  a.put(\"Pear\", 33);\n  a.put(\"Avocado\", 44);\n  a.put(\"ApplE\", 111);\n  a.put(\"BananA\", 222);\n  a.put(\"PeaR\", 333);\n  a.put(\"AvocadO\", 444);\n\n  // need to resupply the constructor args; they are private to the object; but, should they be?\n  let b = H.clone<Text, Nat>(a, Text.equal, Text.hash);\n\n  // ensure clone has each key-value pair present in original\n  for ((k,v) in a.entries()) {\n    Prim.debugPrint(debug_show (k,v));\n    switch (b.get(k)) {\n    case null { assert false };\n    case (?w) { assert v == w };\n    };\n  };\n\n  // ensure clone has each key present in original\n  for (k in a.keys()) {\n    switch (b.get(k)) {\n    case null { assert false };\n    case (?_) {  };\n    };\n  };\n\n  // ensure clone has each value present in original\n  for (v in a.vals()) {\n    var foundMatch = false;\n    for (w in b.vals()) {\n      if (v == w) { foundMatch := true }\n    };\n    assert foundMatch\n  };\n\n  // ensure original has each key-value pair present in clone\n  for ((k,v) in b.entries()) {\n    Prim.debugPrint(debug_show (k,v));\n    switch (a.get(k)) {\n    case null { assert false };\n    case (?w) { assert v == w };\n    };\n  };\n\n  // do some more operations:\n  a.put(\"apple\", 1111);\n  a.put(\"banana\", 2222);\n  a.delete(\"pear\");\n  a.delete(\"avocado\");\n\n  // check them:\n  switch (a.get(\"apple\")) {\n  case (?1111) { };\n  case _ { assert false };\n  };\n  switch (a.get(\"banana\")) {\n  case (?2222) { };\n  case _ { assert false };\n  };\n  switch (a.get(\"pear\")) {\n  case null {  };\n  case (?_) { assert false };\n  };\n  switch (a.get(\"avocado\")) {\n  case null {  };\n  case (?_) { assert false };\n  };\n\n  // undo operations above:\n  a.put(\"apple\", 1);\n  a.put(\"banana\", 2);\n  a.put(\"pear\", 3);\n  a.put(\"avocado\", 4);\n\n  // ensure clone has each key-value pair present in original\n  for ((k,v) in a.entries()) {\n    Prim.debugPrint(debug_show (k,v));\n    switch (b.get(k)) {\n    case null { assert false };\n    case (?w) { assert v == w };\n    };\n  };\n\n  // ensure original has each key-value pair present in clone\n  for ((k,v) in b.entries()) {\n    Prim.debugPrint(debug_show (k,v));\n    switch (a.get(k)) {\n    case null { assert false };\n    case (?w) { assert v == w };\n    };\n  };\n\n\n  // test fromEntries method\n  let c = H.fromEntries<Text, Nat>(b.entries(), Text.equal, Text.hash);\n\n  // c agrees with each entry of b\n  for ((k,v) in b.entries()) {\n    Prim.debugPrint(debug_show (k,v));\n    switch (c.get(k)) {\n    case null { assert false };\n    case (?w) { assert v == w };\n    };\n  };\n\n  // b agrees with each entry of c\n  for ((k,v) in c.entries()) {\n    Prim.debugPrint(debug_show (k,v));\n    switch (b.get(k)) {\n    case null { assert false };\n    case (?w) { assert v == w };\n    };\n  };\n};\n"}