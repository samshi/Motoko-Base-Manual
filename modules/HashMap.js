modules.HashMap={"imports":{"mo:⛔":"Prim","Prelude":"P","Array":"A","Hash":"Hash","Iter":"Iter","AssocList":"AssocList"},"functions":{"clone":{"desc":"clone cannot be an efficient object method,\n...but is still useful in tests, and beyond.","body":"public func clone<K, V> (\n  h : HashMap<K, V>,\n  keyEq : (K, K) -> Bool,\n  keyHash : K -> Hash.Hash\n) : HashMap<K, V> {\n  let h2 = HashMap<K, V>(h.size(), keyEq, keyHash);\n  for ((k,v) in h.entries()) {\n    h2.put(k,v);\n  };\n  h2\n}"},"fromIter":{"desc":"Clone from any iterator of key-value pairs","body":"public func fromIter<K, V>(\n  iter : Iter.Iter<(K, V)>,\n  initCapacity : Nat,\n  keyEq : (K, K) -> Bool,\n  keyHash : K -> Hash.Hash\n) : HashMap<K, V> {\n  let h = HashMap<K, V>(initCapacity, keyEq, keyHash);\n  for ((k, v) in iter) {\n    h.put(k, v);\n  };\n  h\n}"},"map":{"desc":"","body":"public func map<K, V1, V2>(\n  h : HashMap<K, V1>,\n  keyEq : (K, K) -> Bool,\n  keyHash : K -> Hash.Hash,\n  mapFn : (K, V1) -> V2,\n) : HashMap<K, V2> {\n  let h2 = HashMap<K, V2>(h.size(), keyEq, keyHash);\n  for ((k, v1) in h.entries()) {\n    let v2 = mapFn(k, v1);\n    h2.put(k, v2);\n  };\n  h2\n}"},"mapFilter":{"desc":"","body":"public func mapFilter<K, V1, V2>(\n  h : HashMap<K, V1>,\n  keyEq : (K, K) -> Bool,\n  keyHash : K -> Hash.Hash,\n  mapFn : (K, V1) -> ?V2,\n) : HashMap<K, V2> {\n  let h2 = HashMap<K, V2>(h.size(), keyEq, keyHash);\n  for ((k, v1) in h.entries()) {\n    switch (mapFn(k, v1)) {\n      case null { };\n      case (?v2) {\n        h2.put(k, v2);\n      };\n    }\n  };\n  h2\n}"},"class.size":{"desc":"Returns the number of entries in this HashMap","body":"public func size() : Nat = _count;"},"class.delete":{"desc":"Deletes the entry with the key `k`. Doesn't do anything if the key doesn't\nexist","body":"public func delete(k : K) = ignore remove(k);"},"class.remove":{"desc":"Removes the entry with the key `k` and returns the associated value if it\nexisted or `null` otherwise.","body":"public func remove(k : K) : ?V {\n  let m = table.size();\n  if (m > 0) {\n    let h = Prim.nat32ToNat(keyHash(k));\n    let pos = h % m;\n    let (kvs2, ov) = AssocList.replace<K, V>(table[pos], k, keyEq, null);\n    table[pos] := kvs2;\n    switch(ov){\n      case null { };\n      case _ { _count -= 1; }\n    };\n    ov\n  } else {\n    null\n  };\n}"},"class.get":{"desc":"Gets the entry with the key `k` and returns its associated value if it\nexisted or `null` otherwise.","body":"public func get(k : K) : ?V {\n  let h = Prim.nat32ToNat(keyHash(k));\n  let m = table.size();\n  let v = if (m > 0) {\n    AssocList.find<K, V>(table[h % m], k, keyEq)\n  } else {\n    null\n  };\n}"},"class.put":{"desc":"Insert the value `v` at key `k`. Overwrites an existing entry with key `k","body":"public func put(k : K, v : V) = ignore replace(k, v);"},"class.replace":{"desc":"Insert the value `v` at key `k` and returns the previous value stored at\n`k` or `null` if it didn't exist.","body":"public func replace(k : K, v : V) : ?V {\n  if (_count >= table.size()) {\n    let size =\n      if (_count == 0) {\n        if (initCapacity > 0) {\n          initCapacity\n        } else {\n          1\n        }\n      } else {\n        table.size() * 2;\n      };\n    let table2 = A.init<KVs<K, V>>(size, null);\n    for (i in table.keys()) {\n      var kvs = table[i];\n      label moveKeyVals : ()\n      loop {\n        switch kvs {\n          case null { break moveKeyVals };\n          case (?((k, v), kvsTail)) {\n            let h = Prim.nat32ToNat(keyHash(k));\n            let pos2 = h % table2.size();\n            table2[pos2] := ?((k,v), table2[pos2]);\n            kvs := kvsTail;\n          };\n        }\n      };\n    };\n    table := table2;\n  };\n  let h = Prim.nat32ToNat(keyHash(k));\n  let pos = h % table.size();\n  let (kvs2, ov) = AssocList.replace<K, V>(table[pos], k, keyEq, ?v);\n  table[pos] := kvs2;\n  switch(ov){\n    case null { _count += 1 };\n    case _ {}\n  };\n  ov\n}"},"class.keys":{"desc":"An `Iter` over the keys","body":"public func keys() : Iter.Iter<K>\n{ Iter.map(entries(), func (kv : (K, V)) : K { kv.0 }) };"},"class.vals":{"desc":"An `Iter` over the values","body":"public func vals() : Iter.Iter<V>\n{ Iter.map(entries(), func (kv : (K, V)) : V { kv.1 }) };"},"class.entries":{"desc":"Returns an iterator over the key value pairs in this\n`HashMap`. Does _not_ modify the `HashMap`.","body":"public func entries() : Iter.Iter<(K, V)> {\n  if (table.size() == 0) {\n    object {"}},"other":"// key-val list type\ntype KVs<K, V> = AssocList.AssocList<K, V>;\n/// An imperative HashMap with a minimal object-oriented interface.\n/// Maps keys of type `K` to values of type `V`.\npublic class HashMap<K, V>(\n  initCapacity : Nat,\n  keyEq : (K, K) -> Bool,\n  keyHash : K -> Hash.Hash) {\n  var table : [var KVs<K, V>] = [var];\n  var _count : Nat = 0;\n};","test":"import Prim \"mo:⛔\";\nimport H \"mo:base/HashMap\";\nimport Hash \"mo:base/Hash\";\nimport Text \"mo:base/Text\";\n\ndebug {\n  let a = H.HashMap<Text, Nat>(3, Text.equal, Text.hash);\n\n  a.put(\"apple\", 1);\n  a.put(\"banana\", 2);\n  a.put(\"pear\", 3);\n  a.put(\"avocado\", 4);\n  a.put(\"Apple\", 11);\n  a.put(\"Banana\", 22);\n  a.put(\"Pear\", 33);\n  a.put(\"Avocado\", 44);\n  a.put(\"ApplE\", 111);\n  a.put(\"BananA\", 222);\n  a.put(\"PeaR\", 333);\n  a.put(\"AvocadO\", 444);\n\n  // need to resupply the constructor args; they are private to the object; but, should they be?\n  let b = H.clone<Text, Nat>(a, Text.equal, Text.hash);\n\n  // ensure clone has each key-value pair present in original\n  for ((k,v) in a.entries()) {\n    Prim.debugPrint(debug_show (k,v));\n    switch (b.get(k)) {\n    case null { assert false };\n    case (?w) { assert v == w };\n    };\n  };\n\n  // ensure original has each key-value pair present in clone\n  for ((k,v) in b.entries()) {\n    Prim.debugPrint(debug_show (k,v));\n    switch (a.get(k)) {\n    case null { assert false };\n    case (?w) { assert v == w };\n    };\n  };\n\n  // ensure clone has each key present in original\n  for (k in a.keys()) {\n    switch (b.get(k)) {\n    case null { assert false };\n    case (?_) {  };\n    };\n  };\n\n  // ensure clone has each value present in original\n  for (v in a.vals()) {\n    var foundMatch = false;\n    for (w in b.vals()) {\n      if (v == w) { foundMatch := true }\n    };\n    assert foundMatch\n  };\n\n  // do some more operations:\n  a.put(\"apple\", 1111);\n  a.put(\"banana\", 2222);\n  switch( a.remove(\"pear\")) {\n    case null { assert false };\n    case (?three) { assert three == 3 };\n  };\n  a.delete(\"avocado\");\n\n  // check them:\n  switch (a.get(\"apple\")) {\n  case (?1111) { };\n  case _ { assert false };\n  };\n  switch (a.get(\"banana\")) {\n  case (?2222) { };\n  case _ { assert false };\n  };\n  switch (a.get(\"pear\")) {\n  case null {  };\n  case (?_) { assert false };\n  };\n  switch (a.get(\"avocado\")) {\n  case null {  };\n  case (?_) { assert false };\n  };\n\n  // undo operations above:\n  a.put(\"apple\", 1);\n  // .. and test that replace works\n  switch (a.replace(\"apple\", 666)) {\n    case null { assert false };\n    case (?one) { assert one == 1; // ...and revert\n                  a.put(\"apple\", 1)\n         };\n  };\n  a.put(\"banana\", 2);\n  a.put(\"pear\", 3);\n  a.put(\"avocado\", 4);\n\n  // ensure clone has each key-value pair present in original\n  for ((k,v) in a.entries()) {\n    Prim.debugPrint(debug_show (k,v));\n    switch (b.get(k)) {\n    case null { assert false };\n    case (?w) { assert v == w };\n    };\n  };\n\n  // ensure original has each key-value pair present in clone\n  for ((k,v) in b.entries()) {\n    Prim.debugPrint(debug_show (k,v));\n    switch (a.get(k)) {\n    case null { assert false };\n    case (?w) { assert v == w };\n    };\n  };\n\n\n  // test fromIter method\n  let c = H.fromIter<Text, Nat>(b.entries(), 0, Text.equal, Text.hash);\n\n  // c agrees with each entry of b\n  for ((k,v) in b.entries()) {\n    Prim.debugPrint(debug_show (k,v));\n    switch (c.get(k)) {\n    case null { assert false };\n    case (?w) { assert v == w };\n    };\n  };\n\n  // b agrees with each entry of c\n  for ((k,v) in c.entries()) {\n    Prim.debugPrint(debug_show (k,v));\n    switch (b.get(k)) {\n    case null { assert false };\n    case (?w) { assert v == w };\n    };\n  };\n\n  // Issue #228\n  let d = H.HashMap<Text, Nat>(50, Text.equal, Text.hash);\n  switch(d.remove(\"test\")) {\n    case null { };\n    case (?_) { assert false };\n  };\n};\n"}