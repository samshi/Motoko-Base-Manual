modules.Float={"imports":{"mo:â›”":"Prim","Int":"Int"},"functions":{"pi":{"desc":"Ratio of the circumference of a circle to its diameter","body":"public let pi : Float = 3.14159265358979323846; // taken from musl math.h"},"e":{"desc":"// Base of the natural logarithm","body":"public let e : Float  = 2.7182818284590452354;  // taken from musl math.h"},"abs":{"desc":"// Returns the absolute value of `x`","body":"public let abs : (x : Float) -> Float = Prim.floatAbs;"},"sqrt":{"desc":"// Returns the square root of `x`","body":"public let sqrt : (x : Float) -> Float = Prim.floatSqrt;"},"ceil":{"desc":"// Returns the smallest integral float greater than or equal to `x`","body":"public let ceil : (x : Float) -> Float = Prim.floatCeil;"},"floor":{"desc":"// Returns the largest integral float less than or equal to `x`","body":"public let floor : (x : Float) -> Float = Prim.floatFloor;"},"trunc":{"desc":"// Returns the nearest integral float not greater in magnitude than `x`","body":"public let trunc : (x : Float) -> Float = Prim.floatTrunc;"},"nearest":{"desc":"// Returns the nearest integral float to `x`","body":"public let nearest : (x : Float) -> Float = Prim.floatNearest;"},"copySign":{"desc":"// Returns `x` if `x` and `y` have same sign, otherwise `x` with negated sign","body":"public let copySign : (x : Float, y : Float) -> Float = Prim.floatCopySign;"},"min":{"desc":"// Returns the smaller value of `x` and `y`","body":"public let min : (x : Float, y :  Float) -> Float = Prim.floatMin;"},"max":{"desc":"// Returns the larger value of `x` and `y`","body":"public let max : (x : Float, y : Float) -> Float = Prim.floatMax;"},"sin":{"desc":"// Returns the sine of the radian angle `x`","body":"public let sin : (x : Float) -> Float = Prim.sin;"},"cos":{"desc":"// Returns the cosine of the radian angle `x`","body":"public let cos : (x : Float) -> Float = Prim.cos;"},"tan":{"desc":"// Returns the tangent of the radian angle `x`","body":"public let tan : (x : Float) -> Float = Prim.tan;"},"arcsin":{"desc":"// Returns the arc sine of `x` in radians","body":"public let arcsin: (x : Float) -> Float = Prim.arcsin;"},"arccos":{"desc":"// Returns the arc cosine of `x` in radians","body":"public let arccos : (x : Float) -> Float = Prim.arccos;"},"arctan":{"desc":"// Returns the arc tangent of `x` in radians","body":"public let arctan : (x : Float) -> Float = Prim.arctan;"},"arctan2":{"desc":"// Given `(y,x)`, returns the arc tangent in radians of `y/x` based on the signs of both values to determine the correct quadrant","body":"public let arctan2 : (y : Float, x : Float) -> Float = Prim.arctan2;"},"exp":{"desc":"// Returns the value of `e` raised to the `x`-th power","body":"public let exp : (x : Float) -> Float = Prim.exp;"},"log":{"desc":"// Returns the natural logarithm (base-`e`) of `x`","body":"public let log : (x : Float) -> Float = Prim.log;"},"format":{"desc":"// Formatting. `format(fmt, x)` formats `x` to `Text` according to the\nformatting directive `fmt`, which can take one of the following forms:\n\n* `#fix prec` as fixed-point format with `prec` digits\n* `#exp prec` as exponential format with `prec` digits\n* `#gen prec` as generic format with `prec` digits\n* `#hex prec` as hexadecimal format with `prec` digits\n* `#exact` as exact format that can be decoded without loss","body":"public func format\n  (fmt : { #fix : Nat8; #exp : Nat8; #gen : Nat8; #hex : Nat8; #exact }, x : Float) : Text =\n  switch fmt {\n    case (#fix(prec)) { Prim.floatToFormattedText(x, prec, 0) };\n    case (#exp(prec)) { Prim.floatToFormattedText(x, prec, 1) };\n    case (#gen(prec)) { Prim.floatToFormattedText(x, prec, 2) };\n    case (#hex(prec)) { Prim.floatToFormattedText(x, prec, 3) };\n    case (#exact) { Prim.floatToFormattedText(x, 17, 2) };\n  };"},"toText":{"desc":"// Conversion to Text. Use `format(fmt, x)` for more detailed control","body":"public let toText : Float -> Text = Prim.floatToText;"},"toInt64":{"desc":"// Conversion to Int64 by truncating Float, equivalent to `toInt64(trunc(f))","body":"public let toInt64 : Float -> Int64 = Prim.floatToInt64;"},"fromInt64":{"desc":"// Conversion from Int64","body":"public let fromInt64 : Int64 -> Float = Prim.int64ToFloat;"},"toInt":{"desc":"// Conversion to Int","body":"public let toInt : Float -> Int = Prim.floatToInt;"},"fromInt":{"desc":"// Conversion from Int. May result in `Inf`","body":"public let fromInt : Int -> Float = Prim.intToFloat;"},"equal":{"desc":"// Returns `x == y`","body":"public func equal(x : Float, y : Float) : Bool { x == y };"},"notEqual":{"desc":"// Returns `x != y`","body":"public func notEqual(x : Float, y : Float) : Bool { x != y };"},"less":{"desc":"// Returns `x < y`","body":"public func less(x : Float, y : Float) : Bool { x < y };"},"lessOrEqual":{"desc":"// Returns `x <= y`","body":"public func lessOrEqual(x : Float, y : Float) : Bool { x <= y };"},"greater":{"desc":"// Returns `x > y`","body":"public func greater(x : Float, y : Float) : Bool { x > y };"},"greaterOrEqual":{"desc":"// Returns `x >= y`","body":"public func greaterOrEqual(x : Float, y : Float) : Bool { x >= y };"},"compare":{"desc":"// Returns the order of `x` and `y`.","body":"public func compare(x : Float, y : Float) : { #less; #equal; #greater} {\n  if (x < y) { #less }\n  else if (x == y) { #equal }\n  else { #greater }\n}"},"neq":{"desc":"Returns the negation of `x`, `-x` ","body":"public func neq(x : Float) : Float { -x; };"},"add":{"desc":"// Returns the sum of `x` and `y`, `x + y`","body":"public func add(x : Float, y : Float) : Float { x + y };"},"sub":{"desc":"// Returns the difference of `x` and `y`, `x - y`","body":"public func sub(x : Float, y : Float) : Float { x - y };"},"mul":{"desc":"// Returns the product of `x` and `y`, `x * y`","body":"public func mul(x : Float, y : Float) : Float { x * y };"},"div":{"desc":"// Returns the division of `x` by `y`, `x / y`","body":"public func div(x : Float, y : Float) : Float { x / y };"},"rem":{"desc":"// Returns the remainder of `x` divided by `y`, `x % y`","body":"public func rem(x : Float, y : Float) : Float { x % y };"},"pow":{"desc":"// Returns `x` to the power of `y`, `x ** y`","body":"public func pow(x : Float, y : Float) : Float { x ** y };"}},"other":"/// 64-bit floating point numbers.\npublic type Float = Prim.Types.Float;","test":"import Debug \"mo:base/Debug\";\nimport Float \"mo:base/Float\";\n\nDebug.print(\"Float\");\n\ndo {\n  Debug.print(\"  abs\");\n\n  assert(Float.abs(1.1) == 1.1);\n  assert(Float.abs(-1.1) == 1.1);\n};\n\ndo {\n  Debug.print(\"  ceil\");\n\n  assert(Float.ceil(1.1) == 2.0);\n};\n\ndo {\n  Debug.print(\"  floor\");\n\n  assert(Float.floor(1.1) == 1.0);\n};\n\ndo {\n  Debug.print(\"  trunc\");\n\n  assert(Float.trunc(1.0012345789) == 1.0);\n};\n\ndo {\n  Debug.print(\"  nearest\");\n\n  assert(Float.nearest(1.00001) == 1.0);\n  assert(Float.nearest(1.99999) == 2.0);\n};\n\ndo {\n  Debug.print(\"  min\");\n\n  assert(Float.min(1.1, 2.2) == 1.1);\n};\n\ndo {\n  Debug.print(\"  max\");\n\n  assert(Float.max(1.1, 2.2) == 2.2);\n};\n\ndo {\n  Debug.print(\"  sin\");\n\n  assert(Float.sin(0.0) == 0.0);\n};\n\ndo {\n  Debug.print(\"  cos\");\n\n  assert(Float.cos(0.0) == 1.0);\n};\n\ndo {\n  Debug.print(\"  toFloat64\");\n\n  assert(Float.toInt64(1e10) == (10000000000 : Int64));\n  assert(Float.toInt64(-1e10) == (-10000000000 : Int64));\n};\n\ndo {\n  Debug.print(\"  ofFloat64\");\n\n  assert(Float.fromInt64(10000000000) == 1e10);\n  assert(Float.fromInt64(-10000000000) == -1e10);\n};\n\n\ndo {\n  Debug.print(\"  format\");\n\n  assert(Float.format(#exact, 20.12345678901) == \"20.12345678901\");\n  assert(Float.format(#fix 6, 20.12345678901) == \"20.123457\");\n  assert(Float.format(#exp 9, 20.12345678901) == \"2.012345679e+01\");\n  assert(Float.format(#gen 12, 20.12345678901) == \"20.123456789\");\n  assert(Float.format(#hex 10, 20.12345678901) == \"0x1.41f9add374p+4\");\n};\n\n\ndo {\n  Debug.print(\"  Pi: \" # Float.toText(Float.pi));\n  Debug.print(\"  arccos(-1.0): \" # Float.toText(Float.arccos(-1.)));\n\n  assert(Float.pi == Float.arccos(-1.));\n};\n\ndo {\n  Debug.print(\"  e: \" # debug_show(Float.toText(Float.e)));\n  Debug.print(\"  exp(1): \" # debug_show(Float.toText(Float.exp(1))));\n\n  assert(Float.e == Float.exp(1));\n};\n"}