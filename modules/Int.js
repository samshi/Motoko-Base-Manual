modules.Int={"imports":{"mo:â›”":"Prim","Prelude":"Prelude","Hash":"Hash"},"functions":{"Int":{"desc":"Infinite precision signed integers.","body":"public type Int= Prim.Types.Int;"},"abs":{"desc":"// Returns the absolute value of the number","body":"public let abs: Int -> Nat = Prim.abs;"},"toText":{"desc":"// Conversion.","body":"public let toText: Int -> Text = func(x) {\n  if (x == 0) {\n    return \"0\";\n  };\n\n  let isNegative = x < 0;\n  var int = if isNegative { -x } else { x };\n\n  var text = \"\";\n  let base = 10;\n\n  while (int > 0) {\n    let rem = int % base;\n    text := (switch (rem) {\n      case 0 { \"0\" };\n      case 1 { \"1\" };\n      case 2 { \"2\" };\n      case 3 { \"3\" };\n      case 4 { \"4\" };\n      case 5 { \"5\" };\n      case 6 { \"6\" };\n      case 7 { \"7\" };\n      case 8 { \"8\" };\n      case 9 { \"9\" };\n      case _ { Prelude.unreachable() };\n    }) # text;\n    int := int / base;\n  };\n\n  return if isNegative { \"-\" # text } else { text };\n}"},"min":{"desc":"Returns the minimum of `x` and `y`.","body":"public func min(x : Int, y : Int) : Int {\n  if (x < y) { x } else { y };\n}"},"max":{"desc":"Returns the maximum of `x` and `y`.","body":"public func max(x : Int, y : Int) : Int {\n  if (x < y) { y } else { x };\n}"},"hash":{"desc":"Computes a hash from the least significant 32-bits of `i`, ignoring other bits.\n@deprecated For large `Int` values consider using a bespoke hash function that considers all of the argument's bits.","body":"public func hash(i : Int) : Hash.Hash {\n  // CAUTION: This removes the high bits!\n  let j = Prim.int32ToNat32(Prim.intToInt32Wrap(i));\n  hashNat8(\n    [j & (255 << 0),\n     j & (255 << 8),\n     j & (255 << 16),\n     j & (255 << 24)\n    ]);\n}"},"hashAcc":{"desc":"@deprecated This function will be removed in future.","body":"public func hashAcc(h1 : Hash.Hash, i : Int) : Hash.Hash {\n  // CAUTION: This removes the high bits!\n  let j = Prim.int32ToNat32(Prim.intToInt32Wrap(i));\n  hashNat8(\n    [h1,\n     j & (255 << 0),\n     j & (255 << 8),\n     j & (255 << 16),\n     j & (255 << 24)\n    ]);\n}"},"equal":{"desc":"Returns `x == y`.","body":"public func equal(x : Int, y : Int) : Bool { x == y };"},"notEqual":{"desc":"// Returns `x != y`.","body":"public func notEqual(x : Int, y : Int) : Bool { x != y };"},"less":{"desc":"// Returns `x < y`.","body":"public func less(x : Int, y : Int) : Bool { x < y };"},"lessOrEqual":{"desc":"// Returns `x <= y`.","body":"public func lessOrEqual(x : Int, y : Int) : Bool { x <= y };"},"greater":{"desc":"// Returns `x > y`.","body":"public func greater(x : Int, y : Int) : Bool { x > y };"},"greaterOrEqual":{"desc":"// Returns `x >= y`.","body":"public func greaterOrEqual(x : Int, y : Int) : Bool { x >= y };"},"compare":{"desc":"// Returns the order of `x` and `y`.","body":"public func compare(x : Int, y : Int) : { #less; #equal; #greater } {\n  if (x < y) { #less }\n  else if (x == y) { #equal }\n  else { #greater }\n}"},"neq":{"desc":"Returns the negation of `x`, `-x` .","body":"public func neq(x : Int) : Int { -x; };"},"add":{"desc":"// Returns the sum of `x` and `y`, `x + y`.","body":"public func add(x : Int, y : Int) : Int { x + y };"},"sub":{"desc":"// Returns the difference of `x` and `y`, `x - y`.","body":"public func sub(x : Int, y : Int) : Int { x - y };"},"mul":{"desc":"// Returns the product of `x` and `y`, `x * y`.","body":"public func mul(x : Int, y : Int) : Int { x * y };"},"div":{"desc":"// Returns the division of `x` by `y`,  `x / y`.\nTraps when `y` is zero.","body":"public func div(x : Int, y : Int) : Int { x / y };"},"rem":{"desc":"// Returns the remainder of `x` divided by `y`, `x % y`.\nTraps when `y` is zero.","body":"public func rem(x : Int, y : Int) : Int { x % y };"},"pow":{"desc":"// Returns `x` to the power of `y`, `x ** y`.","body":"public func pow(x : Int, y : Int) : Int { x ** y };"}},"related":"// this is a local copy of deprecated Hash.hashNat8 (redefined to suppress the warning)\nprivate func hashNat8(key : [Nat32]) : Hash.Hash {\n  var hash : Nat32 = 0;\n  for (natOfKey in key.vals()) {\n    hash := hash +% natOfKey;\n    hash := hash +% hash << 10;\n    hash := hash ^ (hash >> 6);\n  };\n  hash := hash +% hash << 3;\n  hash := hash ^ (hash >> 11);\n  hash := hash +% hash << 15;\n  return hash;\n};","test":"import Debug \"mo:base/Debug\";\nimport Int \"mo:base/Int\";\n\nDebug.print(\"Int\");\n\ndo {\n  Debug.print(\"  add\");\n\n  assert(Int.add(1, Int.add(2, 3)) == Int.add(1, Int.add(2, 3)));\n  assert(Int.add(0, 1) == 1);\n  assert(1 == Int.add(1, 0));\n  assert(Int.add(0, 1) == Int.add(1, 0));\n  assert(Int.add(1, 2) == Int.add(2, 1));\n};\n\ndo {\n  Debug.print(\"  toText\");\n\n  assert(Int.toText(0) == \"0\");\n  assert(Int.toText(-0) == \"0\");\n  assert(Int.toText(1234) == \"1234\");\n  assert(Int.toText(-1234) == \"-1234\");\n};\n"}