modules.Buffer={"imports":{"mo:â›”":"Prim"},"functions":{"Buffer":{"desc":"Create a stateful buffer class encapsulating a mutable array.\n\nThe argument `initCapacity` determines its initial capacity.\nThe underlying mutable array grows by doubling when its current\ncapacity is exceeded.","body":"public class Buffer<X>(initCapacity : Nat) {\n  var count : Nat = 0;\n  var elems : [var X] = [var]; // initially empty; allocated upon first `add`\n\n  /// Adds a single element to the buffer.\n  public func add(elem : X) {\n    if (count == elems.size()) {\n      let size =\n        if (count == 0) {\n          if (initCapacity > 0) { initCapacity } else { 1 }\n        } else {\n          2 * elems.size()\n        };\n      let elems2 = Prim.Array_init<X>(size, elem);\n      var i = 0;\n      label l loop {\n        if (i >= count) break l;\n        elems2[i] := elems[i];\n        i += 1;\n      };\n      elems := elems2;\n    };\n    elems[count] := elem;\n    count += 1;\n  };\n\n  /// Removes the item that was inserted last and returns it or `null` if no\n  /// elements had been added to the Buffer.\n  public func removeLast() : ?X {\n    if (count == 0) {\n      null\n    } else {\n      count -= 1;\n      ?elems[count]\n    };\n  };\n\n  /// Adds all elements in buffer `b` to this buffer.\n  public func append(b : Buffer<X>) {\n    let i = b.vals();\n    loop {\n      switch (i.next()) {\n        case null return;\n        case (?x) { add(x) };\n      };\n    };\n  };\n\n  /// Returns the current number of elements.\n  public func size() : Nat =\n    count;\n\n  /// Resets the buffer.\n  public func clear() =\n    count := 0;\n\n  /// Returns a copy of this buffer.\n  public func clone() : Buffer<X> {\n    let c = Buffer<X>(elems.size());\n    var i = 0;\n    label l loop {\n      if (i >= count) break l;\n      c.add(elems[i]);\n      i += 1;\n    };\n    c\n  };\n\n  /// Returns an `Iter` over the elements of this buffer.\n  public func vals() : { next : () -> ?X } = object {\n    var pos = 0;\n    public func next() : ?X {\n      if (pos == count) { null } else {\n        let elem = ?elems[pos];\n        pos += 1;\n        elem\n      }\n    }\n  };\n\n  /// Creates a new array containing this buffer's elements.\n  public func toArray() : [X] =\n    // immutable clone of array\n    Prim.Array_tabulate<X>(\n      count,\n      func(x : Nat) : X { elems[x] }\n    );\n\n  /// Creates a mutable array containing this buffer's elements.\n  public func toVarArray() : [var X] {\n    if (count == 0) { [var] } else {\n      let a = Prim.Array_init<X>(count, elems[0]);\n      var i = 0;\n      label l loop {\n        if (i >= count) break l;\n        a[i] := elems[i];\n        i += 1;\n      };\n      a\n    }\n  };\n\n  /// Gets the `i`-th element of this buffer. Traps if  `i >= count`. Indexing is zero-based.\n  public func get(i : Nat) : X {\n    assert(i < count);\n    elems[i]\n  };\n\n  /// Gets the `i`-th element of the buffer as an option. Returns `null` when `i >= count`. Indexing is zero-based.\n  public func getOpt(i : Nat) : ?X {\n    if (i < count) {\n      ?elems[i]\n    }\n    else {\n      null\n    }\n  };\n\n  /// Overwrites the current value of the `i`-entry of  this buffer with `elem`. Traps if the\n  /// index is out of bounds. Indexing is zero-based.\n  public func put(i : Nat, elem : X) {\n    elems[i] := elem;\n  };\n}"},"fromArray":{"desc":"Creates a buffer from immutable array elements.","body":"public func fromArray<X>(elems : [X]) : Buffer<X> {\n  let buff = Buffer<X>(elems.size());\n  for (elem in elems.vals()) {\n    buff.add(elem)\n  };\n  buff\n}"},"fromVarArray":{"desc":"Creates a buffer from the elements of a mutable array.","body":"public func fromVarArray<X>(elems : [var X]) : Buffer<X> {\n  let buff = Buffer<X>(elems.size());\n  for (elem in elems.vals()) {\n    buff.add(elem)\n  };\n  buff\n}"}},"other":"","test":""}