modules.Buffer={"imports":{"mo:â›”":"Prim"},"functions":{"fromArray":{"desc":"Creates a buffer from immutable array elements.","body":"public func fromArray<X>(elems : [X]) : Buffer<X> {\n  let buff = Buffer<X>(elems.size());\n  for (elem in elems.vals()) {\n    buff.add(elem)\n  };\n  buff\n}"},"fromVarArray":{"desc":"Creates a buffer from the elements of a mutable array.","body":"public func fromVarArray<X>(elems : [var X]) : Buffer<X> {\n  let buff = Buffer<X>(elems.size());\n  for (elem in elems.vals()) {\n    buff.add(elem)\n  };\n  buff\n}"},"class.add":{"desc":"initially empty; allocated upon first `add`\n\nAdds a single element to the buffer.","body":"public func add(elem : X) {\n  if (count == elems.size()) {\n    let size =\n      if (count == 0) {\n        if (initCapacity > 0) { initCapacity } else { 1 }\n      } else {\n        2 * elems.size()\n      };\n    let elems2 = Prim.Array_init<X>(size, elem);\n    var i = 0;\n    label l loop {\n      if (i >= count) break l;\n      elems2[i] := elems[i];\n      i += 1;\n    };\n    elems := elems2;\n  };\n  elems[count] := elem;\n  count += 1;\n}"},"class.removeLast":{"desc":"Removes the item that was inserted last and returns it or `null` if no\nelements had been added to the Buffer.","body":"public func removeLast() : ?X {\n  if (count == 0) {\n    null\n  } else {\n    count -= 1;\n    ?elems[count]\n  };\n}"},"class.append":{"desc":"Adds all elements in buffer `b` to this buffer.","body":"public func append(b : Buffer<X>) {\n  let i = b.vals();\n  loop {\n    switch (i.next()) {\n      case null return;\n      case (?x) { add(x) };\n    };\n  };\n}"},"class.size":{"desc":"Returns the current number of elements","body":"public func size() : Nat =\n  count;"},"class.clear":{"desc":"Resets the buffer","body":"public func clear() =\n  count := 0;"},"class.clone":{"desc":"Returns a copy of this buffer.","body":"public func clone() : Buffer<X> {\n  let c = Buffer<X>(elems.size());\n  var i = 0;\n  label l loop {\n    if (i >= count) break l;\n    c.add(elems[i]);\n    i += 1;\n  };\n  c\n}"},"class.vals":{"desc":"Returns an `Iter` over the elements of this buffer.","body":"public func vals() : { next : () -> ?X } = object {\n  var pos = 0;"},"class.toArray":{"desc":"Creates a new array containing this buffer's elements","body":"public func toArray() : [X] =\n  // immutable clone of array\n  Prim.Array_tabulate<X>(\n    count,\n    func(x : Nat) : X { elems[x] }\n  );"},"class.toVarArray":{"desc":"Creates a mutable array containing this buffer's elements.","body":"public func toVarArray() : [var X] {\n  if (count == 0) { [var] } else {\n    let a = Prim.Array_init<X>(count, elems[0]);\n    var i = 0;\n    label l loop {\n      if (i >= count) break l;\n      a[i] := elems[i];\n      i += 1;\n    };\n    a\n  }\n}"},"class.get":{"desc":"Gets the `i`-th element of this buffer. Traps if  `i >= count`. Indexing is zero-based.","body":"public func get(i : Nat) : X {\n  assert(i < count);\n  elems[i]\n}"},"class.getOpt":{"desc":"Gets the `i`-th element of the buffer as an option. Returns `null` when `i >= count`. Indexing is zero-based.","body":"public func getOpt(i : Nat) : ?X {\n  if (i < count) {\n    ?elems[i]\n  }\n  else {\n    null\n  }\n}"},"class.put":{"desc":"Overwrites the current value of the `i`-entry of  this buffer with `elem`. Traps if the\nindex is out of bounds. Indexing is zero-based.","body":"public func put(i : Nat, elem : X) {\n  elems[i] := elem;\n}"}},"other":"/// Create a stateful buffer class encapsulating a mutable array.\n/// The argument `initCapacity` determines its initial capacity.\n/// The underlying mutable array grows by doubling when its current\n/// capacity is exceeded.\npublic class Buffer<X>(initCapacity : Nat) {\n  var count : Nat = 0;\n  var elems : [var X] = [var];\n};","test":""}