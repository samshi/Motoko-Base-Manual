modules.Buffer={"imports":{"mo:â›”":"Prim","Result":"Result","Order":"Order","Array":"Array"},"functions":{"Buffer":{"desc":"","body":"public class Buffer<X>(initCapacity : Nat) = this {\n  var _size : Nat = 0; // avoid name clash with `size()` method\n  var elements : [var ?X] = Prim.Array_init(initCapacity, null);\n\n  /// Returns the current number of elements in the buffer.\n  ///\n  /// Runtime: O(1)\n  ///\n  /// Space: O(1)\n  public func size() : Nat = _size;\n\n  /// Adds a single element to the end of the buffer, doubling\n  /// the size of the array if capacity is exceeded.\n  ///\n  /// Amortized Runtime: O(1), Worst Case Runtime: O(size)\n  ///\n  /// Amortized Space: O(1), Worst Case Space: O(size)\n  public func add(element : X) {\n    if (_size == elements.size()) {\n      reserve(newCapacity(elements.size()));\n    };\n    elements[_size] := ?element;\n    _size += 1;\n  };\n\n  /// Returns the element at index `index`. Traps if  `index >= size`. Indexing is zero-based.\n  ///\n  /// Runtime: O(1)\n  ///\n  /// Space: O(1)\n  public func get(index : Nat) : X {\n    switch (elements[index]) {\n      case (?element) element;\n      case null Prim.trap(\"Buffer index out of bounds in get\");\n    };\n  };\n\n  /// Returns the element at index `index` as an option.\n  /// Returns `null` when `index >= size`. Indexing is zero-based.\n  ///\n  /// Runtime: O(1)\n  ///\n  /// Space: O(1)\n  public func getOpt(index : Nat) : ?X {\n    if (index < _size) {\n      elements[index];\n    } else {\n      null;\n    };\n  };\n\n  /// Overwrites the current element at `index` with `element`. Traps if\n  /// `index` >= size. Indexing is zero-based.\n  ///\n  /// Runtime: O(1)\n  ///\n  /// Space: O(1)\n  public func put(index : Nat, element : X) {\n    if (index >= _size) {\n      Prim.trap \"Buffer index out of bounds in put\";\n    };\n    elements[index] := ?element;\n  };\n\n  /// Removes and returns the last item in the buffer or `null` if\n  /// the buffer is empty.\n  ///\n  /// Amortized Runtime: O(1), Worst Case Runtime: O(size)\n  ///\n  /// Amortized Space: O(1), Worst Case Space: O(size)\n  public func removeLast() : ?X {\n    if (_size == 0) {\n      return null;\n    };\n\n    _size -= 1;\n    let lastElement = elements[_size];\n    elements[_size] := null;\n\n    if (_size < elements.size() / DECREASE_THRESHOLD) {\n      reserve(elements.size() / DECREASE_FACTOR);\n    };\n\n    lastElement;\n  };\n\n  /// Removes and returns the element at `index` from the buffer.\n  /// All elements with index > `index` are shifted one position to the left.\n  /// This may cause a downsizing of the array.\n  ///\n  /// Traps if index >= size.\n  ///\n  /// WARNING: Repeated removal of elements using this method is ineffecient\n  /// and might be a sign that you should consider a different data-structure\n  /// for your use case.\n  ///\n  /// Runtime: O(size)\n  ///\n  /// Amortized Space: O(1), Worst Case Space: O(size)\n  public func remove(index : Nat) : X {\n    if (index >= _size) {\n      Prim.trap \"Buffer index out of bounds in remove\";\n    };\n\n    let element = elements[index];\n\n    // copy elements to new array and shift over in one pass\n    if ((_size - 1) : Nat < elements.size() / DECREASE_THRESHOLD) {\n      let elements2 = Prim.Array_init<?X>(elements.size() / DECREASE_FACTOR, null);\n\n      var i = 0;\n      var j = 0;\n      label l while (i < _size) {\n        if (i == index) {\n          i += 1;\n          continue l;\n        };\n\n        elements2[j] := elements[i];\n        i += 1;\n        j += 1;\n      };\n      elements := elements2;\n    } else {\n      // just shift over elements\n      var i = index;\n      while (i < (_size - 1 : Nat)) {\n        elements[i] := elements[i + 1];\n        i += 1;\n      };\n      elements[_size] := null;\n    };\n\n    _size -= 1;\n\n    switch (element) {\n      case (?element) {\n        element\n      };\n      case null {\n        Prim.trap \"Malformed buffer in remove\"\n      }\n    }\n  };\n\n  /// Resets the buffer. Capacity is set to 8.\n  ///\n  /// Runtime: O(1)\n  ///\n  /// Space: O(1)\n  public func clear() {\n    _size := 0;\n    reserve(DEFAULT_CAPACITY);\n  };\n\n  /// Removes all elements from the buffer for which the predicate returns false.\n  /// The predicate is given both the index of the element and the element itself.\n  /// This may cause a downsizing of the array.\n  ///\n  /// Runtime: O(size)\n  ///\n  /// Amortized Space: O(1), Worst Case Space: O(size)\n  public func filterEntries(predicate : (Nat, X) -> Bool) {\n    var numRemoved = 0;\n    let keep = Prim.Array_tabulate<Bool>(\n      _size,\n      func i {\n        switch (elements[i]) {\n          case (?element) {\n            if (predicate(i, element)) {\n              true;\n            } else {\n              numRemoved += 1;\n              false;\n            };\n          };\n          case null {\n            Prim.trap \"Malformed buffer in filter()\";\n          };\n        };\n      },\n    );\n\n    let capacity = elements.size();\n\n    var original = elements;\n    if ((_size - numRemoved : Nat) < capacity / DECREASE_THRESHOLD) {\n      elements := Prim.Array_init<?X>(capacity / DECREASE_FACTOR, null);\n    };\n\n    var i = 0;\n    var j = 0;\n    while (i < _size) {\n      if (keep[i]) {\n        elements[j] := original[i];\n        i += 1;\n        j += 1;\n      } else {\n        i += 1;\n      };\n    };\n\n    _size -= numRemoved;\n  };\n\n  /// Returns the capacity of the buffer (the length of the underlying array).\n  ///\n  /// Runtime: O(1)\n  ///\n  /// Space: O(1)\n  public func capacity() : Nat = elements.size();\n\n  /// Changes the capacity to `capacity`. Traps if `capacity` < `size`.\n  ///\n  /// Runtime: O(capacity)\n  ///\n  /// Space: O(capacity)\n  public func reserve(capacity : Nat) {\n    if (capacity < _size) {\n      Prim.trap \"capacity must be >= size in reserve\";\n    };\n\n    let elements2 = Prim.Array_init<?X>(capacity, null);\n\n    var i = 0;\n    while (i < _size) {\n      elements2[i] := elements[i];\n      i += 1;\n    };\n    elements := elements2;\n  };\n\n  /// Adds all elements in buffer `b` to this buffer.\n  ///\n  /// Amortized Runtime: O(size2), Worst Case Runtime: O(size1 + size2)\n  ///\n  /// Amortized Space: O(1), Worst Case Space: O(size1 + size2)\n  public func append(buffer2 : Buffer<X>) {\n    let size2 = buffer2.size();\n    // Make sure you only allocate a new array at most once\n    if (_size + size2 > elements.size()) {\n      // FIXME would be nice to have a tabulate for var arrays here\n      reserve(newCapacity(_size + size2));\n    };\n    var i = 0;\n    while (i < size2) {\n      elements[_size + i] := buffer2.getOpt i;\n      i += 1;\n    };\n\n    _size += size2;\n  };\n\n  /// Inserts `element` at `index`, shifts all elements to the right of\n  /// `index` over by one index. Traps if `index` is greater than size.\n  ///\n  /// Runtime: O(size)\n  ///\n  /// Amortized Space: O(1), Worst Case Space: O(size)\n  public func insert(index : Nat, element : X) {\n    if (index > _size) {\n      Prim.trap \"Buffer index out of bounds in insert\";\n    };\n    let capacity = elements.size();\n\n    if (_size + 1 > capacity) {\n      let capacity = elements.size();\n      let elements2 = Prim.Array_init<?X>(newCapacity capacity, null);\n      var i = 0;\n      while (i < _size + 1) {\n        if (i < index) {\n          elements2[i] := elements[i];\n        } else if (i == index) {\n          elements2[i] := ?element;\n        } else {\n          elements2[i] := elements[i - 1];\n        };\n\n        i += 1;\n      };\n      elements := elements2;\n    } else {\n      var i : Nat = _size;\n      while (i > index) {\n        elements[i] := elements[i - 1];\n        i -= 1;\n      };\n      elements[index] := ?element;\n    };\n\n    _size += 1;\n  };\n\n  /// Inserts `buffer2` at `index`, and shifts all elements to the right of\n  /// `index` over by size2. Traps if `index` is greater than size.\n  ///\n  /// Runtime: O(size)\n  ///\n  /// Amortized Space: O(1), Worst Case Space: O(size1 + size2)\n  public func insertBuffer(index : Nat, buffer2 : Buffer<X>) {\n    if (index > _size) {\n      Prim.trap \"Buffer index out of bounds in insertBuffer\";\n    };\n\n    let size2 = buffer2.size();\n    let capacity = elements.size();\n\n    // copy elements to new array and shift over in one pass\n    if (_size + size2 > capacity) {\n      let elements2 = Prim.Array_init<?X>(newCapacity(_size + size2), null);\n      var i = 0;\n      for (element in elements.vals()) {\n        if (i == index) {\n          i += size2;\n        };\n        elements2[i] := element;\n        i += 1;\n      };\n\n      i := 0;\n      while (i < size2) {\n        elements2[i + index] := buffer2.getOpt(i);\n        i += 1;\n      };\n      elements := elements2;\n    } // just insert\n    else {\n      var i = index;\n      while (i < index + size2) {\n        if (i < _size) {\n          elements[i + size2] := elements[i];\n        };\n        elements[i] := buffer2.getOpt(i - index);\n\n        i += 1;\n      };\n    };\n\n    _size += size2;\n  };\n\n  /// Sorts the elements in the buffer according to `compare`.\n  /// Sort is deterministic, stable, and in-place.\n  ///\n  /// Runtime: O(size * log(size))\n  ///\n  /// Space: O(size)\n  public func sort(compare : (X, X) -> Order.Order) {\n    // Stable merge sort in a bottom-up iterative style\n    if (_size == 0) {\n      return;\n    };\n    let scratchSpace = Prim.Array_init<?X>(_size, null);\n\n    let sizeDec = _size - 1 : Nat;\n    var currSize = 1; // current size of the subarrays being merged\n    // when the current size == size, the array has been merged into a single sorted array\n    while (currSize < _size) {\n      var leftStart = 0; // selects the current left subarray being merged\n      while (leftStart < sizeDec) {\n        let mid : Nat = if (leftStart + currSize - 1 : Nat < sizeDec) {\n          leftStart + currSize - 1;\n        } else { sizeDec };\n        let rightEnd : Nat = if (leftStart + (2 * currSize) - 1 : Nat < sizeDec) {\n          leftStart + (2 * currSize) - 1;\n        } else { sizeDec };\n\n        // Merge subarrays elements[leftStart...mid] and elements[mid+1...rightEnd]\n        var left = leftStart;\n        var right = mid + 1;\n        var nextSorted = leftStart;\n        while (left < mid + 1 and right < rightEnd + 1) {\n          let leftOpt = elements[left];\n          let rightOpt = elements[right];\n          switch (leftOpt, rightOpt) {\n            case (?leftElement, ?rightElement) {\n              switch (compare(leftElement, rightElement)) {\n                case (#less or #equal) {\n                  scratchSpace[nextSorted] := leftOpt;\n                  left += 1;\n                };\n                case (#greater) {\n                  scratchSpace[nextSorted] := rightOpt;\n                  right += 1;\n                };\n              };\n            };\n            case (_, _) {\n              // only sorting non-null items\n              Prim.trap \"Malformed buffer in sort\";\n            };\n          };\n          nextSorted += 1;\n        };\n        while (left < mid + 1) {\n          scratchSpace[nextSorted] := elements[left];\n          nextSorted += 1;\n          left += 1;\n        };\n        while (right < rightEnd + 1) {\n          scratchSpace[nextSorted] := elements[right];\n          nextSorted += 1;\n          right += 1;\n        };\n\n        // Copy over merged elements\n        var i = leftStart;\n        while (i < rightEnd + 1) {\n          elements[i] := scratchSpace[i];\n          i += 1;\n        };\n\n        leftStart += 2 * currSize;\n      };\n      currSize *= 2;\n    };\n  };\n\n  /// Returns an Iterator (`Iter`) over the elements of this buffer.\n  /// Iterator provides a single method `next()`, which returns\n  /// elements in order, or `null` when out of elements to iterate over.\n  ///\n  /// Runtime: O(1)\n  ///\n  /// Space: O(1)\n  public func vals() : { next : () -> ?X } = object {\n    // FIXME either handle modification to underlying list\n    // or explicitly warn users in documentation\n    var nextIndex = 0;\n    public func next() : ?X {\n      if (nextIndex >= _size) {\n        return null;\n      };\n      let nextElement = elements[nextIndex];\n      nextIndex += 1;\n      nextElement;\n    };\n  };\n\n  // FOLLOWING METHODS ARE DEPRECATED\n\n  /// @deprecated Use static library function instead.\n  public func clone() : Buffer<X> {\n    let newBuffer = Buffer<X>(elements.size());\n    for (element in vals()) {\n      newBuffer.add(element);\n    };\n    newBuffer;\n  };\n\n  /// @deprecated Use static library function instead.\n  public func toArray() : [X] =\n  // immutable clone of array\n  Prim.Array_tabulate<X>(\n    _size,\n    func(i : Nat) : X { get i },\n  );\n\n  /// @deprecated Use static library function instead.\n  public func toVarArray() : [var X] {\n    if (_size == 0) { [var] } else {\n      let newArray = Prim.Array_init<X>(_size, get 0);\n      var i = 0;\n      for (element in vals()) {\n        newArray[i] := element;\n        i += 1;\n      };\n      newArray;\n    };\n  };\n}"},"isEmpty":{"desc":"Returns true iff the buffer is empty.\n\nRuntime: O(1)\n\nSpace: O(1)","body":"public func isEmpty<X>(buffer : Buffer<X>) : Bool = buffer.size() == 0;"},"contains":{"desc":"// Returns true iff `buffer` contains `element` with respect to equality\ndefined by `equal`.\n\nRuntime: O(size)\n\nSpace: O(1)\n\n*Runtime and space assumes that `equal` runs in O(1) time and space.","body":"public func contains<X>(buffer : Buffer<X>, element : X, equal : (X, X) -> Bool) : Bool {\n  for (current in buffer.vals()) {\n    if (equal(current, element)) {\n      return true;\n    };\n  };\n\n  false;\n}"},"clone":{"desc":"Returns a copy of `buffer`, with the same capacity.\n\nRuntime: O(size)\n\nSpace: O(size)","body":"public func clone<X>(buffer : Buffer<X>) : Buffer<X> {\n  let newBuffer = Buffer<X>(buffer.capacity());\n  for (element in buffer.vals()) {\n    newBuffer.add(element);\n  };\n  newBuffer;\n}"},"max":{"desc":"Finds the greatest element in `buffer` defined by `compare`.\nReturns `null` if `buffer` is empty.\n\nRuntime: O(size)\n\nSpace: O(1)\n\n*Runtime and space assumes that `compare` runs in O(1) time and space.","body":"public func max<X>(buffer : Buffer<X>, compare : (X, X) -> Order) : ?X {\n  if (buffer.size() == 0) {\n    return null;\n  };\n\n  var maxSoFar = buffer.get(0);\n  for (current in buffer.vals()) {\n    switch (compare(current, maxSoFar)) {\n      case (#greater) {\n        maxSoFar := current;\n      };\n      case _ {};\n    };\n  };\n\n  ?maxSoFar;\n}"},"min":{"desc":"Finds the least element in `buffer` defined by `compare`.\nReturns `null` if `buffer` is empty.\n\nRuntime: O(size)\n\nSpace: O(1)\n\n*Runtime and space assumes that `compare` runs in O(1) time and space.","body":"public func min<X>(buffer : Buffer<X>, compare : (X, X) -> Order) : ?X {\n  if (buffer.size() == 0) {\n    return null;\n  };\n\n  var minSoFar = buffer.get(0);\n  for (current in buffer.vals()) {\n    switch (compare(current, minSoFar)) {\n      case (#less) {\n        minSoFar := current;\n      };\n      case _ {};\n    };\n  };\n\n  ?minSoFar;\n}"},"equal":{"desc":"Defines equality for two buffers, using `equal` to recursively compare elements in the\nbuffers. Returns true iff the two buffers are of the same size, and `equal`\nevaluates to true for every pair of elements in the two buffers of the same\nindex.\n\nRuntime: O(size)\n\nSpace: O(1)\n\n*Runtime and space assumes that `equal` runs in O(1) time and space.","body":"public func equal<X>(buffer1 : Buffer<X>, buffer2 : Buffer<X>, equal : (X, X) -> Bool) : Bool {\n  let size1 = buffer1.size();\n\n  if (size1 != buffer2.size()) {\n    return false;\n  };\n\n  var i = 0;\n  while (i < size1) {\n    if (not equal(buffer1.get(i), buffer2.get(i))) {\n      return false;\n    };\n    i += 1;\n  };\n\n  true;\n}"},"compare":{"desc":"Defines comparison for two buffers, using `compare` to recursively compare elements in the\nbuffers. Comparison is defined lexicographically.\n\nRuntime: O(size)\n\nSpace: O(1)\n\n*Runtime and space assumes that `compare` runs in O(1) time and space.","body":"public func compare<X>(buffer1 : Buffer<X>, buffer2 : Buffer<X>, compare : (X, X) -> Order.Order) : Order.Order {\n  let size1 = buffer1.size();\n  let size2 = buffer2.size();\n  let minSize = if (size1 < size2) { size1 } else { size2 };\n\n  var i = 0;\n  while (i < minSize) {\n    switch (compare(buffer1.get(i), buffer2.get(i))) {\n      case (#less) {\n        return #less;\n      };\n      case (#greater) {\n        return #greater;\n      };\n      case _ {};\n    };\n    i += 1;\n  };\n\n  if (size1 < size2) {\n    #less;\n  } else if (size1 == size2) {\n    #equal;\n  } else {\n    #greater;\n  };\n}"},"toText":{"desc":"Creates a textual representation of `buffer`, using `toText` to recursively\nconvert the elements into Text.\n\nRuntime: O(size)\n\nSpace: O(size)\n\n*Runtime and space assumes that `toText` runs in O(1) time and space.","body":"public func toText<X>(buffer : Buffer<X>, toText : X -> Text) : Text {\n  let size : Int = buffer.size();\n  var i = 0;\n  var text = \"\";\n  while (i < size - 1) {\n    text := text # toText(buffer.get(i)) # \", \"; // Text implemented as rope\n    i += 1;\n  };\n  if (size > 0) {\n    // avoid the trailing comma\n    text := text # toText(buffer.get(i));\n  };\n\n  \"[\" # text # \"]\";\n}"},"hash":{"desc":"Hashes `buffer` using `hash` to hash the underlying elements.\nThe deterministic hash function is a function of the elements in the Buffer, as well\nas their ordering.\n\nRuntime: O(size)\n\nSpace: O(1)\n\n*Runtime and space assumes that `hash` runs in O(1) time and space.","body":"public func hash<X>(buffer : Buffer<X>, hash : X -> Nat32) : Nat32 {\n  let size = buffer.size();\n  var i = 0;\n  var accHash : Nat32 = 0;\n\n  while (i < size) {\n    accHash := Prim.intToNat32Wrap(i) ^ accHash ^ hash(buffer.get(i));\n    i += 1;\n  };\n\n  accHash;\n}"},"indexOf":{"desc":"Finds the first index of `element` in `buffer` using equality of elements defined\nby `equal`. Returns `null` if `element` is not found.\n\nRuntime: O(size)\n\nSpace: O(size)\n\n*Runtime and space assumes that `equal` runs in O(1) time and space.","body":"public func indexOf<X>(element : X, buffer : Buffer<X>, equal : (X, X) -> Bool) : ?Nat {\n  let size = buffer.size();\n  var i = 0;\n  while (i < size) {\n    if (equal(buffer.get(i), element)) {\n      return ?i;\n    };\n    i += 1;\n  };\n\n  null;\n}"},"lastIndexOf":{"desc":"Finds the last index of `element` in `buffer` using equality of elements defined\nby `equal`. Returns `null` if `element` is not found.\n\nRuntime: O(size)\n\nSpace: O(size)\n\n*Runtime and space assumes that `equal` runs in O(1) time and space.","body":"public func lastIndexOf<X>(element : X, buffer : Buffer<X>, equal : (X, X) -> Bool) : ?Nat {\n  let size = buffer.size();\n  if (size == 0) {\n    return null;\n  };\n  var i = size;\n  while (i >= 1) {\n    i -= 1;\n    if (equal(buffer.get(i), element)) {\n      return ?i;\n    };\n  };\n\n  null;\n}"},"indexOfBuffer":{"desc":"Searches for `subBuffer` in `buffer`, and returns the starting index if it is found.\n\nRuntime: O(size of buffer + size of subBuffer)\n\nSpace: O(size of subBuffer)\n\n*Runtime and space assumes that `equal` runs in O(1) time and space.","body":"public func indexOfBuffer<X>(subBuffer : Buffer<X>, buffer : Buffer<X>, equal : (X, X) -> Bool) : ?Nat {\n  // Uses the KMP substring search algorithm\n  // Implementation from: https://www.educative.io/answers/what-is-the-knuth-morris-pratt-algorithm\n  let size = buffer.size();\n  let subSize = subBuffer.size();\n  if (subSize > size or subSize == 0) {\n    return null;\n  };\n\n  // precompute lps\n  let lps = Prim.Array_init<Nat>(subSize, 0);\n  var i = 0;\n  var j = 1;\n\n  while (j < subSize) {\n    if (equal(subBuffer.get(i), subBuffer.get(j))) {\n      i += 1;\n      lps[j] := i;\n      j += 1;\n    } else if (i == 0) {\n      lps[j] := 0;\n      j += 1;\n    } else {\n      i := lps[i - 1];\n    };\n  };\n\n  // start search\n  i := 0;\n  j := 0;\n  let subSizeDec = subSize - 1 : Nat; // hoisting loop invariant\n  while (i < subSize and j < size) {\n    if (equal(subBuffer.get(i), buffer.get(j)) and i == subSizeDec) {\n      return ?(j - i);\n    } else if (equal(subBuffer.get(i), buffer.get(j))) {\n      i += 1;\n      j += 1;\n    } else {\n      if (i != 0) {\n        i := lps[i - 1];\n      } else {\n        j += 1;\n      };\n    };\n  };\n\n  null;\n}"},"binarySearch":{"desc":"Similar to indexOf, but runs in logarithmic time. Assumes that `buffer` is sorted.\nBehavior is undefined if `buffer` is not sorted. Uses `compare` to\nperform the search. Returns an index of `element` if it is found.\n\nRuntime: O(log(size))\n\nSpace: O(1)\n\n*Runtime and space assumes that `compare` runs in O(1) time and space.","body":"public func binarySearch<X>(element : X, buffer : Buffer<X>, compare : (X, X) -> Order.Order) : ?Nat {\n  var low = 0;\n  var high = buffer.size();\n\n  while (low < high) {\n    let mid = (low + high) / 2;\n    let current = buffer.get(mid);\n    switch (compare(element, current)) {\n      case (#equal) {\n        return ?mid;\n      };\n      case (#less) {\n        high := mid;\n      };\n      case (#greater) {\n        low := mid + 1;\n      };\n    };\n  };\n\n  null;\n}"},"subBuffer":{"desc":"Returns the sub-buffer of `buffer` starting at index `start`\nof length `length`. Traps if `start` is out of bounds, or `start + length`\nis greater than the size of `buffer`.\n\nRuntime: O(length)\n\nSpace: O(length)","body":"public func subBuffer<X>(buffer : Buffer<X>, start : Nat, length : Nat) : Buffer<X> {\n  let size = buffer.size();\n  let end = start + length; // exclusive\n  if (start >= size or end > size) {\n    Prim.trap \"Buffer index out of bounds in subBuffer\";\n  };\n\n  let newBuffer = Buffer<X>(newCapacity length);\n\n  var i = start;\n  while (i < end) {\n    newBuffer.add(buffer.get(i));\n\n    i += 1;\n  };\n\n  newBuffer;\n}"},"isSubBufferOf":{"desc":"Checks if `subBuffer` is a sub-Buffer of `buffer`. Uses `equal` to\ncompare elements.\n\nRuntime: O(size of subBuffer + size of buffer)\n\nSpace: O(size of subBuffer)\n\n*Runtime and space assumes that `equal` runs in O(1) time and space.","body":"public func isSubBufferOf<X>(subBuffer : Buffer<X>, buffer : Buffer<X>, equal : (X, X) -> Bool) : Bool {\n  switch (indexOfBuffer(subBuffer, buffer, equal)) {\n    case null subBuffer.size() == 0;\n    case _ true;\n  };\n}"},"isStrictSubBufferOf":{"desc":"Checks if `subBuffer` is a strict subBuffer of `buffer`, i.e. `subBuffer` must be\nstrictly contained inside both the first and last indices of `buffer`.\nUses `equal` to compare elements.\n\nRuntime: O(size of subBuffer + size of buffer)\n\nSpace: O(size of subBuffer)\n\n*Runtime and space assumes that `equal` runs in O(1) time and space.","body":"public func isStrictSubBufferOf<X>(subBuffer : Buffer<X>, buffer : Buffer<X>, equal : (X, X) -> Bool) : Bool {\n  let subBufferSize = subBuffer.size();\n\n  switch (indexOfBuffer(subBuffer, buffer, equal)) {\n    case (?index) {\n      index != 0 and index != (buffer.size() - subBufferSize : Nat) // enforce strictness\n    };\n    case null {\n      subBufferSize == 0 and subBufferSize != buffer.size();\n    };\n  };\n}"},"prefix":{"desc":"Returns the prefix of `buffer` of length `length`. Traps if `length`\nis greater than the size of `buffer`.\n\nRuntime: O(length)\n\nSpace: O(length)","body":"public func prefix<X>(buffer : Buffer<X>, length : Nat) : Buffer<X> {\n  let size = buffer.size();\n  if (length > size) {\n    Prim.trap \"Buffer index out of bounds in prefix\";\n  };\n\n  let newBuffer = Buffer<X>(newCapacity length);\n\n  var i = 0;\n  while (i < length) {\n    newBuffer.add(buffer.get(i));\n    i += 1;\n  };\n\n  newBuffer;\n}"},"isPrefixOf":{"desc":"Checks if `prefix` is a prefix of `buffer`. Uses `equal` to\ncompare elements.\n\nRuntime: O(size of prefix)\n\nSpace: O(size of prefix)\n\n*Runtime and space assumes that `equal` runs in O(1) time and space.","body":"public func isPrefixOf<X>(prefix : Buffer<X>, buffer : Buffer<X>, equal : (X, X) -> Bool) : Bool {\n  let sizePrefix = prefix.size();\n  if (buffer.size() < sizePrefix) {\n    return false;\n  };\n\n  var i = 0;\n  while (i < sizePrefix) {\n    if (not equal(buffer.get(i), prefix.get(i))) {\n      return false;\n    };\n\n    i += 1;\n  };\n\n  return true;\n}"},"isStrictPrefixOf":{"desc":"Checks if `prefix` is a strict prefix of `buffer`. Uses `equal` to\ncompare elements.\n\nRuntime: O(size of prefix)\n\nSpace: O(size of prefix)\n\n*Runtime and space assumes that `equal` runs in O(1) time and space.","body":"public func isStrictPrefixOf<X>(prefix : Buffer<X>, buffer : Buffer<X>, equal : (X, X) -> Bool) : Bool {\n  if (buffer.size() <= prefix.size()) {\n    return false;\n  };\n  isPrefixOf(prefix, buffer, equal)\n}"},"suffix":{"desc":"Returns the suffix of `buffer` of length `length`.\nTraps if `length`is greater than the size of `buffer`.\n\nRuntime: O(length)\n\nSpace: O(length)","body":"public func suffix<X>(buffer : Buffer<X>, length : Nat) : Buffer<X> {\n  let size = buffer.size();\n\n  if (length > size) {\n    Prim.trap \"Buffer index out of bounds in suffix\";\n  };\n\n  let newBuffer = Buffer<X>(newCapacity length);\n\n  var i = size - length : Nat;\n  while (i < size) {\n    newBuffer.add(buffer.get(i));\n\n    i += 1;\n  };\n\n  newBuffer;\n}"},"isSuffixOf":{"desc":"Checks if `suffix` is a suffix of `buffer`. Uses `equal` to compare\nelements.\n\nRuntime: O(length of suffix)\n\nSpace: O(length of suffix)\n\n*Runtime and space assumes that `equal` runs in O(1) time and space.","body":"public func isSuffixOf<X>(suffix : Buffer<X>, buffer : Buffer<X>, equal : (X, X) -> Bool) : Bool {\n  let suffixSize = suffix.size();\n  let bufferSize = buffer.size();\n  if (bufferSize < suffixSize) {\n    return false;\n  };\n\n  var i = bufferSize;\n  var j = suffixSize;\n  while (i >= 1 and j >= 1) {\n    i -= 1;\n    j -= 1;\n    if (not equal(buffer.get(i), suffix.get(j))) {\n      return false;\n    };\n  };\n\n  return true;\n}"},"isStrictSuffixOf":{"desc":"Checks if `suffix` is a strict suffix of `buffer`. Uses `equal` to compare\nelements.\n\nRuntime: O(length of suffix)\n\nSpace: O(length of suffix)\n\n*Runtime and space assumes that `equal` runs in O(1) time and space.","body":"public func isStrictSuffixOf<X>(suffix : Buffer<X>, buffer : Buffer<X>, equal : (X, X) -> Bool) : Bool {\n  if (buffer.size() <= suffix.size()) {\n    return false;\n  };\n  isSuffixOf(suffix, buffer, equal)\n}"},"forAll":{"desc":"Returns true iff every element in `buffer` satisfies `predicate`.\n\nRuntime: O(size)\n\nSpace: O(1)\n\n*Runtime and space assumes that `predicate` runs in O(1) time and space.","body":"public func forAll<X>(buffer : Buffer<X>, predicate : X -> Bool) : Bool {\n  for (element in buffer.vals()) {\n    if (not predicate element) {\n      return false;\n    };\n  };\n\n  true;\n}"},"forSome":{"desc":"Returns true iff some element in `buffer` satisfies `predicate`.\n\nRuntime: O(size)\n\nSpace: O(1)\n\n*Runtime and space assumes that `predicate` runs in O(1) time and space.","body":"public func forSome<X>(buffer : Buffer<X>, predicate : X -> Bool) : Bool {\n  for (element in buffer.vals()) {\n    if (predicate element) {\n      return true;\n    };\n  };\n\n  false;\n}"},"forNone":{"desc":"Returns true iff no element in `buffer` satisfies `predicate`.\n\nRuntime: O(size)\n\nSpace: O(1)\n\n*Runtime and space assumes that `predicate` runs in O(1) time and space.","body":"public func forNone<X>(buffer : Buffer<X>, predicate : X -> Bool) : Bool {\n  for (element in buffer.vals()) {\n    if (predicate element) {\n      return false;\n    };\n  };\n\n  true;\n}"},"toArray":{"desc":"Creates an array containing elements from `buffer`.\n\nRuntime: O(size)\n\nSpace: O(size)","body":"public func toArray<X>(buffer : Buffer<X>) : [X] ="},"toVarArray":{"desc":"Creates a mutable array containing elements from `buffer`.\n\nRuntime: O(size)\n\nSpace: O(size)","body":"public func toVarArray<X>(buffer : Buffer<X>) : [var X] {\n  let size = buffer.size();\n  if (size == 0) { [var] } else {\n    let newArray = Prim.Array_init<X>(size, buffer.get(0));\n    var i = 1;\n    while (i < size) {\n      newArray[i] := buffer.get(i);\n      i += 1;\n    };\n    newArray;\n  };\n}"},"fromArray":{"desc":"Creates a buffer containing elements from `array`.\n\nRuntime: O(size)\n\nSpace: O(size)","body":"public func fromArray<X>(array : [X]) : Buffer<X> {\n  // When returning new buffer, if possible, set the capacity\n  // to the capacity of the old buffer. Otherwise, return them\n  // at 2/3 capacity (like in this case). Alternative is to\n  // calculate what the size would be if the elements were\n  // sequentially added using `add`. This current strategy (2/3)\n  // is the upper bound of that calculation (if the last element\n  // added caused a capacity increase).\n  let newBuffer = Buffer<X>(newCapacity(array.size()));\n\n  for (element in array.vals()) {\n    newBuffer.add(element);\n  };\n\n  newBuffer;\n}"},"fromVarArray":{"desc":"Creates a buffer containing elements from `array`.\n\nRuntime: O(size)\n\nSpace: O(size)","body":"public func fromVarArray<X>(array : [var X]) : Buffer<X> {\n  let newBuffer = Buffer<X>(newCapacity(array.size()));\n\n  for (element in array.vals()) {\n    newBuffer.add(element);\n  };\n\n  newBuffer;\n}"},"fromIter":{"desc":"Creates a buffer containing elements from `iter`.\n\nRuntime: O(size)\n\nSpace: O(size)","body":"public func fromIter<X>(iter : { next : () -> ?X }) : Buffer<X> {\n  let newBuffer = Buffer<X>(DEFAULT_CAPACITY); // can't get size from `iter`\n\n  for (element in iter) {\n    newBuffer.add(element);\n  };\n\n  newBuffer;\n}"},"trimToSize":{"desc":"Reallocates the array underlying `buffer` such that capacity == size.\n\nRuntime: O(size)\n\nSpace: O(size)","body":"public func trimToSize<X>(buffer : Buffer<X>) {\n  let size = buffer.size();\n  if (size < buffer.capacity()) {\n    buffer.reserve(size);\n  };\n}"},"map":{"desc":"Creates a new buffer by applying `f` to each element in `buffer`.\n\nRuntime: O(size)\n\nSpace: O(size)\n\n*Runtime and space assumes that `f` runs in O(1) time and space.","body":"public func map<X, Y>(buffer : Buffer<X>, f : X -> Y) : Buffer<Y> {\n  let newBuffer = Buffer<Y>(buffer.capacity());\n\n  for (element in buffer.vals()) {\n    newBuffer.add(f element);\n  };\n\n  newBuffer;\n}"},"iterate":{"desc":"Applies `f` to each element in `buffer`.\n\nRuntime: O(size)\n\nSpace: O(size)\n\n*Runtime and space assumes that `f` runs in O(1) time and space.","body":"public func iterate<X>(buffer : Buffer<X>, f : X -> ()) {\n  for (element in buffer.vals()) {\n    f element;\n  };\n}"},"mapEntries":{"desc":"Applies `f` to each element in `buffer` and its index.\n\nRuntime: O(size)\n\nSpace: O(size)\n\n*Runtime and space assumes that `f` runs in O(1) time and space.","body":"public func mapEntries<X, Y>(buffer : Buffer<X>, f : (Nat, X) -> Y) : Buffer<Y> {\n  let newBuffer = Buffer<Y>(buffer.capacity());\n\n  var i = 0;\n  let size = buffer.size();\n  while (i < size) {\n    newBuffer.add(f(i, buffer.get(i)));\n    i += 1;\n  };\n\n  newBuffer;\n}"},"mapFilter":{"desc":"Creates a new buffer by applying `f` to each element in `buffer`,\nand keeping all non-null elements.\n\nRuntime: O(size)\n\nSpace: O(size)\n\n*Runtime and space assumes that `f` runs in O(1) time and space.","body":"public func mapFilter<X, Y>(buffer : Buffer<X>, f : X -> ?Y) : Buffer<Y> {\n  let newBuffer = Buffer<Y>(buffer.capacity());\n\n  for (element in buffer.vals()) {\n    switch (f element) {\n      case (?element) {\n        newBuffer.add(element);\n      };\n      case _ {};\n    };\n  };\n\n  newBuffer;\n}"},"mapResult":{"desc":"Creates a new buffer by applying `f` to each element in `buffer`.\nIf any invocation of `f` produces an `#err`, returns an `#err`. Otherwise\nReturns an `#ok` containing the new buffer.\n\nRuntime: O(size)\n\nSpace: O(size)\n\n*Runtime and space assumes that `f` runs in O(1) time and space.","body":"public func mapResult<X, Y, E>(buffer : Buffer<X>, f : X -> Result.Result<Y, E>) : Result.Result<Buffer<Y>, E> {\n  let newBuffer = Buffer<Y>(buffer.capacity());\n\n  for (element in buffer.vals()) {\n    switch (f element) {\n      case (#ok result) {\n        newBuffer.add(result);\n      };\n      case (#err e) {\n        return #err e;\n      };\n    };\n  };\n\n  #ok newBuffer;\n}"},"chain":{"desc":"Creates a new buffer by applying `k` to each element in `buffer`,\nand concatenating the resulting buffers in order. This operation\nis similar to what in other functional languages is known as monadic bind.\n\nRuntime: O(size)\n\nSpace: O(size)\n\n*Runtime and space assumes that `f` runs in O(1) time and space.","body":"public func chain<X, Y>(buffer : Buffer<X>, k : X -> Buffer<Y>) : Buffer<Y> {\n  let newBuffer = Buffer<Y>(buffer.size() * 4);\n\n  for (element in buffer.vals()) {\n    newBuffer.append(k element);\n  };\n\n  newBuffer;\n}"},"foldLeft":{"desc":"Collapses the elements in `buffer` into a single value by starting with `base`\nand progessively combining elements into `base` with `combine`. Iteration runs\nleft to right.\n\nRuntime: O(size)\n\nSpace: O(1)\n\n*Runtime and space assumes that `combine` runs in O(1) time and space.","body":"public func foldLeft<A, X>(buffer : Buffer<X>, base : A, combine : (A, X) -> A) : A {\n  var accumulation = base;\n\n  for (element in buffer.vals()) {\n    accumulation := combine(accumulation, element);\n  };\n\n  accumulation;\n}"},"foldRight":{"desc":"Collapses the elements in `buffer` into a single value by starting with `base`\nand progessively combining elements into `base` with `combine`. Iteration runs\nright to left.\n\nRuntime: O(size)\n\nSpace: O(1)\n\n*Runtime and space assumes that `combine` runs in O(1) time and space.","body":"public func foldRight<X, A>(buffer : Buffer<X>, base : A, combine : (X, A) -> A) : A {\n  let size = buffer.size();\n  if (size == 0) {\n    return base;\n  };\n  var accumulation = base;\n\n  var i = size;\n  while (i >= 1) {\n    i -= 1; // to avoid Nat underflow, subtract first and stop iteration at 1\n    accumulation := combine(buffer.get(i), accumulation);\n  };\n\n  accumulation;\n}"},"first":{"desc":"Returns the first element of `buffer`. Traps if `buffer` is empty.\n\nRuntime: O(1)\n\nSpace: O(1)","body":"public func first<X>(buffer : Buffer<X>) : X = buffer.get(0);"},"last":{"desc":"// Returns the last element of `buffer`. Traps if `buffer` is empty.\n\nRuntime: O(1)\n\nSpace: O(1)","body":"public func last<X>(buffer : Buffer<X>) : X = buffer.get(buffer.size() - 1);"},"make":{"desc":"// Returns a new buffer with capacity and size 1, containing `element`.\n\nRuntime: O(1)\n\nSpace: O(1)","body":"public func make<X>(element : X) : Buffer<X> {\n  let newBuffer = Buffer<X>(1);\n  newBuffer.add(element);\n  newBuffer;\n}"},"reverse":{"desc":"Reverses the order of elements in `buffer`.\n\nRuntime: O(size)\n\nSpace: O(1)","body":"public func reverse<X>(buffer : Buffer<X>) {\n  let size = buffer.size();\n  if (size == 0) {\n    return;\n  };\n\n  var i = 0;\n  var j = size - 1 : Nat;\n  var temp = buffer.get(0);\n  while (i < size / 2) {\n    temp := buffer.get(j);\n    buffer.put(j, buffer.get(i));\n    buffer.put(i, temp);\n    i += 1;\n    j -= 1;\n  };\n}"},"merge":{"desc":"Merges two sorted buffers into a single sorted buffer, using `compare` to define\nthe ordering. The final ordering is stable. Behavior is undefined if either\n`buffer1` or `buffer2` is not sorted.\n\nRuntime: O(size1 + size2)\n\nSpace: O(size1 + size2)\n\n*Runtime and space assumes that `compare` runs in O(1) time and space.","body":"public func merge<X>(buffer1 : Buffer<X>, buffer2 : Buffer<X>, compare : (X, X) -> Order) : Buffer<X> {\n  let size1 = buffer1.size();\n  let size2 = buffer2.size();\n\n  let newBuffer = Buffer<X>(newCapacity(size1 + size2));\n\n  var pointer1 = 0;\n  var pointer2 = 0;\n\n  while (pointer1 < size1 and pointer2 < size2) {\n    let current1 = buffer1.get(pointer1);\n    let current2 = buffer2.get(pointer2);\n\n    switch (compare(current1, current2)) {\n      case (#less) {\n        newBuffer.add(current1);\n        pointer1 += 1;\n      };\n      case _ {\n        newBuffer.add(current2);\n        pointer2 += 1;\n      };\n    };\n  };\n\n  while (pointer1 < size1) {\n    newBuffer.add(buffer1.get(pointer1));\n    pointer1 += 1;\n  };\n\n  while (pointer2 < size2) {\n    newBuffer.add(buffer2.get(pointer2));\n    pointer2 += 1;\n  };\n\n  newBuffer;\n}"},"removeDuplicates":{"desc":"Eliminates all duplicate elements in `buffer` as defined by `compare`.\nElimination is stable with respect to the original ordering of the elements.\n\nRuntime: O(size * log(size))\n\nSpace: O(size)","body":"public func removeDuplicates<X>(buffer : Buffer<X>, compare : (X, X) -> Order) {\n  let size = buffer.size();\n  let indices = Prim.Array_tabulate<(Nat, X)>(size, func i = (i, buffer.get(i)));\n  // Sort based on element, while carrying original index information\n  // This groups together the duplicate elements\n  let sorted = Array.sort<(Nat, X)>(indices, func(pair1, pair2) = compare(pair1.1, pair2.1));\n  let uniques = Buffer<(Nat, X)>(size);\n\n  // Iterate over elements\n  var i = 0;\n  while (i < size) {\n    var j = i;\n    // Iterate over duplicate elements, and find the smallest index among them (for stability)\n    var minIndex = sorted[j];\n    label duplicates while (j < (size - 1 : Nat)) {\n      let pair1 = sorted[j];\n      let pair2 = sorted[j + 1];\n      switch (compare(pair1.1, pair2.1)) {\n        case (#equal) {\n          if (pair2.0 < pair1.0) {\n            minIndex := pair2;\n          };\n          j += 1;\n        };\n        case _ {\n          break duplicates;\n        };\n      };\n    };\n\n    uniques.add(minIndex);\n    i := j + 1;\n  };\n\n  // resort based on original ordering and place back in buffer\n  uniques.sort(\n    func(pair1, pair2) {\n      if (pair1.0 < pair2.0) {\n        #less;\n      } else if (pair1.0 == pair2.0) {\n        #equal;\n      } else {\n        #greater;\n      };\n    },\n  );\n\n  buffer.clear();\n  buffer.reserve(uniques.size());\n  for (element in uniques.vals()) {\n    buffer.add(element.1);\n  };\n}"},"partition":{"desc":"Splits `buffer` into a pair of buffers where all elements in the left\nbuffer satisfy `predicate` and all elements in the right buffer do not.\n\nRuntime: O(size)\n\nSpace: O(size)\n\n*Runtime and space assumes that `predicate` runs in O(1) time and space.","body":"public func partition<X>(buffer : Buffer<X>, predicate : X -> Bool) : (Buffer<X>, Buffer<X>) {\n  let size = buffer.size();\n  let trueBuffer = Buffer<X>(size);\n  let falseBuffer = Buffer<X>(size);\n\n  for (element in buffer.vals()) {\n    if (predicate element) {\n      trueBuffer.add(element);\n    } else {\n      falseBuffer.add(element);\n    };\n  };\n\n  (trueBuffer, falseBuffer);\n}"},"split":{"desc":"Splits the buffer into two buffers at `index`, where the left buffer contains\nall elements with indices less than `index`, and the right buffer contains all\nelements with indices greater than or equal to `index`. Traps if `index` is out\nof bounds.\n\nRuntime: O(size)\n\nSpace: O(size)\n\n*Runtime and space assumes that `compare` runs in O(1) time and space.","body":"public func split<X>(buffer : Buffer<X>, index : Nat) : (Buffer<X>, Buffer<X>) {\n  let size = buffer.size();\n\n  if (index < 0 or index > size) {\n    Prim.trap \"Index out of bounds in split\";\n  };\n\n  let buffer1 = Buffer<X>(newCapacity index);\n  let buffer2 = Buffer<X>(newCapacity(size - index));\n\n  var i = 0;\n  while (i < index) {\n    buffer1.add(buffer.get(i));\n    i += 1;\n  };\n  while (i < size) {\n    buffer2.add(buffer.get(i));\n    i += 1;\n  };\n\n  (buffer1, buffer2);\n}"},"chunk":{"desc":"Breaks up `buffer` into buffers of size `size`. The last chunk may\nhave less than `size` elements if the number of elements is not divisible\nby the chunk size.\n\nRuntime: O(number of elements in buffer)\n\nSpace: O(number of elements in buffer)","body":"public func chunk<X>(buffer : Buffer<X>, size : Nat) : Buffer<Buffer<X>> {\n  if (size == 0) {\n    Prim.trap \"Chunk size must be non-zero in chunk\";\n  };\n\n  // ceil(buffer.size() / size)\n  let newBuffer = Buffer<Buffer<X>>((buffer.size() + size - 1) / size);\n\n  var newInnerBuffer = Buffer<X>(newCapacity size);\n  var innerSize = 0;\n  for (element in buffer.vals()) {\n    if (innerSize == size) {\n      newBuffer.add(newInnerBuffer);\n      newInnerBuffer := Buffer<X>(newCapacity size);\n      innerSize := 0;\n    };\n    newInnerBuffer.add(element);\n    innerSize += 1;\n  };\n  if (innerSize > 0) {\n    newBuffer.add(newInnerBuffer);\n  };\n\n  newBuffer;\n}"},"groupBy":{"desc":"Groups equal and adjacent elements in the list into sub lists.\n\nRuntime: O(size)\n\nSpace: O(size)\n\n*Runtime and space assumes that `equal` runs in O(1) time and space.","body":"public func groupBy<X>(buffer : Buffer<X>, equal : (X, X) -> Bool) : Buffer<Buffer<X>> {\n  let size = buffer.size();\n  let newBuffer = Buffer<Buffer<X>>(size);\n  if (size == 0) {\n    return newBuffer;\n  };\n\n  var i = 0;\n  var baseElement = buffer.get(0);\n  var newInnerBuffer = Buffer<X>(size);\n  while (i < size) {\n    let element = buffer.get(i);\n\n    if (equal(baseElement, element)) {\n      newInnerBuffer.add(element);\n    } else {\n      newBuffer.add(newInnerBuffer);\n      baseElement := element;\n      newInnerBuffer := Buffer<X>(size - i);\n      newInnerBuffer.add(element);\n    };\n    i += 1;\n  };\n  if (newInnerBuffer.size() > 0) {\n    newBuffer.add(newInnerBuffer);\n  };\n\n  newBuffer;\n}"},"flatten":{"desc":"Flattens the buffer of buffers into a single buffer.\n\nRuntime: O(number of elements in buffer)\n\nSpace: O(number of elements in buffer)","body":"public func flatten<X>(buffer : Buffer<Buffer<X>>) : Buffer<X> {\n  let size = buffer.size();\n  if (size == 0) {\n    return Buffer<X>(0);\n  };\n\n  let newBuffer = Buffer<X>(\n    if (buffer.get(0).size() != 0) {\n      newCapacity(buffer.get(0).size() * size);\n    } else {\n      newCapacity(size);\n    },\n  );\n\n  for (innerBuffer in buffer.vals()) {\n    for (innerElement in innerBuffer.vals()) {\n      newBuffer.add(innerElement);\n    };\n  };\n\n  newBuffer;\n}"},"zip":{"desc":"Combines the two buffers into a single buffer of pairs, pairing together\nelements with the same index. If one buffer is longer than the other, the\nremaining elements from the longer buffer are not included.\n\nRuntime: O(min(size1, size2))\n\nSpace: O(min(size1, size2))","body":"public func zip<X, Y>(buffer1 : Buffer<X>, buffer2 : Buffer<Y>) : Buffer<(X, Y)> {\n  // compiler should pull lamda out as a static function since it is fully closed\n  zipWith<X, Y, (X, Y)>(buffer1, buffer2, func(x, y) = (x, y));\n}"},"zipWith":{"desc":"Combines the two buffers into a single buffer, pairing together\nelements with the same index and combining them using `zip`. If\none buffer is longer than the other, the remaining elements from\nthe longer buffer are not included.\n\nRuntime: O(min(size1, size2))\n\nSpace: O(min(size1, size2))\n\n*Runtime and space assumes that `zip` runs in O(1) time and space.","body":"public func zipWith<X, Y, Z>(buffer1 : Buffer<X>, buffer2 : Buffer<Y>, zip : (X, Y) -> Z) : Buffer<Z> {\n  let size1 = buffer1.size();\n  let size2 = buffer2.size();\n  let minSize = if (size1 < size2) { size1 } else { size2 };\n\n  var i = 0;\n  let newBuffer = Buffer<Z>(newCapacity minSize);\n  while (i < minSize) {\n    newBuffer.add(zip(buffer1.get(i), buffer2.get(i)));\n    i += 1;\n  };\n  newBuffer;\n}"},"takeWhile":{"desc":"Creates a new buffer taking elements in order from `buffer` until predicate\nreturns false.\n\nRuntime: O(size)\n\nSpace: O(size)\n\n*Runtime and space assumes that `predicate` runs in O(1) time and space.","body":"public func takeWhile<X>(buffer : Buffer<X>, predicate : X -> Bool) : Buffer<X> {\n  let newBuffer = Buffer<X>(buffer.size());\n\n  for (element in buffer.vals()) {\n    if (not predicate element) {\n      return newBuffer;\n    };\n    newBuffer.add(element);\n  };\n\n  newBuffer;\n}"},"dropWhile":{"desc":"Creates a new buffer excluding elements in order from `buffer` until predicate\nreturns false.\n\nRuntime: O(size)\n\nSpace: O(size)\n\n*Runtime and space assumes that `predicate` runs in O(1) time and space.","body":"public func dropWhile<X>(buffer : Buffer<X>, predicate : X -> Bool) : Buffer<X> {\n  let size = buffer.size();\n  let newBuffer = Buffer<X>(size);\n\n  var i = 0;\n  var take = false;\n  label iter for (element in buffer.vals()) {\n    if (not (take or predicate element)) {\n      take := true;\n    };\n    if (take) {\n      newBuffer.add(element);\n    };\n  };\n  newBuffer;\n}"}},"related":"type Order = Order.Order;\n// The following constants are used to manage the capacity.\n// The length of `elements` is increased by `INCREASE_FACTOR` when capacity is reached.\n// The length of `elements` is decreased by `DECREASE_FACTOR` when capacity is strictly less than\n// `DECREASE_THRESHOLD`.\n// INCREASE_FACTOR = INCREASE_FACTOR_NUME / INCREASE_FACTOR_DENOM (with floating point division)\n// Keep INCREASE_FACTOR low to minimize cycle limit problem\nprivate let INCREASE_FACTOR_NUME = 3;\nprivate let INCREASE_FACTOR_DENOM = 2;\nprivate let DECREASE_THRESHOLD = 4; // Don't decrease capacity too early to avoid thrashing\nprivate let DECREASE_FACTOR = 2;\nprivate let DEFAULT_CAPACITY = 8;\nprivate func newCapacity(oldCapacity : Nat) : Nat {\n  if (oldCapacity == 0) {\n    1;\n  } else {\n    // calculates ceil(oldCapacity * INCREASE_FACTOR) without floats\n    ((oldCapacity * INCREASE_FACTOR_NUME) + INCREASE_FACTOR_DENOM - 1) / INCREASE_FACTOR_DENOM\n  };\n};\n// immutable clone of array\nPrim.Array_tabulate<X>(\n  buffer.size(),\n  func(i : Nat) : X { buffer.get(i) },\n);","test":""}