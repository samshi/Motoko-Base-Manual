modules.Trie={"imports":{"mo:â›”":"Prim","Prelude":"P","Option":"Option","Hash":"Hash","Array":"A","List":"List","AssocList":"AssocList","Iter":"I"},"functions":{"Trie":{"desc":"Binary hash tries: either empty, a leaf node, or a branch node","body":"public type Trie<K, V> = {\n  #empty;\n  #leaf : Leaf<K, V>;\n  #branch : Branch<K, V>;\n}"},"Leaf":{"desc":"Leaf nodes of trie consist of key-value pairs as a list.","body":"public type Leaf<K, V> = {\n  size : Nat ;\n  keyvals : AssocList<Key<K>, V> ;\n}"},"Branch":{"desc":"Branch nodes of the trie discriminate on a bit position of the keys' hashes.\nwe never store this bitpos; rather,\nwe enforce a style where this position is always known from context.","body":"public type Branch<K, V> = {\n  size : Nat;\n  left : Trie<K, V>;\n  right : Trie<K, V>;\n}"},"AssocList":{"desc":"","body":"public type AssocList<K, V> = AssocList.AssocList<K, V>;"},"Key":{"desc":"/// A `Key` for the trie has an associated hash value","body":"public type Key<K> = {\n  /// `hash` permits fast inequality checks, and permits collisions\n  hash: Hash.Hash;\n  /// `key` permits precise equality checks, but only used after equal hashes.\n  key: K;\n}"},"equalKey":{"desc":"Equality function for two `Key<K>`s, in terms of equality of `K`'s.","body":"public func equalKey<K>(keq : (K, K) -> Bool) : ((Key<K>, Key<K>) -> Bool) {\n  func (key1 : Key<K>, key2 : Key<K>) : Bool {\n    Hash.equal(key1.hash, key2.hash) and keq(key1.key, key2.key)\n  }\n}"},"isValid":{"desc":"Checks the invariants of the trie structure, including the placement of keys at trie paths","body":"public func isValid<K, V>(t : Trie<K, V>, enforceNormal : Bool) : Bool {\n  func rec(t : Trie<K, V>, bitpos : ?Hash.Hash, bits : Hash.Hash, mask : Hash.Hash) : Bool {\n    switch t {\n      case (#empty) {\n        switch bitpos {\n          case null { true };\n          case (?_) { not enforceNormal };\n        }\n      };\n      case (#leaf(l)) {\n        let len = List.size(l.keyvals);\n        ((len <= MAX_LEAF_SIZE) or (not enforceNormal))\n        and\n        len == l.size\n        and\n        ( List.all(\n            l.keyvals,\n            func ((k : Key<K>, v : V)) : Bool {\n            // { Prim.debugPrint \"testing hash...\"; true }\n            // and\n              ((k.hash & mask) == bits)\n            // or\n            // (do {\n            //    Prim.debugPrint(\"\\nmalformed hash!:\\n\");\n            //    Prim.debugPrintInt(Prim.nat32ToNat(k.hash));\n            //    Prim.debugPrint(\"\\n (key hash) != (path bits): \\n\");\n            //    Prim.debugPrintInt(Prim.nat32ToNat(bits));\n            //    Prim.debugPrint(\"\\nmask  : \");\n            //    Prim.debugPrintInt(Prim.nat32ToNat(mask));\n            //    Prim.debugPrint(\"\\n\");\n            //    false\n            //  })\n               }\n             )\n        // or\n        // (do { Prim.debugPrint(\"one or more hashes are malformed\"); false })\n        )\n      };\n      case (#branch(b)) {\n        let bitpos1 =\n          switch bitpos {\n            case null  {Prim.natToNat32(0)};\n            case (?bp) {Prim.natToNat32(Prim.nat32ToNat(bp) + 1)}\n          };\n        let mask1 = mask | (Prim.natToNat32(1) << bitpos1);\n        let bits1 = bits | (Prim.natToNat32(1) << bitpos1);\n        let sum = size(b.left) + size(b.right);\n        (b.size == sum\n     //  or (do { Prim.debugPrint(\"malformed size\"); false })\n         )\n        and\n        rec(b.left,  ?bitpos1, bits,  mask1)\n        and\n        rec(b.right, ?bitpos1, bits1, mask1)\n      };\n    }\n  };\n  rec(t, null, 0, 0)\n}"},"Trie2D":{"desc":"A 2D trie maps dimension-1 keys to another\nlayer of tries, each keyed on the dimension-2 keys.","body":"public type Trie2D<K1, K2, V> = Trie<K1, Trie<K2, V>>;"},"Trie3D":{"desc":"// A 3D trie maps dimension-1 keys to another\nlayer of 2D tries, each keyed on the dimension-2 and dimension-3 keys.","body":"public type Trie3D<K1, K2, K3, V> = Trie<K1, Trie2D<K2, K3, V> >;"},"empty":{"desc":"// An empty trie.","body":"public func empty<K, V>() : Trie<K, V> { #empty; };"},"size":{"desc":"Get size in O(1) time.","body":"public func size<K, V>(t : Trie<K, V>) : Nat {\n  switch t {\n    case (#empty) { 0 };\n    case (#leaf(l)) { l.size };\n    case (#branch(b)) { b.size };\n  }\n}"},"branch":{"desc":"Construct a branch node, computing the size stored there.","body":"public func branch<K, V>(l : Trie<K, V>, r : Trie<K, V>) : Trie<K, V> {\n    let sum = size(l) + size(r);\n    #branch {\n      size = sum;\n      left = l;\n      right = r\n    };\n  };"},"leaf":{"desc":"// Construct a leaf node, computing the size stored there.\n\nThis helper function automatically enforces the MAX_LEAF_SIZE\nby constructing branches as necessary; to do so, it also needs the bitpos\nof the leaf.","body":"public func leaf<K, V>(kvs : AssocList<Key<K>, V>, bitpos : Nat) : Trie<K, V> {\n  fromList(null, kvs, bitpos)\n}"},"fromList":{"desc":"Transform a list into a trie, splitting input list into small (leaf) lists, if necessary.","body":"public func fromList<K, V>(kvc : ?Nat, kvs : AssocList<Key<K>, V>, bitpos : Nat) : Trie<K, V> {\n  func rec(kvc : ?Nat, kvs : AssocList<Key<K>, V>, bitpos : Nat) : Trie<K, V> {\n    switch kvc {\n      case null {\n        switch (ListUtil.lenClamp(kvs, MAX_LEAF_SIZE)) {\n          case null {} /* fall through to branch case. */;\n          case (?len) {\n            return #leaf({ size = len; keyvals = kvs })\n          };\n        }\n      };\n      case (?c) {\n        if ( c == 0 ) {\n          return #empty\n        } else if ( c <= MAX_LEAF_SIZE ) {\n          return #leaf({ size = c; keyvals = kvs })\n        } else {\n        /* fall through to branch case */\n        }\n      };\n    };\n    let (ls, l, rs, r) = splitList(kvs, bitpos);\n    if ( ls == 0 and rs == 0 ) {\n      #empty\n    } else if (rs == 0 and ls <= MAX_LEAF_SIZE) {\n      #leaf({ size = ls; keyvals = l })\n    } else if (ls == 0 and rs <= MAX_LEAF_SIZE) {\n      #leaf({ size = rs; keyvals = r })\n    } else {\n      branch(rec(?ls, l, bitpos + 1), rec(?rs, r, bitpos + 1))\n    }\n  };\n  rec(kvc, kvs, bitpos)\n}"},"clone":{"desc":"Clone the trie efficiently, via sharing.\n\nPurely-functional representation permits _O(1)_ copy, via persistent sharing.","body":"public func clone<K, V>(t : Trie<K, V>) : Trie<K, V> = t;"},"replace":{"desc":"// Replace the given key's value option with the given one, returning the previous one","body":"public func replace<K, V>(t : Trie<K, V>, k : Key<K>, k_eq : (K, K) -> Bool, v : ?V) : (Trie<K, V>, ?V) {\n   let key_eq = equalKey(k_eq);\n\n   func rec(t : Trie<K, V>, bitpos : Nat) : (Trie<K, V>, ?V) {\n      switch t {\n        case (#empty) {\n          let (kvs, _) = AssocList.replace(null, k, key_eq, v);\n          (leaf(kvs, bitpos), null)\n        };\n        case (#branch(b)) {\n          let bit = Hash.bit(k.hash, bitpos);\n          // rebuild either the left or right path with the (k, v) pair\n          if (not bit) {\n            let (l, v_) = rec(b.left, bitpos + 1);\n            (branch(l, b.right), v_)\n          }\n          else {\n            let (r, v_) = rec(b.right, bitpos + 1);\n            (branch(b.left, r), v_)\n          }\n        };\n     case (#leaf(l)) {\n       let (kvs2, old_val) =\n         AssocList.replace(l.keyvals, k, key_eq, v);\n       (leaf(kvs2, bitpos), old_val)\n      };\n    }\n   };\n   let (to, vo) = rec(t, 0);\n //assert(isValid<K, V>(to, false));\n   (to, vo)\n };"},"put":{"desc":"// Put the given key's value in the trie; return the new trie, and the previous value associated with the key, if any","body":"public func put<K, V>(t : Trie<K, V>, k : Key<K>, k_eq : (K, K) -> Bool, v : V) : (Trie<K, V>, ?V) {\n    replace(t, k, k_eq, ?v)\n  };"},"get":{"desc":"// Get the value of the given key in the trie, or return null if nonexistent","body":"public func get<K, V>(t : Trie<K, V>, k : Key<K>, k_eq : (K, K) -> Bool) : ?V =\n   find(t, k, k_eq);"},"find":{"desc":"// Find the given key's value in the trie, or return null if nonexistent","body":"public func find<K, V>(t : Trie<K, V>, k : Key<K>, k_eq : (K, K) -> Bool) : ?V {\n    let key_eq = equalKey(k_eq);\n    func rec(t : Trie<K, V>, bitpos : Nat) : ?V {\n      switch t {\n        case (#empty) { null };\n        case (#leaf(l)) {\n          AssocList.find(l.keyvals, k, key_eq)\n        };\n        case (#branch(b)) {\n          let bit = Hash.bit(k.hash, bitpos);\n          if (not bit) {\n            rec(b.left, bitpos + 1)\n          }\n          else {\n            rec(b.right, bitpos + 1)\n          }\n        };\n      }\n    };\n    rec(t, 0)\n  };\n\n\n\nfunc splitAssocList<K, V>(al : AssocList<Key<K>, V>, bitpos : Nat)\n   : (AssocList<Key<K>, V>, AssocList<Key<K>, V>)\n {\n   List.partition(\n     al,\n     func ((k : Key<K>, v : V)) : Bool {\n       not Hash.bit(k.hash, bitpos)\n     }\n   )\n };\n\nfunc splitList<K, V>(l : AssocList<Key<K>, V>, bitpos : Nat)\n  : (Nat, AssocList<Key<K>, V>, Nat, AssocList<Key<K>, V>)\n  {\n   func rec(l : AssocList<Key<K>, V>) : (Nat, AssocList<Key<K>, V>, Nat, AssocList<Key<K>, V>) {\n       switch l {\n         case null { (0, null, 0, null) };\n         case (?((k, v), t)) {\n           let (cl, l, cr, r) = rec(t) ;\n           if (not Hash.bit(k.hash, bitpos)){\n             (cl + 1, ?((k, v), l), cr, r)\n           } else {\n             (cl, l, cr + 1, ?((k, v), r))\n           }\n         };\n       }\n     };\n   rec(l)\n };"},"merge":{"desc":"// Merge tries, preferring the right trie where there are collisions\nin common keys.\n\nnote: the `disj` operation generalizes this `merge`\noperation in various ways, and does not (in general) lose\ninformation; this operation is a simpler, special case.","body":"public func merge<K, V>(tl : Trie<K, V>, tr :  Trie<K, V>, k_eq : (K, K) -> Bool) : Trie<K, V> {\n    let key_eq = equalKey(k_eq);\n    func rec(bitpos : Nat, tl : Trie<K, V>, tr : Trie<K, V>) : Trie<K, V> {\n      switch (tl, tr) {\n        case (#empty, _) { return tr };\n        case (_, #empty) { return tl };\n        case (#leaf(l1), #leaf(l2)) {\n          leaf(\n            AssocList.disj(\n              l1.keyvals, l2.keyvals,\n              key_eq,\n              func (x : ?V, y : ?V) : V {\n                switch (x, y) {\n                  case (null, null) { P.unreachable() };\n                  case (null, ?v) { v };\n                  case (?v, _) { v };\n                }\n              }\n            ),\n            bitpos)\n        };\n        case (#leaf(l), _) {\n          let (ll, lr) = splitAssocList(l.keyvals, bitpos);\n          rec(bitpos, branch(leaf(ll, bitpos), leaf(lr, bitpos)), tr)\n        };\n        case (_, #leaf(l)) {\n          let (ll, lr) = splitAssocList(l.keyvals, bitpos);\n          rec(bitpos, tl, branch(leaf(ll, bitpos), leaf(lr, bitpos)))\n        };\n        case (#branch(b1), #branch(b2)) {\n          branch(rec(bitpos + 1, b1.left, b2.left),\n                 rec(bitpos + 1, b1.right, b2.right))\n        };\n      }\n    };\n    rec(0, tl, tr)\n  };"},"mergeDisjoint":{"desc":"// Merge tries like `merge`, except signals a\ndynamic error if there are collisions in common keys between the\nleft and right inputs.","body":"public func mergeDisjoint<K, V>(tl : Trie<K, V>, tr : Trie<K, V>, k_eq : (K, K) -> Bool) : Trie<K, V> {\n    let key_eq = equalKey(k_eq);\n\n    func rec(bitpos : Nat, tl : Trie<K, V>, tr : Trie<K, V>) : Trie<K, V> {\n      switch (tl, tr) {\n        case (#empty, _) { return tr };\n        case (_, #empty) { return tl };\n        case (#leaf(l1), #leaf(l2)) {\n          leaf(\n            AssocList.disjDisjoint(\n              l1.keyvals, l2.keyvals,\n              func (x : ?V, y : ?V) : V {\n                switch (x, y) {\n                  case (null, ?v) { v };\n                  case (?v, null) { v };\n                  case (_, _) { P.unreachable() };\n                }\n              }\n            ),\n            bitpos\n          )\n        };\n        case (#leaf(l), _) {\n          let (ll, lr) = splitAssocList(l.keyvals, bitpos);\n          rec(bitpos, branch(leaf(ll, bitpos), leaf(lr, bitpos)), tr)\n        };\n        case (_, #leaf(l)) {\n          let (ll, lr) = splitAssocList(l.keyvals, bitpos);\n          rec(bitpos, tl, branch(leaf(ll, bitpos), leaf(lr, bitpos)))\n        };\n        case (#branch(b1), #branch(b2)) {\n          branch(\n            rec(bitpos + 1, b1.left, b2.left),\n            rec(bitpos + 1, b1.right, b2.right)\n          )\n        };\n      }\n    };\n    rec(0, tl, tr)\n  };"},"diff":{"desc":"// Difference of tries. The output consists are pairs of\nthe left trie whose keys are not present in the right trie; the\nvalues of the right trie are irrelevant.","body":"public func diff<K, V, W>(tl : Trie<K, V>, tr : Trie<K, W>, k_eq : ( K, K) -> Bool) : Trie<K, V> {\n  let key_eq = equalKey(k_eq);\n\n  func rec(bitpos : Nat, tl : Trie<K, V>, tr : Trie<K, W>) : Trie<K, V> {\n    switch (tl, tr) {\n      case (#empty, _) { return #empty };\n      case (_, #empty) { return tl };\n      case (#leaf(l1), #leaf(l2)) {\n        leaf(\n           AssocList.diff(\n             l1.keyvals, l2.keyvals,\n             key_eq,\n           ),\n           bitpos\n         )\n      };\n      case (#leaf(l), _) {\n        let (ll, lr) = splitAssocList(l.keyvals, bitpos);\n        rec(bitpos, branch(leaf(ll, bitpos), leaf(lr, bitpos)), tr)\n      };\n      case (_, #leaf(l)) {\n        let (ll, lr) = splitAssocList(l.keyvals, bitpos);\n        rec(bitpos, tl, branch(leaf(ll, bitpos), leaf(lr, bitpos)))\n      };\n      case (#branch(b1), #branch(b2)) {\n        branch(rec(bitpos + 1, b1.left, b2.left),\n               rec(bitpos + 1, b1.right, b2.right))\n      };\n    }\n  };\n  rec(0, tl, tr)\n}"},"disj":{"desc":"Map disjunction.\n\nThis operation generalizes the notion of \"set union\" to finite maps.\n\nProduces a \"disjunctive image\" of the two tries, where the values of\nmatching keys are combined with the given binary operator.\n\nFor unmatched key-value pairs, the operator is still applied to\ncreate the value in the image.  To accomodate these various\nsituations, the operator accepts optional values, but is never\napplied to (null, null).\n\nImplements the database idea of an [\"outer join\"](https://stackoverflow.com/questions/38549/what-is-the-difference-between-inner-join-and-outer-join).","body":"public func disj<K, V, W, X>(\n  tl : Trie<K, V>,\n  tr : Trie<K, W>,\n  k_eq : (K, K) -> Bool,\n  vbin : (?V, ?W) -> X\n) : Trie<K, X> {\n  let key_eq = equalKey(k_eq);\n\n  /* empty right case; build from left only: */\n  func recL(t : Trie<K, V>, bitpos : Nat) : Trie<K, X> {\n    switch t {\n      case (#empty) { #empty };\n      case (#leaf(l)) {\n        leaf(AssocList.disj(l.keyvals, null, key_eq, vbin), bitpos)\n      };\n      case (#branch(b)) {\n        branch(recL(b.left, bitpos + 1),\n               recL(b.right, bitpos + 1)) };\n    }\n  };\n\n /* empty left case; build from right only: */\n func recR(t : Trie<K, W>, bitpos : Nat) : Trie<K, X> {\n   switch t {\n     case (#empty) { #empty };\n     case (#leaf(l)) {\n       leaf(AssocList.disj(null, l.keyvals, key_eq, vbin), bitpos)\n     };\n     case (#branch(b)) {\n       branch(recR(b.left, bitpos + 1),\n              recR(b.right, bitpos + 1)) };\n   }\n };\n\n /* main recursion */\n func rec(bitpos : Nat, tl : Trie<K, V>, tr : Trie<K, W>) : Trie<K, X> {\n   switch (tl, tr) {\n     case (#empty, #empty) { #empty };\n     case (#empty, _) { recR(tr, bitpos) };\n     case (_, #empty) { recL(tl, bitpos) };\n     case (#leaf(l1), #leaf(l2)) {\n       leaf(AssocList.disj(l1.keyvals, l2.keyvals, key_eq, vbin), bitpos)\n     };\n     case (#leaf(l), _) {\n       let (ll, lr) = splitAssocList(l.keyvals, bitpos);\n       rec(bitpos, branch(leaf(ll, bitpos), leaf(lr, bitpos)), tr)\n     };\n     case (_, #leaf(l)) {\n       let (ll, lr) = splitAssocList(l.keyvals, bitpos);\n       rec(bitpos, tl, branch(leaf(ll, bitpos), leaf(lr, bitpos)))\n     };\n     case (#branch(b1), #branch(b2)) {\n       branch(rec(bitpos + 1, b1.left, b2.left),\n         rec(bitpos + 1, b1.right, b2.right))\n     };\n    }\n  };\n\n  rec(0, tl, tr)\n}"},"join":{"desc":"Map join.\n\nImplements the database idea of an [\"inner join\"](https://stackoverflow.com/questions/38549/what-is-the-difference-between-inner-join-and-outer-join).\n\nThis operation generalizes the notion of \"set intersection\" to\nfinite maps.  The values of matching keys are combined with the given binary\noperator, and unmatched key-value pairs are not present in the output.","body":"public func join<K, V, W, X>(\n  tl : Trie<K, V>,\n  tr : Trie<K, W>,\n  k_eq : (K, K) -> Bool,\n  vbin : (V, W) -> X\n) : Trie<K, X> {\n  let key_eq = equalKey(k_eq);\n\n  func rec(bitpos : Nat, tl : Trie<K, V>, tr : Trie<K, W>) : Trie<K, X> {\n    switch (tl, tr) {\n      case (#empty, _) { #empty };\n      case (_, #empty) { #empty };\n      case (#leaf(l1), #leaf(l2)) {\n        leaf(AssocList.join(l1.keyvals, l2.keyvals, key_eq, vbin), bitpos)\n      };\n      case (#leaf(l), _) {\n        let (ll, lr) = splitAssocList(l.keyvals, bitpos);\n        rec(bitpos, branch(leaf(ll, bitpos), leaf(lr, bitpos)), tr)\n      };\n      case (_, #leaf(l)) {\n        let (ll, lr) = splitAssocList(l.keyvals, bitpos);\n        rec(bitpos, tl, branch(leaf(ll, bitpos), leaf(lr, bitpos)))\n      };\n      case (#branch(b1), #branch(b2)) {\n        branch(rec(bitpos + 1, b1.left, b2.left),\n          rec(bitpos + 1, b1.right, b2.right))\n      };\n    }\n  };\n\n  rec(0, tl, tr)\n}"},"foldUp":{"desc":"This operation gives a recursor for the internal structure of\ntries.  Many common operations are instantiations of this function,\neither as clients, or as hand-specialized versions (e.g., see , map,\nmapFilter, some and all below).","body":"public func foldUp<K, V, X>(t : Trie<K, V>, bin : (X, X) -> X, leaf : (K, V) -> X, empty : X) : X {\n  func rec(t : Trie<K, V>) : X {\n    switch t {\n      case (#empty) { empty };\n      case (#leaf(l)) {\n        AssocList.fold(\n          l.keyvals, empty,\n          func (k : Key<K>, v : V, x : X) : X { bin(leaf(k.key, v), x) }\n        )\n      };\n      case (#branch(b)) { bin(rec(b.left), rec(b.right)) };\n    }\n  };\n  rec(t)\n}"},"prod":{"desc":"Map product.\n\nConditional _catesian product_, where the given\noperation `op` _conditionally_ creates output elements in the\nresulting trie.\n\nThe keyed structure of the input tries are not relevant for this\noperation: all pairs are considered, regardless of keys matching or\nnot.  Moreover, the resulting trie may use keys that are unrelated to\nthese input keys.","body":"public func prod<K1, V1, K2, V2, K3, V3>(\n  tl : Trie<K1, V1>,\n  tr : Trie<K2, V2>,\n  op : (K1, V1, K2, V2) -> ?(Key<K3>, V3),\n  k3_eq : (K3, K3) -> Bool\n)  : Trie<K3, V3>  {\n\n  /*- binary case: merge disjoint results: */\n  func merge (a : Trie<K3, V3>, b : Trie<K3, V3>) : Trie<K3, V3> =\n    mergeDisjoint(a, b, k3_eq);\n\n  /*- \"`foldUp` squared\" (imagine two nested loops): */\n  foldUp(\n    tl, merge,\n    func (k1 : K1, v1 : V1) : Trie<K3, V3> {\n      foldUp(\n        tr, merge,\n        func (k2 : K2, v2 : V2) : Trie<K3, V3> {\n          switch (op(k1, v1, k2, v2)) {\n            case null { #empty };\n            case (?(k3, v3)) { (put(#empty, k3, k3_eq, v3)).0 };\n          }\n        },\n        #empty\n      )\n    },\n    #empty\n  )\n}"},"iter":{"desc":"Returns an `Iter` over the key-value entries of the trie.\n\nEach iterator gets a _persistent view_ of the mapping, independent of concurrent updates to the iterated map.","body":"public func iter<K, V>(t : Trie<K, V>) : I.Iter<(K, V)> {\n  object {\n    var stack = ?(t, null) : List.List<Trie<K, V>>;\n    public func next() : ?(K, V) {\n      switch stack {\n        case null { null };\n        case (?(trie, stack2)) {\n          switch trie {\n            case (#empty) {\n              stack := stack2;\n              next()\n            };\n            case (#leaf({ keyvals = null })) {\n              stack := stack2;\n              next()\n            };\n            case (#leaf({ size = c; keyvals = ?((k, v), kvs) })) {\n              stack := ?(#leaf({ size = c-1; keyvals = kvs }), stack2);\n              ?(k.key, v)\n            };\n            case (#branch(br)) {\n              stack := ?(br.left, ?(br.right, stack2));\n              next()\n            };\n          }\n        }\n      }\n    }\n  }\n}"},"fold":{"desc":"Fold over the key-value pairs of the trie, using an accumulator.\nThe key-value pairs have no reliable or meaningful ordering.","body":"public func fold<K, V, X>(t : Trie<K, V>, f : (K, V, X) -> X, x : X) : X {\n  func rec(t : Trie<K, V>, x : X) : X {\n    switch t {\n      case (#empty) { x };\n      case (#leaf(l)) {\n        AssocList.fold(\n         l.keyvals, x,\n         func (k : Key<K>, v : V, x : X) : X = f(k.key, v, x)\n        )\n      };\n      case (#branch(b)) { rec(b.left, rec(b.right, x)) };\n    };\n  };\n  rec(t, x)\n}"},"some":{"desc":"Test whether a given key-value pair is present, or not.","body":"public func some<K, V>(t : Trie<K, V>, f : (K, V) -> Bool) : Bool {\n  func rec(t : Trie<K, V>) : Bool {\n    switch t {\n      case (#empty) { false };\n      case (#leaf(l)) {\n        List.some(\n          l.keyvals, func ((k : Key<K>, v:V)) : Bool = f(k.key, v)\n        )\n      };\n      case (#branch(b)) { rec(b.left) or rec(b.right) };\n    };\n  };\n  rec(t)\n}"},"all":{"desc":"Test whether all key-value pairs have a given property.","body":"public func all<K, V>(t : Trie<K, V>, f : (K, V) -> Bool) : Bool {\n  func rec(t : Trie<K, V>) : Bool {\n    switch t {\n      case (#empty) { true };\n      case (#leaf(l)) {\n        List.all(\n          l.keyvals, func ((k : Key<K>, v : V)) : Bool=f(k.key, v)\n        )\n      };\n      case (#branch(b)) { rec(b.left) and rec(b.right) };\n    };\n  };\n  rec(t)\n}"},"nth":{"desc":"Project the nth key-value pair from the trie.\n\nNote: This position is not meaningful; it's only here so that we\ncan inject tries into arrays using functions like `Array.tabulate`.","body":"public func nth<K, V>(t : Trie<K, V>, i : Nat) : ?(Key<K>, V) {\n    func rec(t : Trie<K, V>, i : Nat) : ?(Key<K>, V) {\n      switch t {\n        case (#empty) { P.unreachable() };\n        case (#leaf(l)) { List.get(l.keyvals, i) };\n        case (#branch(b)) {\n          let size_left = size(b.left);\n          if (i < size_left) { rec(b.left,  i) }\n          else { rec(b.right, i - size_left) }\n        }\n      }\n    };\n    if (i >= size(t)) {\n      return null\n    };\n    rec(t, i)\n}"},"toArray":{"desc":"Gather the collection of key-value pairs into an array of a (possibly-distinct) type.","body":"public func toArray<K, V, W>(t : Trie<K, V>, f : (K, V) -> W) : [W] {\n    let a = A.tabulate<W> (\n      size(t),\n      func (i : Nat) : W {\n        let (k, v) = switch (nth(t, i)) {\n          case null { P.unreachable() };\n          case (?x) { x };\n        };\n        f(k.key, v)\n      }\n    );\n    a\n  };"},"isEmpty":{"desc":"// Test for \"deep emptiness\": subtrees that have branching structure,\nbut no leaves.  These can result from naive filtering operations;\nfilter uses this function to avoid creating such subtrees.","body":"public func isEmpty<K, V>(t : Trie<K, V>) : Bool {\n  size(t) == 0\n}"},"filter":{"desc":"Filter the key-value pairs by a given predicate.","body":"public func filter<K, V>(t : Trie<K, V>, f : (K, V) -> Bool) : Trie<K, V> {\n  func rec(t : Trie<K, V>, bitpos : Nat) : Trie<K, V> {\n    switch t {\n      case (#empty) { #empty };\n      case (#leaf(l)) {\n        leaf(\n          List.filter(\n            l.keyvals,\n            func ((k : Key<K>, v : V)) : Bool = f(k.key, v)\n          ),\n          bitpos\n        )\n      };\n      case (#branch(b)) {\n        let fl = rec(b.left, bitpos + 1);\n        let fr = rec(b.right, bitpos + 1);\n        switch (isEmpty(fl), isEmpty(fr)) {\n          case (true, true) { #empty };\n          case (false, true) { fl };\n          case (true, false) { fr };\n          case (false, false) { branch(fl, fr) };\n        };\n      }\n    }\n  };\n  rec(t, 0)\n}"},"mapFilter":{"desc":"Map and filter the key-value pairs by a given predicate.","body":"public func mapFilter<K, V, W>(t : Trie<K, V>, f : (K, V) -> ?W) : Trie<K, W> {\n  func rec(t : Trie<K, V>, bitpos : Nat) : Trie<K, W> {\n    switch t {\n      case (#empty) { #empty };\n      case (#leaf(l)) {\n        leaf(\n          List.mapFilter(\n            l.keyvals,\n            // retain key and hash, but update key's value using f:\n            func ((k : Key<K>, v : V)) : ?(Key<K>, W) {\n              switch (f(k.key, v)) {\n                case null { null };\n                case (?w) { ?({key = k.key; hash = k.hash}, w) };\n              }\n            }\n          ),\n          bitpos\n        )\n      };\n      case (#branch(b)) {\n        let fl = rec(b.left, bitpos + 1);\n        let fr = rec(b.right, bitpos + 1);\n        switch (isEmpty(fl), isEmpty(fr)) {\n          case (true, true) { #empty };\n          case (false, true) { fl };\n          case (true, false) { fr };\n          case (false, false) { branch(fl, fr) };\n        };\n      }\n    }\n  };\n\n rec(t, 0)\n}"},"equalStructure":{"desc":"Test for equality, but naively, based on structure.\nDoes not attempt to remove \"junk\" in the tree;\nFor instance, a \"smarter\" approach would equate\n  `#bin {left = #empty; right = #empty}`\nwith\n  `#empty`.\nWe do not observe that equality here.","body":"public func equalStructure<K, V>(\n  tl : Trie<K, V>,\n  tr : Trie<K, V>,\n  keq : (K, K) -> Bool,\n  veq : (V, V) -> Bool\n) : Bool {\n  func rec(tl : Trie<K, V>, tr : Trie<K, V>) : Bool {\n    switch (tl, tr) {\n      case (#empty, #empty) { true };\n      case (#leaf(l1), #leaf(l2)) {\n        List.equal(l1.keyvals, l2.keyvals,\n          func ((k1 : Key<K>, v1 : V), (k2 : Key<K>, v2 : V)) : Bool =\n            keq(k1.key, k2.key) and veq(v1, v2)\n        )\n      };\n      case (#branch(b1), #branch(b2)) {\n        rec(b1.left, b2.left) and rec(b2.right, b2.right)\n      };\n      case _ { false };\n    }\n  };\n  rec(tl, tr)\n}"},"replaceThen":{"desc":"Replace the given key's value in the trie,\nand only if successful, do the success continuation,\notherwise, return the failure value","body":"public func replaceThen<K, V, X>(\n  t : Trie<K, V>, k : Key<K>, k_eq : (K, K) -> Bool, v2 : V,\n  success: (Trie<K, V>, V) -> X,\n  fail: () -> X\n) : X {\n  let (t2, ov) = replace(t, k, k_eq, ?v2);\n  switch ov {\n    case null { /* no prior value; failure to remove */ fail() };\n    case (?v1) { success(t2, v1) };\n  }\n}"},"putFresh":{"desc":"Put the given key's value in the trie; return the new trie; assert that no prior value is associated with the key","body":"public func putFresh<K, V>(t : Trie<K, V>,  k : Key<K>, k_eq : (K, K) -> Bool, v : V) : Trie<K, V> {\n  let (t2, none) = replace(t, k, k_eq, ?v);\n  switch none {\n    case null {};\n    case (?_) assert false;\n  };\n  t2\n}"},"put2D":{"desc":"Put the given key's value in the 2D trie; return the new 2D trie.","body":"public func put2D<K1, K2, V>(\n  t : Trie2D<K1, K2, V>,\n  k1 : Key<K1>,\n  k1_eq : (K1, K1) -> Bool,\n  k2 : Key<K2>,\n  k2_eq : (K2, K2) -> Bool,\n  v:V\n) : Trie2D<K1, K2, V> {\n  let inner = find(t, k1, k1_eq);\n  let (updated_inner, _) = switch inner {\n    case null { put(#empty, k2, k2_eq, v) };\n    case (?inner) { put(inner, k2, k2_eq, v) };\n  };\n  let (updated_outer, _) = put(t, k1, k1_eq, updated_inner);\n  updated_outer;\n}"},"put3D":{"desc":"Put the given key's value in the trie; return the new trie;","body":"public func put3D<K1, K2, K3, V> (\n  t : Trie3D<K1, K2, K3, V>,\n  k1 : Key<K1>,\n  k1_eq : (K1, K1) -> Bool,\n  k2 : Key<K2>,\n  k2_eq : (K2, K2) -> Bool,\n  k3 : Key<K3>,\n  k3_eq : (K3, K3) -> Bool,\n  v : V\n) : Trie3D<K1, K2, K3, V> {\n  let inner1 = find(t, k1, k1_eq);\n  let (updated_inner1, _) = switch inner1 {\n    case null {\n      put(\n        #empty, k2, k2_eq,\n         (put(#empty, k3, k3_eq, v)).0\n      )\n    };\n    case (?inner1) {\n      let inner2 = find(inner1, k2, k2_eq);\n      let (updated_inner2, _) = switch inner2 {\n        case null { put(#empty, k3, k3_eq, v) };\n        case (?inner2) { put(inner2, k3, k3_eq, v) };\n      };\n      put(inner1, k2, k2_eq, updated_inner2 )\n    };\n  };\n  let (updated_outer, _) = put(t, k1, k1_eq, updated_inner1);\n  updated_outer;\n}"},"remove":{"desc":"Remove the given key's value in the trie; return the new trie","body":"public func remove<K, V>(t : Trie<K, V>, k : Key<K>, k_eq : (K, K) -> Bool) : (Trie<K, V>, ?V) {\n  replace(t, k, k_eq, null)\n}"},"removeThen":{"desc":"Remove the given key's value in the trie,\nand only if successful, do the success continuation,\notherwise, return the failure value","body":"public func removeThen<K, V, X>(\n  t : Trie<K, V>,\n  k : Key<K>,\n  k_eq : (K, K) -> Bool,\n  success : (Trie<K, V>, V) -> X,\n  fail : () -> X\n) : X {\n  let (t2, ov) = replace(t, k, k_eq, null);\n  switch ov {\n    case null { /* no prior value; failure to remove */ fail() };\n    case (?v) { success(t2, v) };\n  }\n}"},"remove2D":{"desc":"remove the given key-key pair's value in the 2D trie; return the\nnew trie, and the prior value, if any.","body":"public func remove2D<K1, K2, V>(\n  t : Trie2D<K1, K2, V>,\n  k1 : Key<K1>,\n  k1_eq : (K1, K1) -> Bool,\n  k2 : Key<K2>,\n  k2_eq : (K2, K2) -> Bool\n) : (Trie2D<K1, K2, V>, ?V)  {\n  switch (find(t, k1, k1_eq)) {\n    case null {\n      (t, null)\n    };\n    case (?inner) {\n      let (updated_inner, ov) = remove(inner, k2, k2_eq);\n      let (updated_outer, _) = put(t, k1, k1_eq, updated_inner);\n      (updated_outer, ov)\n    };\n  }\n}"},"remove3D":{"desc":"Remove the given key-key pair's value in the 3D trie; return the\nnew trie, and the prior value, if any.","body":"public func remove3D<K1, K2, K3, V>(\n  t : Trie3D<K1, K2, K3, V>,\n  k1 : Key<K1>,\n  k1_eq : (K1, K1) -> Bool,\n  k2 : Key<K2>,\n  k2_eq : (K2, K2) -> Bool,\n  k3 : Key<K3>,\n  k3_eq : (K3, K3) -> Bool,\n) : (Trie3D<K1, K2, K3, V>, ?V) {\n  switch (find(t, k1, k1_eq)) {\n    case null {\n      (t, null)\n    };\n    case (?inner) {\n      let (updated_inner, ov) = remove2D(inner, k2, k2_eq, k3, k3_eq);\n      let (updated_outer, _) = put(t, k1, k1_eq, updated_inner);\n      (updated_outer, ov)\n    };\n  }\n}"},"mergeDisjoint2D":{"desc":"Like [`mergeDisjoint`](#mergedisjoint), except instead of merging a\npair, it merges the collection of dimension-2 sub-trees of a 2D\ntrie.","body":"public func mergeDisjoint2D<K1, K2, V>(\n  t : Trie2D<K1, K2, V>,\n  k1_eq : (K1, K1) -> Bool,\n  k2_eq : (K2, K2) -> Bool\n) : Trie<K2, V> {\n  foldUp(\n    t,\n    func (t1 : Trie<K2, V>, t2 : Trie<K2, V>) : Trie<K2, V> {\n      mergeDisjoint(t1, t2, k2_eq)\n    },\n    func (_ : K1, t : Trie<K2, V>) : Trie<K2, V> { t },\n    #empty\n  )\n}"},"class.lenClamp":{"desc":"Return the list length unless the number of items in the list exceeds\na maximum value. If the list length exceed the maximum, the function\nreturns `null`.","body":"public func lenClamp<T>(l : List<T>, max : Nat) : ?Nat {\n  func rec(l : List<T>, max : Nat, i : Nat) : ?Nat {\n    switch l {\n      case null { ?i };\n      case (?(_, t)) {\n        if ( i > max ) { null }\n        else { rec(t, max, i + 1) }\n      };\n    }\n  };\n  rec(l, max, 0)\n}"},"class.Build":{"desc":"The build of a trie, as an AST for a simple DSL.","body":"public type Build<K, V> = {\n  #skip ;\n  #put : (K, ?Hash.Hash, V) ;\n  #seq : {\n    size : Nat;\n    left : Build<K, V>;\n    right : Build<K, V>;\n  } ;\n}"},"class.size":{"desc":"Size of the build, measured in `#put` operations","body":"public func size<K, V>(tb : Build<K, V>) : Nat {\n  switch tb {\n    case (#skip) { 0 };\n    case (#put(_, _, _)) { 1 };\n    case (#seq(seq)) { seq.size };\n  }\n}"},"class.seq":{"desc":"Build sequence of two sub-builds","body":"public func seq<K, V>(l : Build<K, V>, r : Build<K, V>) : Build<K, V> {\n    let sum = size(l) + size(r);\n    #seq({ size = sum; left = l; right = r })\n  };"},"class.prod":{"desc":"Like [`prod`](#prod), except do not actually do the put calls, just\nrecord them, as a (binary tree) data structure, isomorphic to the\nrecursion of this function (which is balanced, in expectation).","body":"public func prod<K1, V1, K2, V2, K3, V3>(\n  tl : Trie<K1, V1>,\n  tr : Trie<K2, V2>,\n  op : (K1, V1, K2, V2) -> ?(K3, V3),\n  k3_eq : (K3, K3) -> Bool\n) : Build<K3, V3> {\n\n  func outer_bin (a : Build<K3, V3>, b : Build<K3, V3>)\n    : Build<K3, V3> {\n      seq(a, b)\n    };\n\n  func inner_bin (a : Build<K3, V3>, b : Build<K3, V3>)\n    : Build<K3, V3> {\n      seq(a, b)\n    };\n\n  /// double-nested folds\n  foldUp(\n    tl, outer_bin,\n    func (k1 : K1, v1 : V1) : Build<K3, V3> {\n      foldUp(\n        tr, inner_bin,\n        func (k2 : K2, v2 : V2) : Build<K3, V3> {\n          switch (op(k1, v1, k2, v2)) {\n            case null { #skip };\n            case (?(k3, v3)) { #put(k3, null, v3) };\n          }\n        },\n        #skip\n      )\n    },\n    #skip\n  )\n}"},"class.nth":{"desc":"Project the nth key-value pair from the trie build.\n\nThis position is meaningful only when the build contains multiple uses of one or more keys, otherwise it is not.","body":"public func nth<K, V>(tb : Build<K, V>, i : Nat) : ?(K, ?Hash.Hash, V) {\n    func rec(tb : Build<K, V>, i : Nat) : ?(K, ?Hash.Hash, V) {\n      switch tb {\n        case (#skip) { P.unreachable() };\n        case (#put(k, h, v)) {\n          assert(i == 0);\n          ?(k, h, v)\n         };\n         case (#seq(s)) {\n           let size_left = size(s.left);\n           if (i < size_left) { rec(s.left,  i) }\n           else { rec(s.right, i - size_left) }\n         };\n      }\n    };\n\n    if (i >= size(tb)) {\n      return null\n    };\n    rec(tb, i)\n  };"},"class.projectInner":{"desc":"Like [`mergeDisjoint`](#mergedisjoint), except that it avoids the\nwork of actually merging any tries; rather, just record the work for\nlatter (if ever).","body":"public func projectInner<K1, K2, V>(t : Trie<K1, Build<K2, V>>)\n  : Build<K2, V> {\n  foldUp(\n    t,\n    func (t1 : Build<K2, V>, t2 : Build<K2, V>) : Build<K2, V> { seq(t1, t2) },\n    func (_ : K1, t : Build<K2, V>) : Build<K2, V> { t },\n    #skip\n  )\n}"},"class.toArray":{"desc":"Gather the collection of key-value pairs into an array of a (possibly-distinct) type.","body":"public func toArray<K, V, W>(tb : Build<K, V>, f: (K, V) -> W) : [W] {\n  let c = size(tb);\n  let a = A.init<?W>(c, null);\n  var i = 0;\n  func rec(tb : Build<K, V>) {\n    switch tb {\n      case (#skip) {};\n      case (#put(k, _, v)) { a[i] := ?f(k, v); i := i + 1 };\n      case (#seq(s)) { rec(s.left); rec(s.right) };\n    }\n  };\n  rec(tb);\n  A.tabulate(c, func(i : Nat) : W {\n    switch (a[i]) {\n      case null { P.unreachable() };\n      case (?x) { x }\n    }})\n}"}},"other":"let MAX_LEAF_SIZE = 8; // to do -- further profiling and tuning\ntype List<T> = List.List<T>;\n///  Get the number of key-value pairs in the trie, in constant time.\nmodule ListUtil {\n  /* Deprecated: List.lenClamp *;\n};\n/// Represent the construction of tries as data.\n/// This module provides optimized variants of normal tries, for\n/// more efficient join queries.\n/// The central insight is that for (unmaterialized) join query results, we\n/// do not need to actually build any resulting trie of the resulting\n/// data, but rather, just need a collection of what would be in that\n/// trie.  Since query results can be large (quadratic in the DB size),\n/// avoiding the construction of this trie provides a considerable savings.\n/// To get this savings, we use an ADT for the operations that _would_ build this trie,\n/// if evaluated. This structure specializes a rope: a balanced tree representing a\n/// sequence.  It is only as balanced as the tries from which we generate\n/// these build ASTs.  They have no intrinsic balance properties of their\n/// own.\npublic module Build {\n};","test":""}